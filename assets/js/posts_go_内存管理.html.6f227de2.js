"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7711],{6262:(l,i)=>{i.A=(l,i)=>{const e=l.__vccOpts||l;for(const[l,n]of i)e[l]=n;return e}},3155:(l,i,e)=>{e.r(i),e.d(i,{comp:()=>o,data:()=>a});var n=e(641);const t={},o=(0,e(6262).A)(t,[["render",function(l,i){return(0,n.uX)(),(0,n.CE)("div",null,i[0]||(i[0]=[(0,n.Fv)('<h3 id="栈内存管理" tabindex="-1"><a class="header-anchor" href="#栈内存管理"><span>栈内存管理</span></a></h3><ol><li>先进后出</li><li>内存空间大小在编译时确定</li><li>速度快</li><li>栈内存主要用于存储局部变量、函数参数等临时数据。</li><li>编译器管理</li></ol><h3 id="堆内存管理" tabindex="-1"><a class="header-anchor" href="#堆内存管理"><span>堆内存管理</span></a></h3><ol><li>后进先出</li><li>内存空间大小在运行时确定</li><li>速度较慢</li><li>堆内存主要用于存储动态分配的数据。</li><li>运行时系统管理</li><li>可以通过new关键字来分配堆内存（Go中new出来的对象可不一定分配在堆上）</li><li>堆内存管理采用了垃圾回收机制，由内存分配器和垃圾收集器</li><li>内存分配器采用了TCMalloc（Thread-Caching Malloc）的设计思想</li><li>内存分配器负责分配堆内存</li><li>垃圾收集器采用了标记-清除算法</li></ol><h3 id="垃圾收集器工作原理-回收不再使用的堆内存-基于三色标记和写屏障的混合算法" tabindex="-1"><a class="header-anchor" href="#垃圾收集器工作原理-回收不再使用的堆内存-基于三色标记和写屏障的混合算法"><span>垃圾收集器工作原理（回收不再使用的堆内存）（基于三色标记和写屏障的混合算法）</span></a></h3><ol><li>标记所有存活的对象</li><li>清除所有未标记的对象</li><li>垃圾收集器是并发的（在程序运行的同时进行回收工作，聊聊如何实现的）</li></ol><h3 id="go语言内存管理的最佳实践-提高go语言程序的内存管理效率" tabindex="-1"><a class="header-anchor" href="#go语言内存管理的最佳实践-提高go语言程序的内存管理效率"><span>Go语言内存管理的最佳实践(提高Go语言程序的内存管理效率)</span></a></h3><ol><li>尽量使用局部变量</li><li>避免使用全局变量</li><li>及时释放不再使用的内存</li><li>使用make关键字来分配切片、映射等复合类型的数据</li><li>使用sync.Pool来管理对象池</li></ol>',8)]))}]]),a=JSON.parse('{"path":"/posts/go/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html","title":"内存管理","lang":"zh-CN","frontmatter":{"title":"内存管理","tags":["golang"],"categories":["golang"],"description":"栈内存管理 先进后出 内存空间大小在编译时确定 速度快 栈内存主要用于存储局部变量、函数参数等临时数据。 编译器管理 堆内存管理 后进先出 内存空间大小在运行时确定 速度较慢 堆内存主要用于存储动态分配的数据。 运行时系统管理 可以通过new关键字来分配堆内存（Go中new出来的对象可不一定分配在堆上） 堆内存管理采用了垃圾回收机制，由内存分配器和垃圾...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"内存管理"}],["meta",{"property":"og:description","content":"栈内存管理 先进后出 内存空间大小在编译时确定 速度快 栈内存主要用于存储局部变量、函数参数等临时数据。 编译器管理 堆内存管理 后进先出 内存空间大小在运行时确定 速度较慢 堆内存主要用于存储动态分配的数据。 运行时系统管理 可以通过new关键字来分配堆内存（Go中new出来的对象可不一定分配在堆上） 堆内存管理采用了垃圾回收机制，由内存分配器和垃圾..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"golang"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"内存管理\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"栈内存管理","slug":"栈内存管理","link":"#栈内存管理","children":[]},{"level":3,"title":"堆内存管理","slug":"堆内存管理","link":"#堆内存管理","children":[]},{"level":3,"title":"垃圾收集器工作原理（回收不再使用的堆内存）（基于三色标记和写屏障的混合算法）","slug":"垃圾收集器工作原理-回收不再使用的堆内存-基于三色标记和写屏障的混合算法","link":"#垃圾收集器工作原理-回收不再使用的堆内存-基于三色标记和写屏障的混合算法","children":[]},{"level":3,"title":"Go语言内存管理的最佳实践(提高Go语言程序的内存管理效率)","slug":"go语言内存管理的最佳实践-提高go语言程序的内存管理效率","link":"#go语言内存管理的最佳实践-提高go语言程序的内存管理效率","children":[]}],"readingTime":{"minutes":1.32,"words":397},"filePathRelative":"posts/go/内存管理.md","excerpt":"<h3>栈内存管理</h3>\\n<ol>\\n<li>先进后出</li>\\n<li>内存空间大小在编译时确定</li>\\n<li>速度快</li>\\n<li>栈内存主要用于存储局部变量、函数参数等临时数据。</li>\\n<li>编译器管理</li>\\n</ol>\\n<h3>堆内存管理</h3>\\n<ol>\\n<li>后进先出</li>\\n<li>内存空间大小在运行时确定</li>\\n<li>速度较慢</li>\\n<li>堆内存主要用于存储动态分配的数据。</li>\\n<li>运行时系统管理</li>\\n<li>可以通过new关键字来分配堆内存（Go中new出来的对象可不一定分配在堆上）</li>\\n<li>堆内存管理采用了垃圾回收机制，由内存分配器和垃圾收集器</li>\\n<li>内存分配器采用了TCMalloc（Thread-Caching Malloc）的设计思想</li>\\n<li>内存分配器负责分配堆内存</li>\\n<li>垃圾收集器采用了标记-清除算法</li>\\n</ol>","autoDesc":true}')}}]);