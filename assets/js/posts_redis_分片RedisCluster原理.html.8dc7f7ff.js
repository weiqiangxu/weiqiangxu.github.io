"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5689],{6262:(s,e)=>{e.A=(s,e)=>{const i=s.__vccOpts||s;for(const[s,a]of e)i[s]=a;return i}},2958:(s,e,i)=>{i.r(e),i.d(e,{comp:()=>l,data:()=>t});var a=i(641);const n={},l=(0,i(6262).A)(n,[["render",function(s,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h1 id="集群分片" tabindex="-1"><a class="header-anchor" href="#集群分片"><span>集群分片</span></a></h1><blockquote><p>主从只是扩展了读，但是写和存储能力并未得到扩展</p></blockquote><h3 id="关键模块" tabindex="-1"><a class="header-anchor" href="#关键模块"><span>关键模块</span></a></h3><ol><li><p>哈希槽(Hash Slot)(数量是2^14=16384)，Cluster每个节点负责一部分哈希槽</p></li><li><p>Keys hash tags 将相关Key分配到相同的hash slot</p></li><li><p>Cluster nodes属性</p></li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>redis-cli cluster nodes</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots.</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Cluster总线</p><ol start="4"><li>Cluster总线</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>节点之间通讯使用集群总线和集群总线协议：有不同的类型和大小的帧组成的二进制协议</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="5"><li><p>集群拓扑</p></li><li><p>节点握手</p></li></ol><h3 id="请求重定向" tabindex="-1"><a class="header-anchor" href="#请求重定向"><span>请求重定向</span></a></h3><blockquote><p>去中心化思想，集群主节点各自负责一部分槽</p></blockquote><h3 id="moved重定向" tabindex="-1"><a class="header-anchor" href="#moved重定向"><span>MOVED重定向</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>客户端发送key命令，节点检查不存在会返回Moved 重定向，客户端收到以后会根据Moved再一次发送找寻目标节点</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>redis-cli -c </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>-c 是集群方式启动，即没加参数 -c，redis-cli不会自动重定向</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ask重定向" tabindex="-1"><a class="header-anchor" href="#ask重定向"><span>Ask重定向</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用Ask重定向来解决此种情况</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="扩容-缩容" tabindex="-1"><a class="header-anchor" href="#扩容-缩容"><span>扩容&amp;缩容</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>扩容</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1. 节点纳入，cluster meet new_node_ip:new_node_port 或者 redis-trib add node</span></span>\n<span class="line"><span>2. 数据迁移，将槽迁移到目标节点</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>缩容</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1. 槽迁移</span></span>\n<span class="line"><span>2. 广播下线 cluster forget nodeId</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="为什么redis-cluster的hash-slot-是2-14-16-1024" tabindex="-1"><a class="header-anchor" href="#为什么redis-cluster的hash-slot-是2-14-16-1024"><span>为什么Redis Cluster的Hash Slot 是2^14=16*1024</span></a></h3><h3 id="为什么redis-cluster中不建议使用发布订阅" tabindex="-1"><a class="header-anchor" href="#为什么redis-cluster中不建议使用发布订阅"><span>为什么Redis Cluster中不建议使用发布订阅</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>所有的publish命令都会向所有节点（包括从节点）进行广播，带宽消耗大</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="经典面试题" tabindex="-1"><a class="header-anchor" href="#经典面试题"><span>经典面试题</span></a></h3><ol><li>数据如何分部在切片实例中</li><li>重定向机制</li><li></li></ol><h3 id="分片模式添加数据的逻辑" tabindex="-1"><a class="header-anchor" href="#分片模式添加数据的逻辑"><span>分片模式添加数据的逻辑</span></a></h3><ol><li>key 转 hash槽，hash槽 转 节点</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>key (CRC16算法) &gt;&gt;&gt; 16 bit</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>16 bit &gt;&gt;&gt;  1024*16 (16384) 取模  = hash槽值</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>实例和哈希槽的映射关系不是固定的</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>实例出现了新增或者删除，重新分配哈希槽，哈希槽在所有实例上重新分布一遍</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="如果有3个实例-而-test-数据分配在实例2的哈希槽之中-那么在实例1执行-get-test-的数据会发生什么" tabindex="-1"><a class="header-anchor" href="#如果有3个实例-而-test-数据分配在实例2的哈希槽之中-那么在实例1执行-get-test-的数据会发生什么"><span>如果有3个实例，而 test 数据分配在实例2的哈希槽之中，那么在实例1执行 get test 的数据会发生什么</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>客户端在实例1执行 get test</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>客户端收到MOVED命令后</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>客户端会再次向实例2发送请求</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>并更新客户端本地缓存中维护的哈希槽和实例的映射关系</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ask响应-和-moved响应" tabindex="-1"><a class="header-anchor" href="#ask响应-和-moved响应"><span>ASK响应 和 MOVED响应</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>收到ask响应后虽然也和moved一样会继续请求新的实例</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>但是并不会更新客户端本地缓存中维护的哈希槽和实例的映射关系</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>收到 MOVEND响应会 更新本地维护的哈希槽和实例的映射关系缓存</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="分片模式到底有没有数据拷贝-有没有同步异步复制的过程" tabindex="-1"><a class="header-anchor" href="#分片模式到底有没有数据拷贝-有没有同步异步复制的过程"><span>分片模式到底有没有数据拷贝？有没有同步异步复制的过程？</span></a></h3><h3 id="分片的缺点" tabindex="-1"><a class="header-anchor" href="#分片的缺点"><span>分片的缺点</span></a></h3><ol><li>无法直接对映射在两个不同 Redis 实例上的键执行交集 (涉及多个键的操作通常不支持)</li><li>涉及多个键的事务不能使用</li><li>备份数据时需要聚合多个实例和主机的持久化文件</li></ol><h3 id="redis-分片副本" tabindex="-1"><a class="header-anchor" href="#redis-分片副本"><span>redis 分片副本</span></a></h3><p><a href="https://baijiahao.baidu.com/s?id=1748526448763042395" target="_blank" rel="noopener noreferrer">深入了解 Redis 集群：分片算法和架构</a></p><ol><li>去中心化服务器端分片 - 官方 Redis 集群中实际使用的</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>请求可以命中任何 Redis 节点</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>每个节点都知道集群中的所有其他节点</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>处理请求的节点将首先检查自身或其他节点是否具有请求的数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>如果数据存储在其他地方，则将请求重定向到相应的节点</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>分片算法</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>一致的哈希</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Redis 集群中使用的哈希槽分片</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>slot = CRC16(key) % 16383</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://cloud.tencent.com/developer/article/1792305" target="_blank" rel="noopener noreferrer">分片详解</a></p><p><a href="https://developer.aliyun.com/article/845366" target="_blank" rel="noopener noreferrer">分片的高可用方案</a></p><h1 id="full-stack-knowledge-system" tabindex="-1"><a class="header-anchor" href="#full-stack-knowledge-system"><span>Full_stack_knowledge_system</span></a></h1><p><a href="https://pdai.tech/" target="_blank" rel="noopener noreferrer">pdai.tech</a></p>',43)]))}]]),t=JSON.parse('{"path":"/posts/redis/%E5%88%86%E7%89%87RedisCluster%E5%8E%9F%E7%90%86.html","title":"集群分片","lang":"zh-CN","frontmatter":{"hide":true,"description":"集群分片 主从只是扩展了读，但是写和存储能力并未得到扩展 关键模块 哈希槽(Hash Slot)(数量是2^14=16384)，Cluster每个节点负责一部分哈希槽 Keys hash tags 将相关Key分配到相同的hash slot Cluster nodes属性 Cluster总线 Cluster总线 集群拓扑 节点握手 请求重定向 去中心化...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/redis/%E5%88%86%E7%89%87RedisCluster%E5%8E%9F%E7%90%86.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"集群分片"}],["meta",{"property":"og:description","content":"集群分片 主从只是扩展了读，但是写和存储能力并未得到扩展 关键模块 哈希槽(Hash Slot)(数量是2^14=16384)，Cluster每个节点负责一部分哈希槽 Keys hash tags 将相关Key分配到相同的hash slot Cluster nodes属性 Cluster总线 Cluster总线 集群拓扑 节点握手 请求重定向 去中心化..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"集群分片\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"关键模块","slug":"关键模块","link":"#关键模块","children":[]},{"level":3,"title":"请求重定向","slug":"请求重定向","link":"#请求重定向","children":[]},{"level":3,"title":"MOVED重定向","slug":"moved重定向","link":"#moved重定向","children":[]},{"level":3,"title":"Ask重定向","slug":"ask重定向","link":"#ask重定向","children":[]},{"level":3,"title":"扩容&缩容","slug":"扩容-缩容","link":"#扩容-缩容","children":[]},{"level":3,"title":"为什么Redis Cluster的Hash Slot 是2^14=16*1024","slug":"为什么redis-cluster的hash-slot-是2-14-16-1024","link":"#为什么redis-cluster的hash-slot-是2-14-16-1024","children":[]},{"level":3,"title":"为什么Redis Cluster中不建议使用发布订阅","slug":"为什么redis-cluster中不建议使用发布订阅","link":"#为什么redis-cluster中不建议使用发布订阅","children":[]},{"level":3,"title":"经典面试题","slug":"经典面试题","link":"#经典面试题","children":[]},{"level":3,"title":"分片模式添加数据的逻辑","slug":"分片模式添加数据的逻辑","link":"#分片模式添加数据的逻辑","children":[]},{"level":3,"title":"如果有3个实例，而 test 数据分配在实例2的哈希槽之中，那么在实例1执行 get test 的数据会发生什么","slug":"如果有3个实例-而-test-数据分配在实例2的哈希槽之中-那么在实例1执行-get-test-的数据会发生什么","link":"#如果有3个实例-而-test-数据分配在实例2的哈希槽之中-那么在实例1执行-get-test-的数据会发生什么","children":[]},{"level":3,"title":"ASK响应 和 MOVED响应","slug":"ask响应-和-moved响应","link":"#ask响应-和-moved响应","children":[]},{"level":3,"title":"分片模式到底有没有数据拷贝？有没有同步异步复制的过程？","slug":"分片模式到底有没有数据拷贝-有没有同步异步复制的过程","link":"#分片模式到底有没有数据拷贝-有没有同步异步复制的过程","children":[]},{"level":3,"title":"分片的缺点","slug":"分片的缺点","link":"#分片的缺点","children":[]},{"level":3,"title":"redis 分片副本","slug":"redis-分片副本","link":"#redis-分片副本","children":[]}],"readingTime":{"minutes":3.26,"words":978},"filePathRelative":"posts/redis/分片RedisCluster原理.md","excerpt":"\\n<blockquote>\\n<p>主从只是扩展了读，但是写和存储能力并未得到扩展</p>\\n</blockquote>\\n<h3>关键模块</h3>\\n<ol>\\n<li>\\n<p>哈希槽(Hash Slot)(数量是2^14=16384)，Cluster每个节点负责一部分哈希槽</p>\\n</li>\\n<li>\\n<p>Keys hash tags 将相关Key分配到相同的hash slot</p>\\n</li>\\n<li>\\n<p>Cluster nodes属性</p>\\n</li>\\n</ol>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>redis-cli cluster nodes</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots.</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);