"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[489],{6262:(e,s)=>{s.A=(e,s)=>{const i=e.__vccOpts||e;for(const[e,a]of s)i[e]=a;return i}},4205:(e,s,i)=>{i.r(s),i.d(s,{comp:()=>l,data:()=>t});var a=i(641);const n={},l=(0,i(6262).A)(n,[["render",function(e,s){return(0,a.uX)(),(0,a.CE)("div",null,s[0]||(s[0]=[(0,a.Fv)('<h1 id="redis的过期删除和内存淘汰" tabindex="-1"><a class="header-anchor" href="#redis的过期删除和内存淘汰"><span>Redis的过期删除和内存淘汰</span></a></h1><h3 id="过期字典" tabindex="-1"><a class="header-anchor" href="#过期字典"><span>过期字典</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>哈希表</span></span>\n<span class="line"><span>struct{ key,expired_timestamp }</span></span>\n<span class="line"><span>key存在过期字典之中且 system_timestamp &gt; expired_timestamp 表示已经过期</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="过期删除策略" tabindex="-1"><a class="header-anchor" href="#过期删除策略"><span>过期删除策略</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>定时(设置key过期就针对这个key创建定时事件，CPU开销大但内存删除很及时)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>惰性(key被访问时如果过期了就删除)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>定期(隔段时间随机检查一定数量的key过期就删除)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="redis的是-惰性-定期" tabindex="-1"><a class="header-anchor" href="#redis的是-惰性-定期"><span>Redis的是 惰性 + 定期</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>间隔每秒10次 (redis.conf.hz 10)</span></span>\n<span class="line"><span>随机抽查的数量20 (过期数量&gt;25%就立刻再查一次)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="内存淘汰策略" tabindex="-1"><a class="header-anchor" href="#内存淘汰策略"><span>内存淘汰策略</span></a></h3><blockquote><p>redis运行内存达到阙值就会删除符合条件的key</p></blockquote><h3 id="内存阙值" tabindex="-1"><a class="header-anchor" href="#内存阙值"><span>内存阙值</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>redis.conf.maxmemory</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>64bit system default 0 无限制</span></span>\n<span class="line"><span>32bit system default 3G</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="默认是不进行内存淘汰-达到阙值后不再提供服务直接返回错误" tabindex="-1"><a class="header-anchor" href="#默认是不进行内存淘汰-达到阙值后不再提供服务直接返回错误"><span>默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误</span></a></h3><blockquote><p>redis.conf.maxmemory-policy</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>noeviction 不淘汰而是拒绝服务(Reids3.0 之后默认)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>volatile-random 设置了过期的随机淘汰</span></span>\n<span class="line"><span>volatile-ttl 优先早过期的淘汰</span></span>\n<span class="line"><span>allkeys-lru 淘汰最少使用的(important)</span></span>\n<span class="line"><span>allkeys-random 随机淘汰</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lru算法-least-recently-used-最近最少使用" tabindex="-1"><a class="header-anchor" href="#lru算法-least-recently-used-最近最少使用"><span>LRU算法( Least Recently Used ) 最近最少使用</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>链表实现</span></span>\n<span class="line"><span>访问过的数据移动到链表头部</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="lfu算法-least-frequently-used-最近最不常用通过记录访问频次" tabindex="-1"><a class="header-anchor" href="#lfu算法-least-frequently-used-最近最不常用通过记录访问频次"><span>LFU算法(Least Frequently Used) 最近最不常用通过记录访问频次</span></a></h3>',17)]))}]]),t=JSON.parse('{"path":"/posts/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0.html","title":"Redis的过期删除和内存淘汰","lang":"zh-CN","frontmatter":{"hide":true,"description":"Redis的过期删除和内存淘汰 过期字典 过期删除策略 Redis的是 惰性 + 定期 内存淘汰策略 redis运行内存达到阙值就会删除符合条件的key 内存阙值 默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误 redis.conf.maxmemory-policy LRU算法( Least Recently Used ) 最近最少使用 LF...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"Redis的过期删除和内存淘汰"}],["meta",{"property":"og:description","content":"Redis的过期删除和内存淘汰 过期字典 过期删除策略 Redis的是 惰性 + 定期 内存淘汰策略 redis运行内存达到阙值就会删除符合条件的key 内存阙值 默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误 redis.conf.maxmemory-policy LRU算法( Least Recently Used ) 最近最少使用 LF..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis的过期删除和内存淘汰\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"过期字典","slug":"过期字典","link":"#过期字典","children":[]},{"level":3,"title":"过期删除策略","slug":"过期删除策略","link":"#过期删除策略","children":[]},{"level":3,"title":"Redis的是 惰性 + 定期","slug":"redis的是-惰性-定期","link":"#redis的是-惰性-定期","children":[]},{"level":3,"title":"内存淘汰策略","slug":"内存淘汰策略","link":"#内存淘汰策略","children":[]},{"level":3,"title":"内存阙值","slug":"内存阙值","link":"#内存阙值","children":[]},{"level":3,"title":"默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误","slug":"默认是不进行内存淘汰-达到阙值后不再提供服务直接返回错误","link":"#默认是不进行内存淘汰-达到阙值后不再提供服务直接返回错误","children":[]},{"level":3,"title":"LRU算法( Least Recently Used ) 最近最少使用","slug":"lru算法-least-recently-used-最近最少使用","link":"#lru算法-least-recently-used-最近最少使用","children":[]},{"level":3,"title":"LFU算法(Least Frequently Used) 最近最不常用通过记录访问频次","slug":"lfu算法-least-frequently-used-最近最不常用通过记录访问频次","link":"#lfu算法-least-frequently-used-最近最不常用通过记录访问频次","children":[]}],"readingTime":{"minutes":1.07,"words":321},"filePathRelative":"posts/redis/过期删除和内存淘汰.md","excerpt":"\\n<h3>过期字典</h3>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>哈希表</span></span>\\n<span class=\\"line\\"><span>struct{ key,expired_timestamp }</span></span>\\n<span class=\\"line\\"><span>key存在过期字典之中且 system_timestamp &gt; expired_timestamp 表示已经过期</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);