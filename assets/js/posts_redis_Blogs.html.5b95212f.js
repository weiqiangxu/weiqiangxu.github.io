"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6783],{6262:(e,i)=>{i.A=(e,i)=>{const t=e.__vccOpts||e;for(const[e,p]of i)t[e]=p;return t}},5653:(e,i,t)=>{t.r(i),t.d(i,{comp:()=>n,data:()=>l});var p=t(641);const a={},n=(0,t(6262).A)(a,[["render",function(e,i){return(0,p.uX)(),(0,p.CE)("div",null,i[0]||(i[0]=[(0,p.Fv)('<h1 id="使用redis搭建博客" tabindex="-1"><a class="header-anchor" href="#使用redis搭建博客"><span>使用Redis搭建博客</span></a></h1><ol><li><p>存储文章内容k-v形式存储字符串(序列化内容)</p></li><li><p>文章访问量自增 INCRBY</p></li><li><p>文章内容访问或更改属性麻烦更换为散列 HSET key field value</p></li><li><p>获取文章列表使用列表类型list LPUSH RPUSH LPOP RPOP</p></li><li><p>文章的标签tags存储使用集合类型 SCARD key</p></li><li><p>文章按照访问量排序 - 有序集合 ZCOUNT key min max</p></li></ol><h1 id="基础" tabindex="-1"><a class="header-anchor" href="#基础"><span>基础</span></a></h1>',3),(0,p.Lk)("ol",null,[(0,p.Lk)("li",{name:""},"字符串类型 简单的一对一映射关系，刚开始采用序列化数组为字符串存储"),(0,p.Lk)("li",null,"哈希类型 存储对象，并且可以直接对对象的某一个属性进行增删改查 {id => {'name':'jack','title'=>'taitannike','time'=>'2018-08-08 15:20'}}"),(0,p.Lk)("li",null,"列表类型（改变某一个的顺序需要把列表的每一个元素全部重新排列） 获取文章列表分页数据的时候，需要用列表，但是依然需要解决排序、取中间片段速度缓慢的问题 [1,2,3,4,5]"),(0,p.Lk)("li",{"美食,旅行,装饰":""},"集合类型 存储文章标签的时候，如何做到标签唯一，有就无操作无就存入. id =>"),(0,p.Lk)("li",null,"有序集合类型 - (散列+跳跃表实现，所以中间存取也是极快) 号称最高级的数据类型，就是序号加值，但是他可以做到按序号大小获取中间片段，以及按大小排序 {score => {['89','tom'],['99','marry']}}")],-1),(0,p.Fv)('<h1 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h1><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：</p><p>String（字符串）</p><p>Hash（哈希）</p><p>List（列表）</p><p>Set（集合）</p><p>Zset（有序集合）。</p><h1 id="进阶" tabindex="-1"><a class="header-anchor" href="#进阶"><span>进阶</span></a></h1><p>1、事务</p><p>2、生存时间</p><p>3、排序</p><p>4、消息通知</p><h1 id="管理" tabindex="-1"><a class="header-anchor" href="#管理"><span>管理</span></a></h1><p>1、持久化</p><p>2、复制</p><p>3、安全</p><p>4、通信协议</p><p>5、管理工具</p>',18)]))}]]),l=JSON.parse('{"path":"/posts/redis/Blogs.html","title":"使用Redis搭建博客","lang":"zh-CN","frontmatter":{"hide":true,"description":"使用Redis搭建博客 存储文章内容k-v形式存储字符串(序列化内容) 文章访问量自增 INCRBY 文章内容访问或更改属性麻烦更换为散列 HSET key field value 获取文章列表使用列表类型list LPUSH RPUSH LPOP RPOP 文章的标签tags存储使用集合类型 SCARD key 文章按照访问量排序 - 有序集合 ZC...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/redis/Blogs.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"使用Redis搭建博客"}],["meta",{"property":"og:description","content":"使用Redis搭建博客 存储文章内容k-v形式存储字符串(序列化内容) 文章访问量自增 INCRBY 文章内容访问或更改属性麻烦更换为散列 HSET key field value 获取文章列表使用列表类型list LPUSH RPUSH LPOP RPOP 文章的标签tags存储使用集合类型 SCARD key 文章按照访问量排序 - 有序集合 ZC..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"使用Redis搭建博客\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[],"readingTime":{"minutes":1.53,"words":459},"filePathRelative":"posts/redis/Blogs.md","excerpt":"\\n<ol>\\n<li>\\n<p>存储文章内容k-v形式存储字符串(序列化内容)</p>\\n</li>\\n<li>\\n<p>文章访问量自增 INCRBY</p>\\n</li>\\n<li>\\n<p>文章内容访问或更改属性麻烦更换为散列 HSET key field value</p>\\n</li>\\n<li>\\n<p>获取文章列表使用列表类型list LPUSH RPUSH LPOP RPOP</p>\\n</li>\\n<li>\\n<p>文章的标签tags存储使用集合类型 SCARD key</p>\\n</li>\\n<li>\\n<p>文章按照访问量排序 - 有序集合 ZCOUNT key min max</p>\\n</li>\\n</ol>","autoDesc":true}')}}]);