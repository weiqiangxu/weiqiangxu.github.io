"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6519],{6262:(e,o)=>{o.A=(e,o)=>{const a=e.__vccOpts||e;for(const[e,t]of o)a[e]=t;return a}},2486:(e,o,a)=>{a.r(o),a.d(o,{comp:()=>p,data:()=>r});var t=a(641);const n={},p=(0,a(6262).A)(n,[["render",function(e,o){return(0,t.uX)(),(0,t.CE)("div",null,o[0]||(o[0]=[(0,t.Fv)('<h1 id="原子操作" tabindex="-1"><a class="header-anchor" href="#原子操作"><span>原子操作</span></a></h1><h3 id="一、cas-compare-and-swap-原理" tabindex="-1"><a class="header-anchor" href="#一、cas-compare-and-swap-原理"><span>一、CAS（Compare-And-Swap）原理</span></a></h3><pre><code>一种用于实现原子操作的机制，用于在多线程或多协程（Goroutine）环境下，安全地更新共享变量的值。内存位置（变量的地址）、预期旧值和新值。基本思想是先比较内存位置中的值是否等于预期旧值，如果相等，表示获取值到准备更新时候没有其他线程更改过这个数据，选择更新这个数据。\n</code></pre><h3 id="二、cas为什么是线程安全的" tabindex="-1"><a class="header-anchor" href="#二、cas为什么是线程安全的"><span>二、cas为什么是线程安全的</span></a></h3><ol><li><p>执行值替换的动作是原子的</p><p>CAS（Compare-And-Swap）操作是原子性的(硬件层面CPU通常会提供一些指令来支持原子操作)。原子性意味着整个操作在执行过程中是不可分割的，它不会被其他线程（或 Go 语言中的 Goroutine）中断。那么不原子的是什么样子呢，比如自增操作<code>count++</code>，这个操作在编译器层面可能会被分解为：读取<code>count</code>的值，将其加<code>1</code>，再将新值写回count的内存位置这三个步骤。三个线程分别获取了count的旧值然后执行<code>++</code>，就会出现结果异常的情况。</p></li><li><p>基于预期旧值的比较机制</p><p>比较内存位置中的当前值与预期旧值，每个线程更新之前，比较一下已经拿到的初始值，和内存之中的值，如果没有变才会更新，如果变了，说明在这个期间有其他线程更新了这个数据，那么会放弃修改这个值。</p></li></ol><h3 id="相关资料" tabindex="-1"><a class="header-anchor" href="#相关资料"><span>相关资料</span></a></h3><ul><li><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E5%92%8Catomic%E5%8C%85.html" target="_blank" rel="noopener noreferrer">很细致的性能对比 &amp;&amp; 并发非安全引发错误示例</a></li><li><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></li></ul>',7)]))}]]),r=JSON.parse('{"path":"/posts/go/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.html","title":"原子操作","lang":"zh-CN","frontmatter":{"description":"原子操作 一、CAS（Compare-And-Swap）原理 二、cas为什么是线程安全的 执行值替换的动作是原子的 CAS（Compare-And-Swap）操作是原子性的(硬件层面CPU通常会提供一些指令来支持原子操作)。原子性意味着整个操作在执行过程中是不可分割的，它不会被其他线程（或 Go 语言中的 Goroutine）中断。那么不原子的是什么...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"原子操作"}],["meta",{"property":"og:description","content":"原子操作 一、CAS（Compare-And-Swap）原理 二、cas为什么是线程安全的 执行值替换的动作是原子的 CAS（Compare-And-Swap）操作是原子性的(硬件层面CPU通常会提供一些指令来支持原子操作)。原子性意味着整个操作在执行过程中是不可分割的，它不会被其他线程（或 Go 语言中的 Goroutine）中断。那么不原子的是什么..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"原子操作\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"一、CAS（Compare-And-Swap）原理","slug":"一、cas-compare-and-swap-原理","link":"#一、cas-compare-and-swap-原理","children":[]},{"level":3,"title":"二、cas为什么是线程安全的","slug":"二、cas为什么是线程安全的","link":"#二、cas为什么是线程安全的","children":[]},{"level":3,"title":"相关资料","slug":"相关资料","link":"#相关资料","children":[]}],"readingTime":{"minutes":1.58,"words":474},"filePathRelative":"posts/go/原子操作.md","excerpt":"\\n<h3>一、CAS（Compare-And-Swap）原理</h3>\\n<pre><code>一种用于实现原子操作的机制，用于在多线程或多协程（Goroutine）环境下，安全地更新共享变量的值。内存位置（变量的地址）、预期旧值和新值。基本思想是先比较内存位置中的值是否等于预期旧值，如果相等，表示获取值到准备更新时候没有其他线程更改过这个数据，选择更新这个数据。\\n</code></pre>\\n<h3>二、cas为什么是线程安全的</h3>\\n<ol>\\n<li>\\n<p>执行值替换的动作是原子的</p>\\n<p>CAS（Compare-And-Swap）操作是原子性的(硬件层面CPU通常会提供一些指令来支持原子操作)。原子性意味着整个操作在执行过程中是不可分割的，它不会被其他线程（或 Go 语言中的 Goroutine）中断。那么不原子的是什么样子呢，比如自增操作<code>count++</code>，这个操作在编译器层面可能会被分解为：读取<code>count</code>的值，将其加<code>1</code>，再将新值写回count的内存位置这三个步骤。三个线程分别获取了count的旧值然后执行<code>++</code>，就会出现结果异常的情况。</p>\\n</li>\\n<li>\\n<p>基于预期旧值的比较机制</p>\\n<p>比较内存位置中的当前值与预期旧值，每个线程更新之前，比较一下已经拿到的初始值，和内存之中的值，如果没有变才会更新，如果变了，说明在这个期间有其他线程更新了这个数据，那么会放弃修改这个值。</p>\\n</li>\\n</ol>","autoDesc":true}')}}]);