"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7618],{6262:(e,l)=>{l.A=(e,l)=>{const t=e.__vccOpts||e;for(const[e,a]of l)t[e]=a;return t}},6439:(e,l,t)=>{t.r(l),t.d(l,{comp:()=>r,data:()=>o});var a=t(641);const i={},r=(0,t(6262).A)(i,[["render",function(e,l){return(0,a.uX)(),(0,a.CE)("div",null,l[0]||(l[0]=[(0,a.Fv)('<h3 id="基本概念和相关术语" tabindex="-1"><a class="header-anchor" href="#基本概念和相关术语"><span>基本概念和相关术语</span></a></h3><p>管理复制日志的一致性算法。本质上是管理日志的，日志决定了Leader和Follower角色以及数据副本。</p><ul><li>任期（Term）： Raft算法将时间划分为多个任期。</li><li>日志（Log）： 客户端的请求以日志的形式进行记录。顺序性、每个节点存储、所有节点最终有相同的请求日志集合。</li><li>状态机（State Machine）：抽象计算模型，可以认为是一些状态的计算规则。Raft通过日志等输入状态机，来确定状态管理节点状态等。</li><li>节点状态：Follower（跟随者）、Candidate（候选者 - 无Leader时候Foller会转化为这个）、Leader（领导者）</li><li>选举触发：Follower 在一个称为选举超时时间（election timeout）内没有收到来自 Leader 的心跳时触发。</li><li>选举Leader的条件：Candidate 从大多数节点（超过集群节点总数的一半）获得了投票，它就会成为 Leader</li><li>投票过程：候选者将自己任期号（Term）+1然后向其他所有节点发送请求投票（候选者当前任期号、日志条目、自己的节点ID ）。</li><li>其他节点：任期号大于自己的任期号自己转变为跟随者、看候选者任期是否自己已经投给其他节点如果投了就拒绝投票、日志新旧程度新的会收到投票。</li><li>候选者：收到所有其他节点的票，如果票数大于集群数量一半比如5节点收到3票，会把自己升级为Leader并且立刻发送心跳消息（AppendEntries）宣告。</li></ul><ol><li>Leader选举过程</li></ol><ul><li>第一阶段：所有节点都是 Follower</li><li>第二阶段：Follower 转为 Candidate 并发起投票</li><li>第三阶段：投票策略(候选者向所有其他节点发消息请求投票)</li><li>第四阶段：Candidate 转为 Leader(自己计算如果得票超过集群数量一半) &gt;N/2</li></ul><ol start="2"><li>Raft算法中处理客户端请求的过程(安全性和强一致性)</li></ol><ul><li>第一阶段：客户端请求提交到 Leader</li><li>第二阶段：Leader 将 Entry(请求日志条目) 发送到其它 Follower</li><li>第三阶段：Leader 等待大多数（超过集群节点总数的一半）Follower 的回应(如果没有收到会重新发送日志条目或者调整复制策略)</li><li>第四阶段：Leader 回应客户端</li><li>第五阶段：Leader 会向所有的 Follower 发送通知这个日志条目已提交,可以将其应用到自己状态机中</li></ul><h3 id="q-a" tabindex="-1"><a class="header-anchor" href="#q-a"><span>Q&amp;A</span></a></h3><ol><li><p>Raft选主必须获得选票 &gt; N/2 才可以 ，那3个节点的宕机1个是不是永远无法选主了呢</p><p>不一定。即使其中一个节点宕机，只要剩下的两个节点仍然可以获得足够的选票（即大于N/2），它们仍然可以选出新的主节点。在Raft协议中，只要仍然有大多数节点存活且可以通信，集群就可以继续正常工作。 在 Raft 算法中，如果一个由 5 个节点组成的集群中有 3 个节点宕机，那么在这种情况下确实无法选出主节点。</p></li><li><p>为什么说2个节点的集群不可能是高可用集群</p><p>在一个只有两个节点的集群中，如果其中一个节点宕机，剩下的一个节点无法组成大多数（大于N/2），因此无法达成一致，也就无法选主。这样会导致集群无法正常工作，从而降低可用性。因此，一个只有两个节点的集群通常被认为不是高可用的，因为无法容忍单点故障。高可用集群通常是由多个节点组成，以确保即使有几个节点失效，集群仍然可以继续运行。</p></li><li><p>k8s如何基于Etcd实现选主用于控制平面组件(APIServer\\ControllerManager\\Scheduler)</p></li><li><p>Go的微服务启动3个Pod如何基于Etcd实现选主 3个Pod分别创建一个租约，然后将<code>/leader</code>key关联这个租约， 其他节点称为候选人之后监听租约，租约过期或被撤销，重新进行选主。</p></li><li><p>Go微服务使用租约选主，会不会说2个同时成为leader</p></li></ol><h3 id="相关文章" tabindex="-1"><a class="header-anchor" href="#相关文章"><span>相关文章</span></a></h3><ul><li><a href="https://juejin.cn/post/6907151199141625870" target="_blank" rel="noopener noreferrer">选主逻辑依赖任期（term）实现说的非常细致生动</a></li><li><a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%9E%E8%B7%B5%E4%B9%8B%E8%B7%AF%EF%BC%88%E5%AE%8C%EF%BC%89/09%20%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%E7%AE%97%E6%B3%95%20Raft%20%E5%92%8C%20Etcd%20%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90.md" target="_blank" rel="noopener noreferrer">分布式一致性算法Raft和Etcd原理解析</a></li><li><a href="https://zhuanlan.zhihu.com/p/405811320" target="_blank" rel="noopener noreferrer">ETCD介绍—etcd概念及原理方面分析</a></li><li><a href="https://toutiao.io/posts/clo2v3/preview" target="_blank" rel="noopener noreferrer">认识分布式系统etcd</a></li><li><a href="https://doczhcn.gitbook.io/etcd/index/index" target="_blank" rel="noopener noreferrer">etcd官方文档中文版</a></li></ul>',11)]))}]]),o=JSON.parse('{"path":"/posts/etcd/Raft%E7%AE%97%E6%B3%95.html","title":"Raft算法","lang":"zh-CN","frontmatter":{"title":"Raft算法","category":["etcd"],"tag":["etcd"],"description":"基本概念和相关术语 管理复制日志的一致性算法。本质上是管理日志的，日志决定了Leader和Follower角色以及数据副本。 任期（Term）： Raft算法将时间划分为多个任期。 日志（Log）： 客户端的请求以日志的形式进行记录。顺序性、每个节点存储、所有节点最终有相同的请求日志集合。 状态机（State Machine）：抽象计算模型，可以认为是...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/etcd/Raft%E7%AE%97%E6%B3%95.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"Raft算法"}],["meta",{"property":"og:description","content":"基本概念和相关术语 管理复制日志的一致性算法。本质上是管理日志的，日志决定了Leader和Follower角色以及数据副本。 任期（Term）： Raft算法将时间划分为多个任期。 日志（Log）： 客户端的请求以日志的形式进行记录。顺序性、每个节点存储、所有节点最终有相同的请求日志集合。 状态机（State Machine）：抽象计算模型，可以认为是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"etcd"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Raft算法\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"基本概念和相关术语","slug":"基本概念和相关术语","link":"#基本概念和相关术语","children":[]},{"level":3,"title":"Q&A","slug":"q-a","link":"#q-a","children":[]},{"level":3,"title":"相关文章","slug":"相关文章","link":"#相关文章","children":[]}],"readingTime":{"minutes":4.21,"words":1263},"filePathRelative":"posts/etcd/Raft算法.md","excerpt":"<h3>基本概念和相关术语</h3>\\n<p>管理复制日志的一致性算法。本质上是管理日志的，日志决定了Leader和Follower角色以及数据副本。</p>\\n<ul>\\n<li>任期（Term）： Raft算法将时间划分为多个任期。</li>\\n<li>日志（Log）： 客户端的请求以日志的形式进行记录。顺序性、每个节点存储、所有节点最终有相同的请求日志集合。</li>\\n<li>状态机（State Machine）：抽象计算模型，可以认为是一些状态的计算规则。Raft通过日志等输入状态机，来确定状态管理节点状态等。</li>\\n<li>节点状态：Follower（跟随者）、Candidate（候选者 - 无Leader时候Foller会转化为这个）、Leader（领导者）</li>\\n<li>选举触发：Follower 在一个称为选举超时时间（election timeout）内没有收到来自 Leader 的心跳时触发。</li>\\n<li>选举Leader的条件：Candidate 从大多数节点（超过集群节点总数的一半）获得了投票，它就会成为 Leader</li>\\n<li>投票过程：候选者将自己任期号（Term）+1然后向其他所有节点发送请求投票（候选者当前任期号、日志条目、自己的节点ID ）。</li>\\n<li>其他节点：任期号大于自己的任期号自己转变为跟随者、看候选者任期是否自己已经投给其他节点如果投了就拒绝投票、日志新旧程度新的会收到投票。</li>\\n<li>候选者：收到所有其他节点的票，如果票数大于集群数量一半比如5节点收到3票，会把自己升级为Leader并且立刻发送心跳消息（AppendEntries）宣告。</li>\\n</ul>","autoDesc":true}')}}]);