"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6382],{6262:(e,i)=>{i.A=(e,i)=>{const n=e.__vccOpts||e;for(const[e,l]of i)n[e]=l;return n}},9730:(e,i,n)=>{n.r(i),n.d(i,{comp:()=>t,data:()=>r});var l=n(641);const o={},t=(0,n(6262).A)(o,[["render",function(e,i){return(0,l.uX)(),(0,l.CE)("div",null,i[0]||(i[0]=[(0,l.Fv)('<h1 id="goroutine状态" tabindex="-1"><a class="header-anchor" href="#goroutine状态"><span>goroutine状态</span></a></h1><h3 id="一、goroutine状态" tabindex="-1"><a class="header-anchor" href="#一、goroutine状态"><span>一、Goroutine状态</span></a></h3><blockquote><p>Go\\src\\runtime\\runtime2.go</p></blockquote><ol><li>_Gidle = 0 刚刚被分配并且还没有被初始化</li><li>_Grunnable = 1 准备好被调度器分配到一个处理器核心上执行，但还未被选中执行</li><li>_Grunning = 2 正在一个处理器核心上执行时，被赋予了内核线程 M 和处理器 P</li><li>_Gsyscall = 3 当goroutine正在执行一个系统调用时，它处于系统调用状态，goroutine 会被阻塞，例如，进行文件 I/O、网络 I/O</li><li>_Gwaiting = 4 当goroutine正在等待某个条件满足时处于等待状态,比如等待一个通道（channel）或者time.Sleep.</li><li>_Gdead = 6 当goroutine已死亡，不再执行任何代码，也不会被调度器再次调度执行，占用的资源（如栈空间等）可以被回收.</li></ol><blockquote><p>有几个状态是不用去理会的</p></blockquote><ul><li>_Genqueue_unused（目前未使用）</li><li>_Gcopystack=8 （不在运行队列上）</li><li>_Gpreempted=9 （没有执行用户代码）</li><li>_Gscan=10 GC （没有执行代码，可以与其他状态同时存在 ）</li></ul><h3 id="二、m状态" tabindex="-1"><a class="header-anchor" href="#二、m状态"><span>二、M状态</span></a></h3><ol><li>执行用户代码（Executing user code）正在执行一个 goroutine 的用户代码</li><li>执行系统调用（Executing system call）进行文件 I/O、网络 I/O 等操作时.</li><li>闲置状态（Idle）</li><li>自旋状态（Spinning） 当没有可运行的 goroutine 但是预计很快就有新的 goroutine，减少上下文切换的开销，不进入闲置而是直接自旋.</li></ol><h3 id="三、p状态" tabindex="-1"><a class="header-anchor" href="#三、p状态"><span>三、P状态</span></a></h3><ol><li>Pidle：当前p尚未与任何m关联，处于空闲状态</li><li>Prunning：当前p已经和m关联，并且正在运行g代码</li><li>Psyscall：当前p正在执行系统调用</li><li>Pgcstop：当前p需要停止调度，一般在GC前或者刚被创建时</li><li>Pdead：当前p已死亡，不会再被调度</li></ol><h3 id="q-a" tabindex="-1"><a class="header-anchor" href="#q-a"><span>Q&amp;A</span></a></h3><ol><li>goroutine在time.Sleep后状态流转是什么样子的</li></ol><p>goroutine当执行 time.Sleep 时，goroutine 进入等待中状态（Waiting），指定的睡眠时间过去后，goroutine 再次变为可运行状态（Runnable），等待被调度器分配到一个处理器核心上执行。</p><ol start="2"><li>goroutine的唤醒是如何实现的</li></ol><ul><li>channel</li><li>time.After\\time.Ticker</li><li>sync.Cond</li></ul><h3 id="相关文章" tabindex="-1"><a class="header-anchor" href="#相关文章"><span>相关文章</span></a></h3><p><a href="https://zhuanlan.zhihu.com/p/618222173" target="_blank" rel="noopener noreferrer">Go调度系列--GMP状态流转</a></p>',17)]))}]]),r=JSON.parse('{"path":"/posts/go/goroutine%E7%8A%B6%E6%80%81.html","title":"goroutine状态","lang":"zh-CN","frontmatter":{"description":"goroutine状态 一、Goroutine状态 Go\\\\src\\\\runtime\\\\runtime2.go _Gidle = 0 刚刚被分配并且还没有被初始化 _Grunnable = 1 准备好被调度器分配到一个处理器核心上执行，但还未被选中执行 _Grunning = 2 正在一个处理器核心上执行时，被赋予了内核线程 M 和处理器 P _Gsysca...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/goroutine%E7%8A%B6%E6%80%81.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"goroutine状态"}],["meta",{"property":"og:description","content":"goroutine状态 一、Goroutine状态 Go\\\\src\\\\runtime\\\\runtime2.go _Gidle = 0 刚刚被分配并且还没有被初始化 _Grunnable = 1 准备好被调度器分配到一个处理器核心上执行，但还未被选中执行 _Grunning = 2 正在一个处理器核心上执行时，被赋予了内核线程 M 和处理器 P _Gsysca..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"goroutine状态\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"一、Goroutine状态","slug":"一、goroutine状态","link":"#一、goroutine状态","children":[]},{"level":3,"title":"二、M状态","slug":"二、m状态","link":"#二、m状态","children":[]},{"level":3,"title":"三、P状态","slug":"三、p状态","link":"#三、p状态","children":[]},{"level":3,"title":"Q&A","slug":"q-a","link":"#q-a","children":[]},{"level":3,"title":"相关文章","slug":"相关文章","link":"#相关文章","children":[]}],"readingTime":{"minutes":1.88,"words":563},"filePathRelative":"posts/go/goroutine状态.md","excerpt":"\\n<h3>一、Goroutine状态</h3>\\n<blockquote>\\n<p>Go\\\\src\\\\runtime\\\\runtime2.go</p>\\n</blockquote>\\n<ol>\\n<li>_Gidle = 0     刚刚被分配并且还没有被初始化</li>\\n<li>_Grunnable = 1 准备好被调度器分配到一个处理器核心上执行，但还未被选中执行</li>\\n<li>_Grunning = 2  正在一个处理器核心上执行时，被赋予了内核线程 M 和处理器 P</li>\\n<li>_Gsyscall = 3  当goroutine正在执行一个系统调用时，它处于系统调用状态，goroutine 会被阻塞，例如，进行文件 I/O、网络 I/O</li>\\n<li>_Gwaiting = 4  当goroutine正在等待某个条件满足时处于等待状态,比如等待一个通道（channel）或者time.Sleep.</li>\\n<li>_Gdead = 6     当goroutine已死亡，不再执行任何代码，也不会被调度器再次调度执行，占用的资源（如栈空间等）可以被回收.</li>\\n</ol>","autoDesc":true}')}}]);