"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[974],{6262:(n,e)=>{e.A=(n,e)=>{const s=n.__vccOpts||n;for(const[n,a]of e)s[n]=a;return s}},6389:(n,e,s)=>{s.r(e),s.d(e,{comp:()=>t,data:()=>l});var a=s(641);const i={},t=(0,s(6262).A)(i,[["render",function(n,e){return(0,a.uX)(),(0,a.CE)("div",null,e[0]||(e[0]=[(0,a.Fv)('<h1 id="context" tabindex="-1"><a class="header-anchor" href="#context"><span>context</span></a></h1><h3 id="一、常用api" tabindex="-1"><a class="header-anchor" href="#一、常用api"><span>一、常用API</span></a></h3><p>WithValue 查找顺序 多层级 context 值覆盖</p><blockquote><p>主要弄清楚 WithValue\\WithTimeout\\WithDeadline\\WithCancel 如何实现 子上下文和父上下文如何相互通讯的</p></blockquote><ol><li>跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗</li></ol><blockquote><p>不会</p></blockquote><ol start="2"><li>background和todo有什么区别</li></ol><blockquote><p>两个都是 emptyCtx int 都实现了接口 context.Context</p></blockquote><ol start="3"><li>context源码角度是一个什么样的结构</li></ol><blockquote><p>context.Context是一个interface 也就是一个待实现的接口</p></blockquote><ol start="4"><li><p>WithCancel() 和 WithTimeout() 可以通知多个goroutine, 如何实现的</p></li><li><p>ctx的key为name的value被子协程更改后，在主协程会变更吗</p></li></ol><blockquote><p>不会变</p></blockquote><ol start="6"><li>WithTimeout和WithCancel等本质上做了什么事情</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>context包有结构体 cancelCtx timerCtx valueCtx </span></span>\n<span class="line"><span>本质上每一次WithTimeout都是重新创建一个结构体，并且把当前的接口体赋到新结构体的属性变量之中</span></span>\n<span class="line"><span>所以结构体中存储parentContext</span></span>\n<span class="line"><span>以context.WithCancel为例</span></span>\n<span class="line"><span>如何在 parent.Done 的时候子 children.Done 呢</span></span>\n<span class="line"><span>本质上是起一个协程并且阻塞在 case &lt;-parent.Done() </span></span>\n<span class="line"><span>然后在阻塞通过后执行 children.Done</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>当执行 WithCancel 的时候，其实就是重新创建一个 cancelCtx 并且调用 propagateCancel 方法</span></span>\n<span class="line"><span>监听父级别上下文的信号，保证父级上下文关闭后，子上下文也发出cancel信号</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>c.Value 的访问</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>每次 WithValue 都会封装一次 valueCtx，然后把值和key存储到新的 valueCtx 之中</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>c.Value 的访问，是对当前的上下文的value访问，如果找不到那么查找父级上下文，找不到继续如何迭代查找</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li>WithTimeout如何实现的</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>源码是通过注册 time.AfterFunc 调用 ctx.cancel 函数执行的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="9"><li><p>为什么说context是线程安全的，如何实现的</p></li><li><p>context读取value会有什么问题（时间复杂度讲一下）嵌套很多层会逐个访问O(N)</p></li></ol><blockquote><p>contextl.Value的并发安全通过sync.Mutex实现</p></blockquote><p><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></p><h3 id="context-withtimeout的使用" tabindex="-1"><a class="header-anchor" href="#context-withtimeout的使用"><span>Context.WithTimeout的使用</span></a></h3><blockquote><p>解释一下WithTimeout的cancel是否要直接defer</p></blockquote><div class="language-golang line-numbers-mode" data-highlighter="shiki" data-ext="golang" data-title="golang" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>package main</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>import (</span></span>\n<span class="line"><span>\t&quot;context&quot;</span></span>\n<span class="line"><span>\t&quot;fmt&quot;</span></span>\n<span class="line"><span>\t&quot;time&quot;</span></span>\n<span class="line"><span>)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func ccc() context.Context {</span></span>\n<span class="line"><span>\tctx, cancel := context.WithTimeout(context.Background(), 4*time.Second)</span></span>\n<span class="line"><span>    // defer会在ccc执行完成以后立即调用</span></span>\n<span class="line"><span>    // 从而导致直接触发&lt;-ctx.Done</span></span>\n<span class="line"><span>    // 无法等到timeOut后触发</span></span>\n<span class="line"><span>\tdefer cancel()</span></span>\n<span class="line"><span>\treturn ctx</span></span>\n<span class="line"><span>}</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>func main() {</span></span>\n<span class="line"><span>\tctx := ccc()</span></span>\n<span class="line"><span>\tselect {</span></span>\n<span class="line"><span>\tcase &lt;-ctx.Done():</span></span>\n<span class="line"><span>\t\tfmt.Println(&quot;Context done.&quot;)</span></span>\n<span class="line"><span>\tcase &lt;-time.After(3 * time.Second):</span></span>\n<span class="line"><span>\t\tfmt.Println(&quot;Timeout after 3 seconds.&quot;)</span></span>\n<span class="line"><span>\t}</span></span>\n<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>',24)]))}]]),l=JSON.parse('{"path":"/posts/go/context.html","title":"context","lang":"zh-CN","frontmatter":{"description":"context 一、常用API WithValue 查找顺序 多层级 context 值覆盖 主要弄清楚 WithValue\\\\WithTimeout\\\\WithDeadline\\\\WithCancel 如何实现 子上下文和父上下文如何相互通讯的 跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗 不会 background和todo有...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/context.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"context"}],["meta",{"property":"og:description","content":"context 一、常用API WithValue 查找顺序 多层级 context 值覆盖 主要弄清楚 WithValue\\\\WithTimeout\\\\WithDeadline\\\\WithCancel 如何实现 子上下文和父上下文如何相互通讯的 跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗 不会 background和todo有..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"context\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"一、常用API","slug":"一、常用api","link":"#一、常用api","children":[]},{"level":3,"title":"Context.WithTimeout的使用","slug":"context-withtimeout的使用","link":"#context-withtimeout的使用","children":[]}],"readingTime":{"minutes":1.99,"words":597},"filePathRelative":"posts/go/context.md","excerpt":"\\n<h3>一、常用API</h3>\\n<p>WithValue\\n查找顺序\\n多层级 context 值覆盖</p>\\n<blockquote>\\n<p>主要弄清楚 WithValue\\\\WithTimeout\\\\WithDeadline\\\\WithCancel 如何实现\\n子上下文和父上下文如何相互通讯的</p>\\n</blockquote>\\n<ol>\\n<li>跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗</li>\\n</ol>\\n<blockquote>\\n<p>不会</p>\\n</blockquote>\\n<ol start=\\"2\\">\\n<li>background和todo有什么区别</li>\\n</ol>","autoDesc":true}')}}]);