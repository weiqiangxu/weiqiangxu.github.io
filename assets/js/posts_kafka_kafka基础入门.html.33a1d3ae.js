"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8166],{6262:(a,e)=>{e.A=(a,e)=>{const s=a.__vccOpts||a;for(const[a,i]of e)s[a]=i;return s}},4253:(a,e,s)=>{s.r(e),s.d(e,{comp:()=>l,data:()=>r});var i=s(641);const n={},l=(0,s(6262).A)(n,[["render",function(a,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h3 id="博客园-详细基础入门" tabindex="-1"><a class="header-anchor" href="#博客园-详细基础入门"><span>博客园-详细基础入门</span></a></h3><blockquote><p>高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>注意是一个分布式文件系统</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="数据单位" tabindex="-1"><a class="header-anchor" href="#数据单位"><span>数据单位</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>数据以 topics 主题类别存储</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>每条记录有键、值、时间戳</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="核心api" tabindex="-1"><a class="header-anchor" href="#核心api"><span>核心API</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Producer API（生产者API）</span></span>\n<span class="line"><span>Consumer API（消费者API）</span></span>\n<span class="line"><span>Streams API（流API）</span></span>\n<span class="line"><span>Connector API（连接器API）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="主题-topic" tabindex="-1"><a class="header-anchor" href="#主题-topic"><span>主题 topic</span></a></h3><blockquote><p>逻辑分类，一类消息</p></blockquote><h3 id="分区-patitions" tabindex="-1"><a class="header-anchor" href="#分区-patitions"><span>分区 patitions</span></a></h3><blockquote><p>一个分区在存储层面可以是一个 append log 文件</p></blockquote><blockquote><p>一个 topic 可以分成多个分区 partition</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>有序、不可变的记录序列</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>分区中每个记录，有一个称谓偏移的顺序ID号码，唯一表示每个分区的记录</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kafka允许设置记录保留期-无论是否使用-但是kafka的性能在数据大小方面实际上是恒定的-因此长时间存储数据不是问题" tabindex="-1"><a class="header-anchor" href="#kafka允许设置记录保留期-无论是否使用-但是kafka的性能在数据大小方面实际上是恒定的-因此长时间存储数据不是问题"><span>kafka允许设置记录保留期（无论是否使用），但是Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据不是问题</span></a></h3><h3 id="consumer-group-消费组" tabindex="-1"><a class="header-anchor" href="#consumer-group-消费组"><span>consumer group 消费组</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>每个consumer属于一个consumer group，一个group里面可以有多个consumer，但是一个topic里面在group之中只会被消费一次，也就是同一个group的多个consumer不可能消费到同一个topic的同一个消息</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="分区" tabindex="-1"><a class="header-anchor" href="#分区"><span>分区</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>可以认为一个 append log 文件或者 一块磁盘</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="组" tabindex="-1"><a class="header-anchor" href="#组"><span>组</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>可以认为是一个用于访问 append log 的密钥 (这个密钥只能给一消费者用)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="消费者" tabindex="-1"><a class="header-anchor" href="#消费者"><span>消费者</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>可以认为是真正拿到 append log 文件内容的程序</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="topic" tabindex="-1"><a class="header-anchor" href="#topic"><span>topic</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>可以认为是 append log 里面每一行内容的类别，比如有些是QQ日志、有些是微信日志</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="一个分区只能被同一个组的一个消费者消费" tabindex="-1"><a class="header-anchor" href="#一个分区只能被同一个组的一个消费者消费"><span>一个分区只能被同一个组的一个消费者消费</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>可以简单地认为 一个 append log 文件，有多个组（密钥），在一个组内（1个密钥）只能给一个消费者使用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="一个消费者可以消费同一个topic的多个分区" tabindex="-1"><a class="header-anchor" href="#一个消费者可以消费同一个topic的多个分区"><span>一个消费者可以消费同一个topic的多个分区</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>最终读取 append log 文件的程序，可以读取多个 append log 文件 (topic是微信日志，这个日志存在很多个地方)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h5 id="关键点-持有一个group-id消费1个分区的消息-只能被1个消费者消费-如果有2个消费者持有同一个-group-id-消费同一个分区的数据-那么其中只有-1个-可以消费到" tabindex="-1"><a class="header-anchor" href="#关键点-持有一个group-id消费1个分区的消息-只能被1个消费者消费-如果有2个消费者持有同一个-group-id-消费同一个分区的数据-那么其中只有-1个-可以消费到"><span>关键点：持有一个group id消费1个分区的消息，只能被1个消费者消费，如果有2个消费者持有同一个 group id 消费同一个分区的数据，那么其中只有 1个 可以消费到</span></a></h5><h5 id="关键点-持有一个group-id消费1个分区的消息-只能被1个消费者消费-如果有2个消费者持有同一个-group-id-消费同一个分区的数据-那么其中只有-1个-可以消费到-1" tabindex="-1"><a class="header-anchor" href="#关键点-持有一个group-id消费1个分区的消息-只能被1个消费者消费-如果有2个消费者持有同一个-group-id-消费同一个分区的数据-那么其中只有-1个-可以消费到-1"><span>关键点：持有一个group id消费1个分区的消息，只能被1个消费者消费，如果有2个消费者持有同一个 group id 消费同一个分区的数据，那么其中只有 1个 可以消费到</span></a></h5><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>底层是如何实现的呢</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>consumer订阅topic以后，底层的逻辑是怎么样的呢</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>消费者数量大于分区数时候，多余的消费者会处于闲置的状态</p></blockquote><h3 id="术语" tabindex="-1"><a class="header-anchor" href="#术语"><span>术语</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Record 消息</span></span>\n<span class="line"><span>Topic 主题</span></span>\n<span class="line"><span>Producer  生产者</span></span>\n<span class="line"><span>Consumer  消费者</span></span>\n<span class="line"><span>Broker  kafka服务器</span></span>\n<span class="line"><span>Partition 分区，一个主题可以分布在多个分区，可以理解为append log文件，通过分区，消息读写可以落到多个节点</span></span>\n<span class="line"><span>Leader/Follower  分区副本，leader负责读写，follower只负责和leader保持同步不对外提供服务</span></span>\n<span class="line"><span>Offset 偏移量，分区之中每个消息根据时间出现的递增序号，这个序号就是偏移量</span></span>\n<span class="line"><span>Consumer group  消费者组，一个或者多个消费者可以共用一个组ID，但是一个分区只能被1个组的1个消费者消费</span></span>\n<span class="line"><span>Coodinator 协调者，负责rebalance</span></span>\n<span class="line"><span>Controller 控制器，本质上是1个broker，负责协调和管理集群（leader选取、rebalance等），（zoookiper第一个创建的临时节点会成为控制器）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kafka存储层-数据存储在日志里面" tabindex="-1"><a class="header-anchor" href="#kafka存储层-数据存储在日志里面"><span>kafka存储层，数据存储在日志里面</span></a></h3><h3 id="参考博客" tabindex="-1"><a class="header-anchor" href="#参考博客"><span>参考博客</span></a></h3><p><a href="https://www.cnblogs.com/along21/p/10278100.html" target="_blank" rel="noopener noreferrer">超详细“零”基础kafka入门篇</a></p><h3 id="kafka通信过程原理-生产者" tabindex="-1"><a class="header-anchor" href="#kafka通信过程原理-生产者"><span>kafka通信过程原理 - 生产者</span></a></h3><ol><li>kafka broker启动，向 zookeeper 注册自己ID，并且向zookeeper订阅所有的broker</li><li>生产者启动，指定bootstrap.servers，指定的broker地址，建立TCP连接</li><li>生产者发送消息给broker获取所有的broker信息</li><li>生产和所有的broker建立TCP连接</li><li>开始生产啦</li></ol><h3 id="kafka通信过程原理-消费者" tabindex="-1"><a class="header-anchor" href="#kafka通信过程原理-消费者"><span>kafka通信过程原理 - 消费者</span></a></h3><ol><li>消费者和一个broker连接</li><li>协调者获取所有分区信息</li><li>协调者让消费者和所有分区leader建立连接</li><li>开始消费啦</li></ol><blockquote><p>以上归根到底最终producer和每一个broker建立连接，consumer和每一个partition(leader)建立连接</p></blockquote><h3 id="发送消息时候如何选择分区" tabindex="-1"><a class="header-anchor" href="#发送消息时候如何选择分区"><span>发送消息时候如何选择分区</span></a></h3><ol><li>轮询</li><li>随机</li></ol><h3 id="分区有什么好处" tabindex="-1"><a class="header-anchor" href="#分区有什么好处"><span>分区有什么好处</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>没有分区的话，消息就会都写到一个节点上了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="关于rebalance" tabindex="-1"><a class="header-anchor" href="#关于rebalance"><span>关于rebalance</span></a></h3><ol><li>消费者数量和分区数量保持一致最好</li><li>当消费者数量小于分区数量的时候，那么必然会有一个消费者消费多个分区的消息</li><li>消费者数量超过分区的数量的时候，那么必然会有消费者没有分区可以消费</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>旧版本的通过zookeeper监听器</span></span>\n<span class="line"><span>新版本通过协调者</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>重平衡过程整个消费群组停止工作，期间无法消费消息</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>消费、主题、分区任何一个发生改变都会重平衡</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="rebalance重平衡过程" tabindex="-1"><a class="header-anchor" href="#rebalance重平衡过程"><span>rebalance重平衡过程</span></a></h3><blockquote><p>heartbeat.interval.ms 控制消费者和协调者心跳间隔</p></blockquote><p><a href="https://mp.weixin.qq.com/s/SuALTpvI3IMPSja9pacJ7Q" target="_blank" rel="noopener noreferrer">图示</a></p><ol><li>第一个消费者 join group 请求给协调者，第一个成为群主</li><li>群主执行分配策略，告知协调者</li><li>新消费者 join group 请求给协调者，协调者找群主要新的分配结果，协调者返回给每一个消费者</li></ol><h3 id="分区分配策略" tabindex="-1"><a class="header-anchor" href="#分区分配策略"><span>分区分配策略</span></a></h3><p><a href="https://blog.csdn.net/lzb348110175/article/details/100773487" target="_blank" rel="noopener noreferrer">.Kafka 分区分配策略（Range分配策略 &amp;&amp; RoundRobin分配策略）</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>背景： 1个topic，分布在3个分区，2个消费者，持有1个 group id </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>那么理想中，每个消费者都能拿到自己占用的分区</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>消费者客户端参数 partition.assignment.strategy 设置消费者与订阅主题topic之间消费策略</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol><li>Range 范围分区</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>假设topic1 的分区 1~8，消费者有3个 abc , 那么每个分区逐个分配给消费者</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1-a</span></span>\n<span class="line"><span>2-b</span></span>\n<span class="line"><span>3-c</span></span>\n<span class="line"><span>4-a</span></span>\n<span class="line"><span>...</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>弊端：a这个消费者会承担更多的分区的消费，从而导致不均衡</span></span>\n<span class="line"><span>    假设 topic2、topic3、topic4全部只有1个分区</span></span>\n<span class="line"><span>    那么这个分区无疑全部落到了a消费者的头上</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>RoundRobin 轮询</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>所有 partition 和 consumer 都列出来</span></span>\n<span class="line"><span>然后按照 hascode 排序</span></span>\n<span class="line"><span>最后通过轮询算法来分配 partition 给到各个消费者</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>场景：假设topic1有3个分区1~3，topic2有5个分区1~5，topic3有8个分区1~8，消费者有ABC，那么将生成 topic1_1\\topic1_2\\... 逐个分配给ABC消费者</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>弊端：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>a. 上面的消费者ABC (当然group是同一个) 订阅了相同的 topic，此时是均匀的( 每个消费者拿到的分区数是大致相等 )</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>b. 上面的消费者B只是订阅了topic1，那么就是不均匀的，（B消费了1个分区，另外的 topic1和topic3都会被AC消费，但是其实因为 AC 还消费了太多的其他的topic，如果要分区均匀给消费者，应该让那个B消费topic1的所有分区）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kafka-如何保证消息的可靠性" tabindex="-1"><a class="header-anchor" href="#kafka-如何保证消息的可靠性"><span>kafka 如何保证消息的可靠性</span></a></h3><ol><li>生产者发送消息丢失（消息发出去了，但是网络原因或者其他导致kafka没收到）</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>发送后不管结果、同步发送、异步发送</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>异步加异常重试是比较稳妥的做法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>acks= 0\\1\\all</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>0 就是发了就不管了</span></span>\n<span class="line"><span>1 要求起码1个leader是返回ok了（leader返回ok，follower没ok，leader挂了，一样炸了）</span></span>\n<span class="line"><span>all 要求leader\\follower所有副本都ok才表示ok</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>Kafka 自身消息丢失</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kafka通过pageCache异步写入磁盘，有可能到了pageCache后没写入磁盘就炸了</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>措施：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>replication.factor 加副本数量</span></span>\n<span class="line"><span>min.insync.replicas 表示写入多个个副本才能认为成功</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>消费者消息丢失</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>消费者获取了数据之后，炸了，没对消费做任何操作，就aotu commit了，offset就被改变了</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>enable.auto.commit=false，设置为手动提交</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>手动提交也分异步和同步，这个异步和同步指的是：pull拉取和push推送的动作是异步还是同步，如果是同步的话必须是push offset之后这个消费者才能消费下一个offset</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>消费者A读取到了offset=3的数据 (自动提交默认是每5秒一次,5s之后consumer会自动提交offset)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>默认5秒钟，一个 Consumer 将会提交它的 Offset 给 Kafka</span></span>\n<span class="line"><span>或者每一次数据从指定的 Topic 取回时，将会提交最后一次的 Offset</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>很明显，这个弊端就在于，如果consumer接收到消息以后，time.Sleep 了6秒才去处理消息，此刻已经commit了你的offset了</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>这个时候恰巧处理消息的程序崩溃了，那么这条消息就丢失了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://www.cnblogs.com/auuv/articles/15984585.html" target="_blank" rel="noopener noreferrer">自动提交和手动提交-漏消费和重复消费</a><a href="https://www.cnblogs.com/jelly12345/p/16018287.html" target="_blank" rel="noopener noreferrer">Kafka自动提交 offset 尚硅谷</a><a href="https://blog.csdn.net/chaiyu2002/article/details/89472416" target="_blank" rel="noopener noreferrer">kafka auto commit官方手册</a></p><h3 id="副本同步原理" tabindex="-1"><a class="header-anchor" href="#副本同步原理"><span>副本同步原理</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Kafka副本分为Leader副本和Follower副本（主从）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>只有Leader副本会对外提供服务，Follower副本只是单纯地和Leader保持数据同步，作为数据冗余容灾的作用</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>AR（Assigned Replicas）</span></span>\n<span class="line"><span>ISR（InSyncReplicas）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>replica.lag.time.max.ms 代表foller副本落后leader副本的最长时间，默认值10秒</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>HW（High Watermark）：高水位，也叫做复制点，表示副本间同步的位置</span></span>\n<span class="line"><span>LEO（Log End Offset）：下一条待写入消息的位移</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kafka为什么快" tabindex="-1"><a class="header-anchor" href="#kafka为什么快"><span>Kafka为什么快</span></a></h3><ol><li><p>顺序 IO</p></li><li><p>Page Cache 和零拷贝</p></li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>操作系统的文件缓存PageCache异步写入，提高了写入消息的性能；</span></span>\n<span class="line"><span>消费消息的时候又通过sendfile实现了零拷贝；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>批量处理和压缩</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>发送时多条消息合并成一个批次进行处理发送</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>消费消息一次拉取一批次的消息进行消费</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="副本" tabindex="-1"><a class="header-anchor" href="#副本"><span>副本</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>AR(Assigned Replicas)(所有副本) = </span></span>\n<span class="line"><span>ISR(已经同步的)(In Sync Replicas) + OSR(同步滞后)(Out-of-Sync Replied)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://baijiahao.baidu.com/s?id=1719501564805569513" target="_blank" rel="noopener noreferrer">一文读懂kafka</a></p><h3 id="broker-恢复机制" tabindex="-1"><a class="header-anchor" href="#broker-恢复机制"><span>broker 恢复机制</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LEO：（Log End Offset）每个副本的最后一个offset</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>HW：（High Watermark）高水位，指的是消费者能见到的最大的 offset</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="先消费后提交offset会有可能出现重复消费的异常-解决异常时保证消费消息的逻辑的幂等性" tabindex="-1"><a class="header-anchor" href="#先消费后提交offset会有可能出现重复消费的异常-解决异常时保证消费消息的逻辑的幂等性"><span>先消费后提交offset会有可能出现重复消费的异常，解决异常时保证消费消息的逻辑的幂等性</span></a></h3><h3 id="先提交后消费会出现消息丢失的可能-因为offset已经更新了consumer却崩溃了" tabindex="-1"><a class="header-anchor" href="#先提交后消费会出现消息丢失的可能-因为offset已经更新了consumer却崩溃了"><span>先提交后消费会出现消息丢失的可能，因为offset已经更新了consumer却崩溃了</span></a></h3><h3 id="消息堆积出现的原因是消费者跟不上生产者的速度-解决方案时增加partition增加消费者" tabindex="-1"><a class="header-anchor" href="#消息堆积出现的原因是消费者跟不上生产者的速度-解决方案时增加partition增加消费者"><span>消息堆积出现的原因是消费者跟不上生产者的速度，解决方案时增加partition增加消费者</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>还有1种消息堆积的是因为，手动提交的情况下，consumer.pull到了message但是一直不消费也不提交直接跳过去了</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="kafka如何在高可用的架构下-多副本-保证数据的一致性的" tabindex="-1"><a class="header-anchor" href="#kafka如何在高可用的架构下-多副本-保证数据的一致性的"><span>kafka如何在高可用的架构下（多副本）保证数据的一致性的</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>高可用是通过数据冗余的方式实现 （在leader挂了的时候follower推举为新的leader）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>数据冗余需要保证数据一致性，就要从副本同步机制讲起</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kafka副本同步机制" tabindex="-1"><a class="header-anchor" href="#kafka副本同步机制"><span>kafka副本同步机制</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LEO和HW</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="分区策略-message究竟要存到topic下面的哪个分区的策略" tabindex="-1"><a class="header-anchor" href="#分区策略-message究竟要存到topic下面的哪个分区的策略"><span>分区策略 - message究竟要存到topic下面的哪个分区的策略</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 手动指定partition</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>2. 随机轮询</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>3. 按key存储 (key的hash和分区数取余数)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>4. 顺序轮询（round-robin）（第一次调用随机生成整数，后续每次调用自增，用这个数于分区数取余数）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="关于我现在自己的项目的一个思考" tabindex="-1"><a class="header-anchor" href="#关于我现在自己的项目的一个思考"><span>关于我现在自己的项目的一个思考</span></a></h2><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 生产者是一个异步的，并且异步回调会写入chan之中，让我们再处理，目前这个回调被我们忽略了有可能带来一个消息丢失</span></span>\n<span class="line"><span>（生产消息可靠性有点低）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>2.消费者这里手动commit是一个同步提交操作，对吞吐影响较大</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>3. 我们目前比较多的是一个消费后手动提交offset的，rebalance之后会不会出现重复消费。比如我在获取了一个消息之后，消费者处理超时了，导致kafka认为我们的消费者已经离线了，rebalance并且把分区给了其他的消费者。这个取决于处理时长，如果5min之内我们都没有处理完就会出现这种情况，目前一次最多poll了500条数据，你认为我们500条数据要处理多久。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="kafka的消费者只有1个-但是分区有5个-那么当这个消费者持有消费者组a消费了这个topic-这5个分区的消费位点都会往前挪动吗" tabindex="-1"><a class="header-anchor" href="#kafka的消费者只有1个-但是分区有5个-那么当这个消费者持有消费者组a消费了这个topic-这5个分区的消费位点都会往前挪动吗"><span>kafka的消费者只有1个，但是分区有5个，那么当这个消费者持有消费者组A消费了这个topic，这5个分区的消费位点都会往前挪动吗</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>首先，分区不是副本，多个分区他们的内容不是一样的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="没有阿里云-怎么命令行界面上或者图形上看当前的topic的订阅者有哪些组-每个消费者组的消费位点是什么-堆积量多少" tabindex="-1"><a class="header-anchor" href="#没有阿里云-怎么命令行界面上或者图形上看当前的topic的订阅者有哪些组-每个消费者组的消费位点是什么-堆积量多少"><span>没有阿里云，怎么命令行界面上或者图形上看当前的topic的订阅者有哪些组，每个消费者组的消费位点是什么，堆积量多少</span></a></h3><h3 id="有没有做堆积量告警-怎么做的" tabindex="-1"><a class="header-anchor" href="#有没有做堆积量告警-怎么做的"><span>有没有做堆积量告警，怎么做的</span></a></h3><h3 id="消息查询按时间点、按位点、按分区如何使用查询" tabindex="-1"><a class="header-anchor" href="#消息查询按时间点、按位点、按分区如何使用查询"><span>消息查询按时间点、按位点、按分区如何使用查询</span></a></h3><h3 id="如何查看某一个消费者组订阅的topic有哪些" tabindex="-1"><a class="header-anchor" href="#如何查看某一个消费者组订阅的topic有哪些"><span>如何查看某一个消费者组订阅的topic有哪些</span></a></h3><h3 id="分区数量的数量设置依据什么合适" tabindex="-1"><a class="header-anchor" href="#分区数量的数量设置依据什么合适"><span>分区数量的数量设置依据什么合适</span></a></h3><h3 id="分区的写入策略" tabindex="-1"><a class="header-anchor" href="#分区的写入策略"><span>分区的写入策略</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>轮询</span></span>\n<span class="line"><span>随机</span></span>\n<span class="line"><span>按键保存</span></span>\n<span class="line"><span>自定义</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://zhuanlan.zhihu.com/p/392921569" target="_blank" rel="noopener noreferrer">Kafka增加分区导致业务数据异常</a></p><h3 id="kafka同一个消费者会消费了同一个topic多个分区的同一个消费偏移吗" tabindex="-1"><a class="header-anchor" href="#kafka同一个消费者会消费了同一个topic多个分区的同一个消费偏移吗"><span>kafka同一个消费者会消费了同一个topic多个分区的同一个消费偏移吗</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>首先，分区不是副本，多个分区他们的内容不是一样的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="增加分区后会有什么情况发生" tabindex="-1"><a class="header-anchor" href="#增加分区后会有什么情况发生"><span>增加分区后会有什么情况发生</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>比如将分区12 扩展为1234会有什么事情</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="一个topic-1有4个分区-只有group-a订阅topic-1-对应的-group-a-的消费者consumer只有一个a-那么这个a可以订阅所有的分区吗" tabindex="-1"><a class="header-anchor" href="#一个topic-1有4个分区-只有group-a订阅topic-1-对应的-group-a-的消费者consumer只有一个a-那么这个a可以订阅所有的分区吗"><span>一个topic_1有4个分区，只有group_a订阅topic_1，对应的 group_a 的消费者consumer只有一个A，那么这个A可以订阅所有的分区吗</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>当然是可以啊，一个消费者持有一个group_id一定是可以订阅到所有分区的</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>不能订阅到的情况只能是，多个消费者持有同一个 group_id</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="http://wjhsh.net/timor19-p-12742362.html" target="_blank" rel="noopener noreferrer">Kafka查看topic、consumer group状态命令</a></p><p><a href="https://blog.csdn.net/javahelpyou/article/details/125887294" target="_blank" rel="noopener noreferrer">kafka对topic的CRUD</a></p><h3 id="ack" tabindex="-1"><a class="header-anchor" href="#ack"><span>ACK</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>消费者位置(consumer position) </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>每个consumer group保存自己的位移信息, checkpoint机制定期持久化</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>老版本的位移是提交到zookeeper中的，目录结构是：/consumers/&lt;group.id&gt;/offsets/&lt;topic&gt;/&lt;partitionId&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://blog.csdn.net/weixin_43956062/article/details/106784984" target="_blank" rel="noopener noreferrer">Kafka 源码解析之 Consumer 如何加入一个 Group</a></p><h3 id="我的-client-a-目前占有1个topic的2个分区-p1-p2-pull了500条数据-offset-10-510-正在消费-消费到50-的时候260-重新加入了一个-client-b订阅该topic-那么这个时候会把client-a正在消费的另一个分区给p2-rebalance给-client-b-吗-如果会的话-会把-10-510的数据给-client-b-消费吗" tabindex="-1"><a class="header-anchor" href="#我的-client-a-目前占有1个topic的2个分区-p1-p2-pull了500条数据-offset-10-510-正在消费-消费到50-的时候260-重新加入了一个-client-b订阅该topic-那么这个时候会把client-a正在消费的另一个分区给p2-rebalance给-client-b-吗-如果会的话-会把-10-510的数据给-client-b-消费吗"><span>我的 client_A 目前占有1个topic的2个分区(p1,p2)，pull了500条数据(offset = 10~510)正在消费，消费到50%的时候260，重新加入了一个 client_B订阅该topic，那么这个时候会把client_A正在消费的另一个分区给p2 rebalance给 client_B 吗，如果会的话，会把 10~510的数据给 client_B 消费吗</span></a></h3><h3 id="rebalance的触发情形有哪些-rebalance的底层原理是什么" tabindex="-1"><a class="header-anchor" href="#rebalance的触发情形有哪些-rebalance的底层原理是什么"><span>rebalance的触发情形有哪些，rebalance的底层原理是什么</span></a></h3>',117)]))}]]),r=JSON.parse('{"path":"/posts/kafka/kafka%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html","title":"kafka基础入门","lang":"zh-CN","frontmatter":{"title":"kafka基础入门","tags":["kafka原理"],"categories":["kafka"],"date":"2023-04-08T06:40:12.000Z","index_img":"/images/bg/computer.jpeg","hide":true,"description":"博客园-详细基础入门 高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统 数据单位 核心API 主题 topic 逻辑分类，一类消息 分区 patitions 一个分区在存储层面可以是一个 append log 文件 一个 topic 可以分成多个分区 partition kafka允许设置记录保留期（无论是否使用），但是Kafka的性能在数据...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/kafka/kafka%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"kafka基础入门"}],["meta",{"property":"og:description","content":"博客园-详细基础入门 高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统 数据单位 核心API 主题 topic 逻辑分类，一类消息 分区 patitions 一个分区在存储层面可以是一个 append log 文件 一个 topic 可以分成多个分区 partition kafka允许设置记录保留期（无论是否使用），但是Kafka的性能在数据..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"kafka原理"}],["meta",{"property":"article:published_time","content":"2023-04-08T06:40:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"kafka基础入门\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-08T06:40:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"博客园-详细基础入门","slug":"博客园-详细基础入门","link":"#博客园-详细基础入门","children":[]},{"level":3,"title":"数据单位","slug":"数据单位","link":"#数据单位","children":[]},{"level":3,"title":"核心API","slug":"核心api","link":"#核心api","children":[]},{"level":3,"title":"主题 topic","slug":"主题-topic","link":"#主题-topic","children":[]},{"level":3,"title":"分区 patitions","slug":"分区-patitions","link":"#分区-patitions","children":[]},{"level":3,"title":"kafka允许设置记录保留期（无论是否使用），但是Kafka的性能在数据大小方面实际上是恒定的，因此长时间存储数据不是问题","slug":"kafka允许设置记录保留期-无论是否使用-但是kafka的性能在数据大小方面实际上是恒定的-因此长时间存储数据不是问题","link":"#kafka允许设置记录保留期-无论是否使用-但是kafka的性能在数据大小方面实际上是恒定的-因此长时间存储数据不是问题","children":[]},{"level":3,"title":"consumer group 消费组","slug":"consumer-group-消费组","link":"#consumer-group-消费组","children":[]},{"level":3,"title":"分区","slug":"分区","link":"#分区","children":[]},{"level":3,"title":"组","slug":"组","link":"#组","children":[]},{"level":3,"title":"消费者","slug":"消费者","link":"#消费者","children":[]},{"level":3,"title":"topic","slug":"topic","link":"#topic","children":[]},{"level":3,"title":"一个分区只能被同一个组的一个消费者消费","slug":"一个分区只能被同一个组的一个消费者消费","link":"#一个分区只能被同一个组的一个消费者消费","children":[]},{"level":3,"title":"一个消费者可以消费同一个topic的多个分区","slug":"一个消费者可以消费同一个topic的多个分区","link":"#一个消费者可以消费同一个topic的多个分区","children":[]},{"level":3,"title":"术语","slug":"术语","link":"#术语","children":[]},{"level":3,"title":"kafka存储层，数据存储在日志里面","slug":"kafka存储层-数据存储在日志里面","link":"#kafka存储层-数据存储在日志里面","children":[]},{"level":3,"title":"参考博客","slug":"参考博客","link":"#参考博客","children":[]},{"level":3,"title":"kafka通信过程原理 - 生产者","slug":"kafka通信过程原理-生产者","link":"#kafka通信过程原理-生产者","children":[]},{"level":3,"title":"kafka通信过程原理 - 消费者","slug":"kafka通信过程原理-消费者","link":"#kafka通信过程原理-消费者","children":[]},{"level":3,"title":"发送消息时候如何选择分区","slug":"发送消息时候如何选择分区","link":"#发送消息时候如何选择分区","children":[]},{"level":3,"title":"分区有什么好处","slug":"分区有什么好处","link":"#分区有什么好处","children":[]},{"level":3,"title":"关于rebalance","slug":"关于rebalance","link":"#关于rebalance","children":[]},{"level":3,"title":"rebalance重平衡过程","slug":"rebalance重平衡过程","link":"#rebalance重平衡过程","children":[]},{"level":3,"title":"分区分配策略","slug":"分区分配策略","link":"#分区分配策略","children":[]},{"level":3,"title":"kafka 如何保证消息的可靠性","slug":"kafka-如何保证消息的可靠性","link":"#kafka-如何保证消息的可靠性","children":[]},{"level":3,"title":"副本同步原理","slug":"副本同步原理","link":"#副本同步原理","children":[]},{"level":3,"title":"Kafka为什么快","slug":"kafka为什么快","link":"#kafka为什么快","children":[]},{"level":3,"title":"副本","slug":"副本","link":"#副本","children":[]},{"level":3,"title":"broker 恢复机制","slug":"broker-恢复机制","link":"#broker-恢复机制","children":[]},{"level":3,"title":"先消费后提交offset会有可能出现重复消费的异常，解决异常时保证消费消息的逻辑的幂等性","slug":"先消费后提交offset会有可能出现重复消费的异常-解决异常时保证消费消息的逻辑的幂等性","link":"#先消费后提交offset会有可能出现重复消费的异常-解决异常时保证消费消息的逻辑的幂等性","children":[]},{"level":3,"title":"先提交后消费会出现消息丢失的可能，因为offset已经更新了consumer却崩溃了","slug":"先提交后消费会出现消息丢失的可能-因为offset已经更新了consumer却崩溃了","link":"#先提交后消费会出现消息丢失的可能-因为offset已经更新了consumer却崩溃了","children":[]},{"level":3,"title":"消息堆积出现的原因是消费者跟不上生产者的速度，解决方案时增加partition增加消费者","slug":"消息堆积出现的原因是消费者跟不上生产者的速度-解决方案时增加partition增加消费者","link":"#消息堆积出现的原因是消费者跟不上生产者的速度-解决方案时增加partition增加消费者","children":[]},{"level":3,"title":"kafka如何在高可用的架构下（多副本）保证数据的一致性的","slug":"kafka如何在高可用的架构下-多副本-保证数据的一致性的","link":"#kafka如何在高可用的架构下-多副本-保证数据的一致性的","children":[]},{"level":3,"title":"kafka副本同步机制","slug":"kafka副本同步机制","link":"#kafka副本同步机制","children":[]},{"level":3,"title":"分区策略 - message究竟要存到topic下面的哪个分区的策略","slug":"分区策略-message究竟要存到topic下面的哪个分区的策略","link":"#分区策略-message究竟要存到topic下面的哪个分区的策略","children":[]},{"level":2,"title":"关于我现在自己的项目的一个思考","slug":"关于我现在自己的项目的一个思考","link":"#关于我现在自己的项目的一个思考","children":[{"level":3,"title":"kafka的消费者只有1个，但是分区有5个，那么当这个消费者持有消费者组A消费了这个topic，这5个分区的消费位点都会往前挪动吗","slug":"kafka的消费者只有1个-但是分区有5个-那么当这个消费者持有消费者组a消费了这个topic-这5个分区的消费位点都会往前挪动吗","link":"#kafka的消费者只有1个-但是分区有5个-那么当这个消费者持有消费者组a消费了这个topic-这5个分区的消费位点都会往前挪动吗","children":[]},{"level":3,"title":"没有阿里云，怎么命令行界面上或者图形上看当前的topic的订阅者有哪些组，每个消费者组的消费位点是什么，堆积量多少","slug":"没有阿里云-怎么命令行界面上或者图形上看当前的topic的订阅者有哪些组-每个消费者组的消费位点是什么-堆积量多少","link":"#没有阿里云-怎么命令行界面上或者图形上看当前的topic的订阅者有哪些组-每个消费者组的消费位点是什么-堆积量多少","children":[]},{"level":3,"title":"有没有做堆积量告警，怎么做的","slug":"有没有做堆积量告警-怎么做的","link":"#有没有做堆积量告警-怎么做的","children":[]},{"level":3,"title":"消息查询按时间点、按位点、按分区如何使用查询","slug":"消息查询按时间点、按位点、按分区如何使用查询","link":"#消息查询按时间点、按位点、按分区如何使用查询","children":[]},{"level":3,"title":"如何查看某一个消费者组订阅的topic有哪些","slug":"如何查看某一个消费者组订阅的topic有哪些","link":"#如何查看某一个消费者组订阅的topic有哪些","children":[]},{"level":3,"title":"分区数量的数量设置依据什么合适","slug":"分区数量的数量设置依据什么合适","link":"#分区数量的数量设置依据什么合适","children":[]},{"level":3,"title":"分区的写入策略","slug":"分区的写入策略","link":"#分区的写入策略","children":[]},{"level":3,"title":"kafka同一个消费者会消费了同一个topic多个分区的同一个消费偏移吗","slug":"kafka同一个消费者会消费了同一个topic多个分区的同一个消费偏移吗","link":"#kafka同一个消费者会消费了同一个topic多个分区的同一个消费偏移吗","children":[]},{"level":3,"title":"增加分区后会有什么情况发生","slug":"增加分区后会有什么情况发生","link":"#增加分区后会有什么情况发生","children":[]},{"level":3,"title":"一个topic_1有4个分区，只有group_a订阅topic_1，对应的 group_a 的消费者consumer只有一个A，那么这个A可以订阅所有的分区吗","slug":"一个topic-1有4个分区-只有group-a订阅topic-1-对应的-group-a-的消费者consumer只有一个a-那么这个a可以订阅所有的分区吗","link":"#一个topic-1有4个分区-只有group-a订阅topic-1-对应的-group-a-的消费者consumer只有一个a-那么这个a可以订阅所有的分区吗","children":[]},{"level":3,"title":"ACK","slug":"ack","link":"#ack","children":[]},{"level":3,"title":"我的 client_A 目前占有1个topic的2个分区(p1,p2)，pull了500条数据(offset = 10~510)正在消费，消费到50%的时候260，重新加入了一个 client_B订阅该topic，那么这个时候会把client_A正在消费的另一个分区给p2 rebalance给 client_B 吗，如果会的话，会把 10~510的数据给 client_B 消费吗","slug":"我的-client-a-目前占有1个topic的2个分区-p1-p2-pull了500条数据-offset-10-510-正在消费-消费到50-的时候260-重新加入了一个-client-b订阅该topic-那么这个时候会把client-a正在消费的另一个分区给p2-rebalance给-client-b-吗-如果会的话-会把-10-510的数据给-client-b-消费吗","link":"#我的-client-a-目前占有1个topic的2个分区-p1-p2-pull了500条数据-offset-10-510-正在消费-消费到50-的时候260-重新加入了一个-client-b订阅该topic-那么这个时候会把client-a正在消费的另一个分区给p2-rebalance给-client-b-吗-如果会的话-会把-10-510的数据给-client-b-消费吗","children":[]},{"level":3,"title":"rebalance的触发情形有哪些，rebalance的底层原理是什么","slug":"rebalance的触发情形有哪些-rebalance的底层原理是什么","link":"#rebalance的触发情形有哪些-rebalance的底层原理是什么","children":[]}]}],"readingTime":{"minutes":12.6,"words":3779},"filePathRelative":"posts/kafka/kafka基础入门.md","localizedDate":"2023年4月8日","excerpt":"<h3>博客园-详细基础入门</h3>\\n<blockquote>\\n<p>高性能，低延迟提交日志存储，复制和传播的专用分布式文件系统</p>\\n</blockquote>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>注意是一个分布式文件系统</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);