<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/29/architecture/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/"/>
    <url>/2024/02/29/architecture/%E5%BA%B7%E5%A8%81%E5%AE%9A%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>系统的结构，取决于系统的成员的交流方式和沟通结构</p></blockquote><p>设计一个组织结构或系统时，需要考虑到人们之间的沟通和协作方式，以确保最终的设计能够促进有效的沟通和协作。</p><p>结构是为了高效沟通和协作，高效沟通和协作的方式决定了组织结构。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/27/redis/Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2024/02/27/redis/Redis%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis的常见问题"><a href="#Redis的常见问题" class="headerlink" title="Redis的常见问题"></a>Redis的常见问题</h3><ol><li>Redis的数据类型有哪几个分别用来干嘛</li><li></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>配置Nginx域名指向不同的服务</title>
    <link href="/2024/01/19/cni/%E9%85%8D%E7%BD%AENginx%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1/"/>
    <url>/2024/01/19/cni/%E9%85%8D%E7%BD%AENginx%E5%9F%9F%E5%90%8D%E6%8C%87%E5%90%91%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-配置和启动Nginx"><a href="#1-配置和启动Nginx" class="headerlink" title="1.配置和启动Nginx"></a>1.配置和启动Nginx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create nginx-test<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意不同版本docker可能指定网络的方式不太一样</span><br>docker run --name nginx \<br>  --network nginx-test -itd \<br>  -p 80:80 \<br>  -v ./nginx.conf:/etc/nginx/conf.d/proxy.conf \<br>  nginx:1.25.1<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nginx.conf">client_body_buffer_size 2048m;   # 设置客户端请求的缓冲区大小<br>client_header_buffer_size 2048m; # 设置客户端请求头部的缓冲区大小<br>client_max_body_size 2048m;      # 设置客户端请求的最大缓冲区大小<br><br>server &#123;<br>    listen 80;<br>    server_name a.com;<br><br>    location / &#123;<br>        proxy_pass http://127.0.0.1:5000;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>    &#125;<br>&#125;<br><br>server &#123;<br>    listen 80;<br>    server_name b.com;<br><br>    location / &#123;<br>        proxy_pass http://gin:8080;<br>        proxy_set_header Host $host;<br>        proxy_set_header X-Real-IP $remote_addr;<br>        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;<br>        proxy_set_header X-Forwarded-Proto $scheme;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-启动服务监听8080端口"><a href="#2-启动服务监听8080端口" class="headerlink" title="2.启动服务监听8080端口"></a>2.启动服务监听8080端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 服务默认端口是5678</span><br>docker run --network nginx-test -itd \<br>  --network-alias gin \<br>  435861851/gin:v0.0.1<br></code></pre></td></tr></table></figure><blockquote><p>注意: 此时访问在nginx内部访问gin:8080是输出Hello Gin</p></blockquote><h3 id="3-配置域名-x2F-etc-x2F-host"><a href="#3-配置域名-x2F-etc-x2F-host" class="headerlink" title="3.配置域名&#x2F;etc&#x2F;host"></a>3.配置域名&#x2F;etc&#x2F;host</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">127.0.0.1 b.com<br></code></pre></td></tr></table></figure><h3 id="4-使用IP访问"><a href="#4-使用IP访问" class="headerlink" title="4.使用IP访问"></a>4.使用IP访问</h3><p><a href="http://b.com/">http://b.com</a></p><blockquote><p>输出 <code>&#123;&quot;message&quot;:&quot;Hello Gin!&quot;&#125;</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/12/08/redis/%E9%AB%98%E5%8F%AF%E7%94%A8-%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="主从复制详解"><a href="#主从复制详解" class="headerlink" title="主从复制详解"></a>主从复制详解</h1><h3 id="主从复制如何执行"><a href="#主从复制如何执行" class="headerlink" title="主从复制如何执行"></a>主从复制如何执行</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">replicaof</span> <span class="hljs-number">192.168.0.1</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><h3 id="主动复制原理"><a href="#主动复制原理" class="headerlink" title="主动复制原理"></a>主动复制原理</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">RDB + buffer<br><br><span class="hljs-literal">slave</span> send psync<br><br><span class="hljs-keyword">master</span> <span class="hljs-title">send</span> FULLRESYNC&#123;runID,offset&#125;<br><br><span class="hljs-keyword">master</span> <span class="hljs-title">bgsave</span> create RDB &amp;&amp; create buffer <br><br><span class="hljs-keyword">master</span> <span class="hljs-title">send</span> RDB<br><br><span class="hljs-literal">slave</span> clear data &amp; load RDB<br><br><span class="hljs-keyword">master</span> <span class="hljs-title">send</span> replication buffer (after RDB <span class="hljs-keyword">write</span> operation)<br><br><span class="hljs-literal">slave</span> load replication buffer<br></code></pre></td></tr></table></figure><h3 id="调优思路"><a href="#调优思路" class="headerlink" title="调优思路"></a>调优思路</h3><ol><li>避免从服务器失联后全量复制 repl_backlog_buffer 缓冲区大小设置</li><li></li></ol><h3 id="频率"><a href="#频率" class="headerlink" title="频率"></a>频率</h3><ol><li>Redis 主节点默认每隔 10 秒对从节点发送 ping 命令判断从节点存活</li><li>从节点每隔 1 秒发送 replconf ack{offset} 命令给主节点上报自身当前的复制偏移量</li></ol><h3 id="从服务器不会自己做（过期删除或内存淘汰），主服务器内存淘汰后会生成del命令发给从服务器"><a href="#从服务器不会自己做（过期删除或内存淘汰），主服务器内存淘汰后会生成del命令发给从服务器" class="headerlink" title="从服务器不会自己做（过期删除或内存淘汰），主服务器内存淘汰后会生成del命令发给从服务器"></a>从服务器不会自己做（过期删除或内存淘汰），主服务器内存淘汰后会生成del命令发给从服务器</h3><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><ol><li>replication buffer</li><li>repl_backlog_buffer</li><li>全量复制</li><li>增量复制</li><li>基于长连接的命令传播</li></ol><h3 id="repl-backlog-buffer"><a href="#repl-backlog-buffer" class="headerlink" title="repl_backlog_buffer"></a>repl_backlog_buffer</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">从库断开之后，如何找到主从差异数据而设计的环形缓冲区<br><br>如果缓冲区被主库的写命令覆盖了，从库会重新进行全量复制<br><br>repl_backlog_buffer配置尽量大一些，可以降低主从断开后全量复制的概率<br></code></pre></td></tr></table></figure><h3 id="replication-buffer"><a href="#replication-buffer" class="headerlink" title="replication buffer"></a>replication buffer</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">主从库增量复制用的<span class="hljs-built_in">buffer</span>存储写命令用的<br></code></pre></td></tr></table></figure><h3 id="网络断开，从库再次连接，是全量还是增量"><a href="#网络断开，从库再次连接，是全量还是增量" class="headerlink" title="网络断开，从库再次连接，是全量还是增量"></a>网络断开，从库再次连接，是全量还是增量</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 从库的slave<span class="hljs-emphasis">_repl_</span>offset会通过psync命令发送给主库，主库根据复制进度决定<br><br><span class="hljs-bullet">2.</span> 主库repl<span class="hljs-emphasis">_backlog_</span>buffer的slave<span class="hljs-emphasis">_repl_</span>offset位置上的数据已经被覆盖掉，会全量复制<br></code></pre></td></tr></table></figure><h3 id="强烈建议主服务器开启持久化，也应该禁止自动重启"><a href="#强烈建议主服务器开启持久化，也应该禁止自动重启" class="headerlink" title="强烈建议主服务器开启持久化，也应该禁止自动重启"></a>强烈建议主服务器开启持久化，也应该禁止自动重启</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果未开启持久化，且支持自动重启，在很短时间内主节点重启且空了数据集，Redis Sentinel甚至没检测到主节点的失败未切换主节点，从库的所有数据也会被清空<br></code></pre></td></tr></table></figure><h3 id="为什么主从复制使用RDB而不是用AOF"><a href="#为什么主从复制使用RDB而不是用AOF" class="headerlink" title="为什么主从复制使用RDB而不是用AOF"></a>为什么主从复制使用RDB而不是用AOF</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">AOF重放命令耗时<br>RDB数据重载快<br>RDB压缩的二进制数据所以文件小、主从网络带宽占据小<br><br>AOF选择刷盘策略，选择不当容易影响Redis性能<br></code></pre></td></tr></table></figure><h3 id="命令repl-diskless-sync开启无磁盘复制模式"><a href="#命令repl-diskless-sync开启无磁盘复制模式" class="headerlink" title="命令repl-diskless-sync开启无磁盘复制模式"></a>命令repl-diskless-sync开启无磁盘复制模式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">RDB不存储磁盘而是直接发送<br></code></pre></td></tr></table></figure><h3 id="主库生成-RDB-文件和传输-RDB-文件压力大，所以有从库的从库的设计"><a href="#主库生成-RDB-文件和传输-RDB-文件压力大，所以有从库的从库的设计" class="headerlink" title="主库生成 RDB 文件和传输 RDB 文件压力大，所以有从库的从库的设计"></a>主库生成 RDB 文件和传输 RDB 文件压力大，所以有从库的从库的设计</h3><h3 id="主从复制的命令传播异步，延迟与数据的不一致不可避免"><a href="#主从复制的命令传播异步，延迟与数据的不一致不可避免" class="headerlink" title="主从复制的命令传播异步，延迟与数据的不一致不可避免"></a>主从复制的命令传播异步，延迟与数据的不一致不可避免</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 加配置扩展写和读负载<br><span class="hljs-bullet">2.</span> 监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据<br></code></pre></td></tr></table></figure><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/bitmap%E4%BD%8D%E5%9B%BE/"/>
    <url>/2023/12/08/redis/bitmap%E4%BD%8D%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="bitmap位图"><a href="#bitmap位图" class="headerlink" title="bitmap位图"></a>bitmap位图</h1><p>(bitmap)[<a href="http://c.biancheng.net/redis/bitmap.html]">http://c.biancheng.net/redis/bitmap.html]</a></p><h3 id="内存占用"><a href="#内存占用" class="headerlink" title="内存占用"></a>内存占用</h3><blockquote><p>位图（bitmap）同样属于 string 数据类型；512 MB 最大；</p></blockquote><h3 id="经典场景之记录签到情况"><a href="#经典场景之记录签到情况" class="headerlink" title="经典场景之记录签到情况"></a>经典场景之记录签到情况</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">SETBIT key offset value<br><br>SETBIT <span class="hljs-built_in">userID</span>(用户ID) <span class="hljs-number">1</span>(具体日期) <span class="hljs-built_in">bool</span>(是否签到)<br><br>一个用户一个位图<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/plan/"/>
    <url>/2023/12/08/redis/plan/</url>
    
    <content type="html"><![CDATA[<ol><li><p>redis 01-28  xiaolincoding\java全栈\Redis入门指南</p></li><li><p>mysql 01-29 xiaolincoding</p></li><li><p>golang 01-30\01-31</p></li><li><p>tcp&#x2F;ip </p></li><li><p>mongodb</p></li><li><p>kafka</p></li><li><p>elastic</p></li><li><p>k8s</p></li><li><p>个人优势</p></li><li><p>项目经验</p></li></ol><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E5%88%86%E7%89%87RedisCluster%E5%8E%9F%E7%90%86/"/>
    <url>/2023/12/08/redis/%E5%88%86%E7%89%87RedisCluster%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="集群分片"><a href="#集群分片" class="headerlink" title="集群分片"></a>集群分片</h1><blockquote><p>主从只是扩展了读，但是写和存储能力并未得到扩展</p></blockquote><h3 id="关键模块"><a href="#关键模块" class="headerlink" title="关键模块"></a>关键模块</h3><ol><li><p>哈希槽(Hash Slot)(数量是2^14&#x3D;16384)，Cluster每个节点负责一部分哈希槽</p></li><li><p>Keys hash tags 将相关Key分配到相同的hash slot</p></li><li><p>Cluster nodes属性</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">redis-cli cluster nodes<br><br>node id, address:<span class="hljs-keyword">port</span>, <span class="hljs-keyword">flags</span>, last ping sent, last pong received, configuration epoch, link <span class="hljs-keyword">state</span>, slots.<br></code></pre></td></tr></table></figure><p>Cluster总线</p></li><li><p>Cluster总线</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">节点之间通讯使用集群总线和集群总线协议：有不同的类型和大小的帧组成的二进制协议<br></code></pre></td></tr></table></figure></li><li><p>集群拓扑</p></li><li><p>节点握手</p></li></ol><h3 id="请求重定向"><a href="#请求重定向" class="headerlink" title="请求重定向"></a>请求重定向</h3><blockquote><p>去中心化思想，集群主节点各自负责一部分槽</p></blockquote><h3 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs llvm">客户端发送key命令，节点检查不存在会返回Moved 重定向，客户端收到以后会根据Moved再一次发送找寻目标节点<br><br>redis-cli -<span class="hljs-keyword">c</span> <br><br>-<span class="hljs-keyword">c</span> 是集群方式启动，即没加参数 -<span class="hljs-keyword">c</span>，redis-cli不会自动重定向<br></code></pre></td></tr></table></figure><h3 id="Ask重定向"><a href="#Ask重定向" class="headerlink" title="Ask重定向"></a>Ask重定向</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">集群伸缩会导致槽迁移，当我们去源节点访问时，此时数据已经可能已经迁移到了目标节点，使用<span class="hljs-built_in">Ask</span>重定向来解决此种情况<br></code></pre></td></tr></table></figure><h3 id="扩容-amp-缩容"><a href="#扩容-amp-缩容" class="headerlink" title="扩容&amp;缩容"></a>扩容&amp;缩容</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown">扩容<br><br><span class="hljs-bullet">1.</span> 节点纳入，cluster meet new<span class="hljs-emphasis">_node_</span>ip:new<span class="hljs-emphasis">_node_</span>port 或者 redis-trib add node<br><span class="hljs-bullet">2.</span> 数据迁移，将槽迁移到目标节点<br><br>缩容<br><br><span class="hljs-bullet">1.</span> 槽迁移<br><span class="hljs-bullet">2.</span> 广播下线 cluster forget nodeId<br></code></pre></td></tr></table></figure><h3 id="为什么Redis-Cluster的Hash-Slot-是2-14-x3D-16-1024"><a href="#为什么Redis-Cluster的Hash-Slot-是2-14-x3D-16-1024" class="headerlink" title="为什么Redis Cluster的Hash Slot 是2^14&#x3D;16*1024"></a>为什么Redis Cluster的Hash Slot 是2^14&#x3D;16*1024</h3><h3 id="为什么Redis-Cluster中不建议使用发布订阅"><a href="#为什么Redis-Cluster中不建议使用发布订阅" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅"></a>为什么Redis Cluster中不建议使用发布订阅</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">所有的publish命令都会向所有节点（包括从节点）进行广播，带宽消耗大<br></code></pre></td></tr></table></figure><h3 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h3><ol><li>数据如何分部在切片实例中</li><li>重定向机制</li><li></li></ol><h3 id="分片模式添加数据的逻辑"><a href="#分片模式添加数据的逻辑" class="headerlink" title="分片模式添加数据的逻辑"></a>分片模式添加数据的逻辑</h3><ol><li>key 转 hash槽，hash槽 转 节点</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">key</span> (CRC16算法) &gt;&gt;&gt; <span class="hljs-number">16</span> bit<br><br><span class="hljs-attribute">16</span> bit &gt;&gt;&gt;  <span class="hljs-number">1024</span>*<span class="hljs-number">16</span> (<span class="hljs-number">16384</span>) 取模  = hash槽值<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">实例和哈希槽的映射关系不是固定的<br><br>实例出现了新增或者删除，重新分配哈希槽，哈希槽在所有实例上重新分布一遍<br></code></pre></td></tr></table></figure><h3 id="如果有3个实例，而-test-数据分配在实例2的哈希槽之中，那么在实例1执行-get-test-的数据会发生什么"><a href="#如果有3个实例，而-test-数据分配在实例2的哈希槽之中，那么在实例1执行-get-test-的数据会发生什么" class="headerlink" title="如果有3个实例，而 test 数据分配在实例2的哈希槽之中，那么在实例1执行 get test 的数据会发生什么"></a>如果有3个实例，而 test 数据分配在实例2的哈希槽之中，那么在实例1执行 get test 的数据会发生什么</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">客户端在实例1执行 <span class="hljs-built_in">get</span> test<br><br>客户端收到MOVED命令后<br><br>客户端会再次向实例2发送请求<br><br>并更新客户端本地缓存中维护的哈希槽和实例的映射关系<br></code></pre></td></tr></table></figure><h3 id="ASK响应-和-MOVED响应"><a href="#ASK响应-和-MOVED响应" class="headerlink" title="ASK响应 和 MOVED响应"></a>ASK响应 和 MOVED响应</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">收到ask响应后虽然也和<span class="hljs-keyword">moved一样会继续请求新的实例</span><br><span class="hljs-keyword"></span><br>但是并不会更新客户端本地缓存中维护的哈希槽和实例的映射关系<br><br>收到 <span class="hljs-keyword">MOVEND响应会 </span>更新本地维护的哈希槽和实例的映射关系缓存<br></code></pre></td></tr></table></figure><h3 id="分片模式到底有没有数据拷贝？有没有同步异步复制的过程？"><a href="#分片模式到底有没有数据拷贝？有没有同步异步复制的过程？" class="headerlink" title="分片模式到底有没有数据拷贝？有没有同步异步复制的过程？"></a>分片模式到底有没有数据拷贝？有没有同步异步复制的过程？</h3><h3 id="分片的缺点"><a href="#分片的缺点" class="headerlink" title="分片的缺点"></a>分片的缺点</h3><ol><li>无法直接对映射在两个不同 Redis 实例上的键执行交集 (涉及多个键的操作通常不支持)</li><li>涉及多个键的事务不能使用</li><li>备份数据时需要聚合多个实例和主机的持久化文件</li></ol><h3 id="redis-分片副本"><a href="#redis-分片副本" class="headerlink" title="redis 分片副本"></a>redis 分片副本</h3><p><a href="https://baijiahao.baidu.com/s?id=1748526448763042395">深入了解 Redis 集群：分片算法和架构</a></p><ol><li><p>去中心化服务器端分片 - 官方 Redis 集群中实际使用的</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">请求可以命中任何 Redis 节点<br><br>每个节点都知道集群中的所有其他节点<br><br>处理请求的节点将首先检查自身或其他节点是否具有请求的数据<br><br>如果数据存储在其他地方，则将请求重定向到相应的节点<br></code></pre></td></tr></table></figure></li><li><p>分片算法</p></li></ol><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">一致的哈希<br><br>Redis 集群中使用的哈希槽分片<br><br><span class="hljs-attribute">slot</span> <span class="hljs-operator">=</span> CRC16(key) % <span class="hljs-number">16383</span><br></code></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1792305">分片详解</a></p><p><a href="https://developer.aliyun.com/article/845366">分片的高可用方案</a></p><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/cluster/"/>
    <url>/2023/12/08/redis/cluster/</url>
    
    <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ol><li>简介</li><li>如何安装使用（linux、docker、k8s）</li><li>底层原理</li><li>高可用、高性能优化配置</li></ol><h3 id="go的redis客户端需要连接池吗，不是说redis是单线程的？"><a href="#go的redis客户端需要连接池吗，不是说redis是单线程的？" class="headerlink" title="go的redis客户端需要连接池吗，不是说redis是单线程的？"></a>go的redis客户端需要连接池吗，不是说redis是单线程的？</h3><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://segmentfault.com/a/1190000038771812">深入学习Redis之Redis Cluster</a></p><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E5%88%86%E7%89%87RedisCluster%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/12/08/redis/%E5%88%86%E7%89%87RedisCluster%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis集群模式搭建"><a href="#Redis集群模式搭建" class="headerlink" title="Redis集群模式搭建"></a>Redis集群模式搭建</h1><ol><li>redis-conf</li><li>redis-cli –cluster create</li></ol><h3 id="Redis-conf配置"><a href="#Redis-conf配置" class="headerlink" title="Redis-conf配置"></a>Redis-conf配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#注释掉 bind 项，默认监听所有网卡 70 #bind 127.0.0.1</span><br><span class="hljs-comment">#关闭保护模式 89 protected-mode no</span><br><span class="hljs-comment">#redis默认端口6379 不用修改 port 6379</span><br><br><span class="hljs-comment"># 开启AOF持久化</span><br>appendonly <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># 开启守护进程</span><br>daemonize <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># 指定redis进程的PID文件存放位置</span><br>pidfile <span class="hljs-string">&quot;/home/centos/redis/redis-6.2.6/logs/redis/redis.pid&quot;</span><br><br><span class="hljs-comment"># log文件输出位置，如果进程以守护进程的方式运行，此处又将输出文件设置为stdout的话，就会将日志信息输出到/dev/null里面去了</span><br>logfile <span class="hljs-string">&quot;/home/centos/redis/redis-6.2.6/logs/redis/redis.log&quot;</span><br><br><span class="hljs-comment"># 默认16个数据库</span><br>databases 16<br><br><span class="hljs-comment"># 指定本地数据库文件名</span><br>dbfilename <span class="hljs-string">&quot;dump.db&quot;</span><br><br><span class="hljs-comment"># 指定本地数据问就按存放位置</span><br><span class="hljs-built_in">dir</span> <span class="hljs-string">&quot;/home/centos/redis/redis-6.2.6/logs/data&quot;</span><br><br><span class="hljs-comment"># 设置redis连接密码，如果配置了连接密码，客户端在连接redis是需要通过AUTH&lt;password&gt;命令提供密码，默认关闭</span><br>requirepass <span class="hljs-string">&quot;xyredis&quot;</span><br><br><span class="hljs-comment"># 开启集群功能</span><br>cluster-enabled <span class="hljs-built_in">yes</span><br><br><span class="hljs-comment"># 群集名称文件设置</span><br>cluster-config-file nodes-6379.conf<br><br><span class="hljs-comment"># 取消注释群集超时时间设置</span><br>cluster-node-timeout 15000<br></code></pre></td></tr></table></figure><h3 id="服务启动和连接"><a href="#服务启动和连接" class="headerlink" title="服务启动和连接"></a>服务启动和连接</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/redis-server /</span>home<span class="hljs-regexp">/centos/</span>redis<span class="hljs-regexp">/redis-6.2.6/</span>redis.conf<br></code></pre></td></tr></table></figure><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">redis-cli --cluster create --cluster-replicas <span class="hljs-number">1 192.168.0</span>.<span class="hljs-number">1:6379 192</span>.<span class="hljs-number">168.0.2</span>:<span class="hljs-number">6379 192.168</span>.<span class="hljs-number">0.3:6379</span> -a redis<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">redis-cli -c -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> redis (-<span class="hljs-selector-tag">a</span> 表示授权账户/密码登录 -c表示集群模式)<br></code></pre></td></tr></table></figure><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/12/08/redis/%E5%88%86%E7%89%87%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="redis-分片技术"><a href="#redis-分片技术" class="headerlink" title="redis 分片技术"></a>redis 分片技术</h1><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">最多1000节点<br><br>（集群节点间）使用异步复制<br></code></pre></td></tr></table></figure><h3 id="Keys-hash-tags，-用来将多个-相关的-key分配到相同的hash-slot中，Redis-Cluster中实现multi-key操作的基础"><a href="#Keys-hash-tags，-用来将多个-相关的-key分配到相同的hash-slot中，Redis-Cluster中实现multi-key操作的基础" class="headerlink" title="Keys hash tags， 用来将多个(相关的)key分配到相同的hash slot中，Redis Cluster中实现multi-key操作的基础"></a>Keys hash tags， 用来将多个(相关的)key分配到相同的hash slot中，Redis Cluster中实现multi-key操作的基础</h3><h3 id="每个节点维护着集群内其他节点的以下信息"><a href="#每个节点维护着集群内其他节点的以下信息" class="headerlink" title="每个节点维护着集群内其他节点的以下信息"></a>每个节点维护着集群内其他节点的以下信息</h3><blockquote><p>redis-cli cluster nodes</p></blockquote><blockquote><p>node id, address:port, flags, last ping sent, last pong received, configuration epoch, link state, slots</p></blockquote><h3 id="Cluster总线"><a href="#Cluster总线" class="headerlink" title="Cluster总线"></a>Cluster总线</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs excel">每个Redis Cluster节点有一个额外的TCP端口用来接受其他节点的连接<br><br><br>该端口往往是client连接的tcp端口+<span class="hljs-number">10000</span>（端口<span class="hljs-number">6379</span>监听客户端连接，那么它的集群总线端口<span class="hljs-number">16379</span>也会被打开）<br><br><br><span class="hljs-built_in">N</span>个节点的集群中，每个节点由<span class="hljs-built_in">N</span>-<span class="hljs-number">1</span>个TCP传出连接，和<span class="hljs-built_in">N</span>-<span class="hljs-number">1</span>个TCP传入连接<br><br><br>节点使用gossip协议和配置更新机制来避免在正常情况下节点之间交换过多的消息<br></code></pre></td></tr></table></figure><h3 id="Moved-重定向"><a href="#Moved-重定向" class="headerlink" title="Moved 重定向"></a>Moved 重定向</h3><ol><li>槽命中：直接返回结果</li><li>槽不命中：键不在节点中，向客户端发送一个Moved重定向，客户端再一次发送命令官方给目标节点</li></ol><blockquote><p>cluster keyslot keyName # 得到keyName的槽</p></blockquote><h3 id="ASK-重定向"><a href="#ASK-重定向" class="headerlink" title="ASK 重定向"></a>ASK 重定向</h3><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">集群伸缩会导致槽迁移<br><br>去源节点访问时，此时数据已经可能已经迁移到了目标节点<br><br>回复<span class="hljs-built_in">Ask</span>重定向<br><br>客户端重新发送请求到目标节点<br></code></pre></td></tr></table></figure><h3 id="扩容-amp-amp-缩容"><a href="#扩容-amp-amp-缩容" class="headerlink" title="扩容 &amp;&amp; 缩容"></a>扩容 &amp;&amp; 缩容</h3><ol><li>确定哪些槽需要被迁移到目标节点</li><li>然后获取槽中key</li><li>将槽中的key全部迁移到目标节点</li><li>向集群所有主节点广播槽（数据）全部迁移到了目标节点</li></ol><h3 id="为什么Redis-Cluster中不建议使用发布订阅呢"><a href="#为什么Redis-Cluster中不建议使用发布订阅呢" class="headerlink" title="为什么Redis Cluster中不建议使用发布订阅呢"></a>为什么Redis Cluster中不建议使用发布订阅呢</h3><blockquote><p>publish命令都会向所有节点（包括从节点）进行广播，加重了带宽负担</p></blockquote><h3 id="为什么Redis-Cluster的Hash-Slot-是16384-x3D-16k"><a href="#为什么Redis-Cluster的Hash-Slot-是16384-x3D-16k" class="headerlink" title="为什么Redis Cluster的Hash Slot 是16384&#x3D;16k"></a>为什么Redis Cluster的Hash Slot 是16384&#x3D;16k</h3><blockquote><p>bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) &#x3D; 16K），也就是说使用2k的空间创建了16k的槽数</p></blockquote><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/"/>
    <url>/2023/12/08/redis/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Redis入门指南"><a href="#Redis入门指南" class="headerlink" title="Redis入门指南"></a>Redis入门指南</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-number">9</span> 种数据类型<br><br>BitMap 二值状态统计的场景<br>Stream 消息队列<br>HyperLogLog 海量数据基数统计的场景<br>GEO 地理位置信息<br><br><br>HSET <span class="hljs-built_in">key</span> field value<br>KEYS<br>LPUSH LPOP<br>RPUSH RPOP<br>LLEN <span class="hljs-built_in">KEY</span><br>SADD <span class="hljs-built_in">KEY</span> member<br>SREM <span class="hljs-built_in">KEY</span> member<br><br>ZADD <span class="hljs-built_in">KEY</span> [score member]...<br>ZADD studend <span class="hljs-number">89</span> tom <span class="hljs-number">98</span> jack <span class="hljs-number">76</span> rose<br><br>MULTI<br>...<br><span class="hljs-built_in">EXEC</span><br><br>Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入<br><br>开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）<br><br>Watch 命令用于监视一个(或多个) <span class="hljs-built_in">key</span> ，如果在事务执行之前这个(或这些) <span class="hljs-built_in">key</span> 被其他命令所改动，那么事务将被打断 (CAS)<br><br>EXPIRE<br><br>SORT<br><br>SORT <span class="hljs-built_in">key</span> ALPHA [字典排序]<br><br>SORT <span class="hljs-built_in">key</span> DESC<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">单台设备的 Redis 的 QPS（Query <span class="hljs-keyword">Per</span> <span class="hljs-keyword">Second</span>，每秒钟处理完请求的次数） 是 MySQL 的 <span class="hljs-number">10</span> 倍，Redis 单机的 QPS 能轻松破 <span class="hljs-number">10</span>w，而 MySQL 单机的 QPS 很难破 <span class="hljs-number">1</span>w<br><br>单线程的 Redis QPS 可以达到 <span class="hljs-number">10</span>W<span class="hljs-operator">/</span>每秒<br></code></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">脑裂：多个主节点的现象<br>（主节点没有问题但是哨兵发现主节点无法连通将从节点选举为主节点的时候）<br><br><br>被降格为从节点的旧主节点<br><br>由于第一次同步是全量同步的方式，此时的从节点（<span class="hljs-selector-tag">A</span>）会清空掉自己本地的数据，然后再做全量同步<br></code></pre></td></tr></table></figure><blockquote><p>脑裂导致数据丢失，本质上是旧主节点降格为从节点之后，被清空数据再同步新主节点导致</p></blockquote><h3 id="脑裂解决方案"><a href="#脑裂解决方案" class="headerlink" title="脑裂解决方案"></a>脑裂解决方案</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs llvm">从节点下线时，禁止主节点写数据，直接返回error给客户端<br><br><br><span class="hljs-keyword">min</span>-slaves-<span class="hljs-keyword">to</span>-write <span class="hljs-keyword">x</span>：主节点必须要有至少 <span class="hljs-keyword">x</span> 个从节点连接，如果小于，主节点禁止写数据<br><br><span class="hljs-keyword">min</span>-slaves-<span class="hljs-keyword">max</span>-lag <span class="hljs-keyword">x</span>，主从数据复制和同步的延迟不能超过 <span class="hljs-keyword">x</span> 秒<br><br>避免原主库是假故障（哨兵认为故障，客户端认为非故障继续写数据，导致客户端写的数据丢失）<br></code></pre></td></tr></table></figure><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">过期字典<br><br>惰性删除: 访问<span class="hljs-built_in">key</span>后发现已经过期就删除<br><br>定期删除：定时随机取出一定数量的<span class="hljs-built_in">key</span>检查并删除其中过期的部分，如果比例超出<span class="hljs-number">25</span>%则会再次执行检查<br></code></pre></td></tr></table></figure><blockquote><p>注意： 过期删除策略和内存淘汰策略不是同一个东西</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">从库不会进行过期扫描，从库对过期的处理是被动的<br><br>Redis 内存满了，会出发内存淘汰机制、<br><br></code></pre></td></tr></table></figure><h3 id="内存淘汰算法"><a href="#内存淘汰算法" class="headerlink" title="内存淘汰算法"></a>内存淘汰算法</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">LRU</span> 全称是 Least Recently Used 翻译为最近最少使用，选择淘汰最近最少使用的数据<br><br>(随机采样的方式来淘汰数据，默认随机<span class="hljs-number">5</span>个淘汰最久没有使用的那个)<br><br>LFU 全称是 Least Frequently Used 翻译为最近最不常用的，依据数据访问次数来淘汰数据<br></code></pre></td></tr></table></figure><h3 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h3><ol><li>缓存雪崩 - 大量缓存同时过期（解决方案：将缓存失效时间随机打散、设置不过期）</li><li>缓存击穿 - 热点数据过期（业务请求加锁、不给热点数据设置过期时间而是后台主动更新缓存）</li><li>缓存穿透 - 数据库没有数据，缓存中也没法构建数据（非法请求限制、构建默认值）</li></ol><p><a href="https://www.cnblogs.com/cpselvis/p/6265825.html">布隆过滤器(Bloom Filter)的原理和实现</a></p><p><a href="https://learnku.com/articles/63352">布隆过滤器原理与实现 - golang</a></p><blockquote><p>一个很长的二进制向量和一系列随机映射函数，用于检索一个元素是否在一个集合中</p></blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">它的优点是空间效率和查询时间都远远超过一般的算法<br></code></pre></td></tr></table></figure><h3 id="Redis的ZSet-加-zrangebysocre-实现延迟队列"><a href="#Redis的ZSet-加-zrangebysocre-实现延迟队列" class="headerlink" title="Redis的ZSet 加 zrangebysocre 实现延迟队列"></a>Redis的ZSet 加 zrangebysocre 实现延迟队列</h3><h3 id="Redis-的大-key-如何处理？"><a href="#Redis-的大-key-如何处理？" class="headerlink" title="Redis 的大 key 如何处理？"></a>Redis 的大 key 如何处理？</h3><ol><li>客户端超时阻塞</li><li>网络阻塞</li><li>del大key会阻塞工作线程</li><li>内存分配不均（集群slot分配均匀的情况下）</li></ol><blockquote><p>String 类型的值大于 10 KB \ Hash、List、Set、ZSet 类型的元素的个数超过 5000个 通常叫做大Key</p></blockquote><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs clean">### 自带命令发现大key（集合只知道个数而不是实际内存量）<br>redis-cli --bigkeys<br><br>### 查看具体大小<br>MEMORY USAGE keyname1<br><br>### 字符串<br>STRLEN<br><br>### 列表List<br>LLEN<br><br>### hash哈希<br>HLEN<br><br>### Set类型<br>SCARD <br><br>### Sorted Set类型<br>ZCARD<br><br>### 第三方工具使用 RdbTools 工具查找大 key<br>redis-rdb-tools<br></code></pre></td></tr></table></figure><h3 id="Redis管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个-Redis-命令，提高交互性能"><a href="#Redis管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个-Redis-命令，提高交互性能" class="headerlink" title="Redis管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，提高交互性能"></a>Redis管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，提高交互性能</h3><h3 id="Redis是不支持事务回滚的，需要程序员手动回滚"><a href="#Redis是不支持事务回滚的，需要程序员手动回滚" class="headerlink" title="Redis是不支持事务回滚的，需要程序员手动回滚"></a>Redis是不支持事务回滚的，需要程序员手动回滚</h3><h3 id="Redis分布式锁-SETNX-KEY-NAME-VALUE"><a href="#Redis分布式锁-SETNX-KEY-NAME-VALUE" class="headerlink" title="Redis分布式锁 SETNX KEY_NAME VALUE"></a>Redis分布式锁 SETNX KEY_NAME VALUE</h3><ol><li>锁超时时间，守护进程自旋，无法限制业务执行时长</li><li>redis集群模式下同步延迟（Redlock）</li></ol><h3 id="redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗"><a href="#redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗" class="headerlink" title="redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗"></a>redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗</h3><h3 id="redis分片集群模式"><a href="#redis分片集群模式" class="headerlink" title="redis分片集群模式"></a>redis分片集群模式</h3><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E6%8C%81%E4%B9%85%E5%8C%96AOF%E6%97%A5%E5%BF%97/"/>
    <url>/2023/12/08/redis/%E6%8C%81%E4%B9%85%E5%8C%96AOF%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="AOF-Append-Only-File-日志"><a href="#AOF-Append-Only-File-日志" class="headerlink" title="AOF(Append Only File)日志"></a>AOF(Append Only File)日志</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">执行写命令完成后会记录日志到硬盘<br></code></pre></td></tr></table></figure><h3 id="如何开启"><a href="#如何开启" class="headerlink" title="如何开启"></a>如何开启</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># redis.conf</span><br><br>appendonly yes                    <span class="hljs-regexp">//</span>是否开启AOF持久化 <br>appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span>   <span class="hljs-regexp">//</span>AOF持久化文件名<br></code></pre></td></tr></table></figure><h3 id="为啥不在写命令执行前记录日志而是写命令执行之后呢"><a href="#为啥不在写命令执行前记录日志而是写命令执行之后呢" class="headerlink" title="为啥不在写命令执行前记录日志而是写命令执行之后呢"></a>为啥不在写命令执行前记录日志而是写命令执行之后呢</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">不阻塞写操作<br>检查开销<br></code></pre></td></tr></table></figure><h3 id="在写命令执行后记录日志有什么风险呢"><a href="#在写命令执行后记录日志有什么风险呢" class="headerlink" title="在写命令执行后记录日志有什么风险呢"></a>在写命令执行后记录日志有什么风险呢</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">丢失风险<br>主进程(执行命令\写日志) 阻塞 <span class="hljs-selector-attr">[下一个]</span> 命令<br></code></pre></td></tr></table></figure><h3 id="对风险消除的措施-写回硬盘策略变更-redis-conf-appendfsync"><a href="#对风险消除的措施-写回硬盘策略变更-redis-conf-appendfsync" class="headerlink" title="对风险消除的措施 - 写回硬盘策略变更 redis.conf.appendfsync"></a>对风险消除的措施 - 写回硬盘策略变更 redis.conf.appendfsync</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">Always   同步写回<span class="hljs-selector-attr">[最不可能丢数据]</span><br>Everysec 每秒写回来<span class="hljs-selector-attr">[可能丢失1s数据]</span><br>No       操作系统控制写回<span class="hljs-selector-attr">[性能最好]</span><span class="hljs-selector-attr">[数据丢失数量可能会很多]</span><br></code></pre></td></tr></table></figure><h3 id="AOF重写机制-应对AOF日志文件增长变大的问题"><a href="#AOF重写机制-应对AOF日志文件增长变大的问题" class="headerlink" title="AOF重写机制(应对AOF日志文件增长变大的问题)"></a>AOF重写机制(应对AOF日志文件增长变大的问题)</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">超过阙值<span class="hljs-number">64</span>M，最新的 <span class="hljs-selector-attr">[键值对]</span> 状态，一条命令记录，写完了文件覆盖形式更新AOF日志<br><br>后台子进程 bgrewriteaof 来完成避免阻塞主进程<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/12/08/redis/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%90%86%E8%A7%A3%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="数据结构角度解释各种数据类型差别"><a href="#数据结构角度解释各种数据类型差别" class="headerlink" title="数据结构角度解释各种数据类型差别"></a>数据结构角度解释各种数据类型差别</h1><h3 id="各种数据类型用了哪些数据结构"><a href="#各种数据类型用了哪些数据结构" class="headerlink" title="各种数据类型用了哪些数据结构"></a>各种数据类型用了哪些数据结构</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">string</span> 简单动态字符串 <span class="hljs-constructor">SDS(<span class="hljs-params">simple</span> <span class="hljs-params">dynamis</span> <span class="hljs-params">string</span>)</span><br><br>zset 跳表 + listpack<br><br>hash 哈希表<br><br>set 整数集合 + 哈希表<br><br><span class="hljs-built_in">list</span> quicklist<br></code></pre></td></tr></table></figure><h3 id="新旧版本-Redis-3-0-和-Redis-7-0最新-涉及哪9种数据结构"><a href="#新旧版本-Redis-3-0-和-Redis-7-0最新-涉及哪9种数据结构" class="headerlink" title="新旧版本(Redis 3.0 和 Redis 7.0最新)涉及哪9种数据结构"></a>新旧版本(Redis 3.0 和 Redis 7.0最新)涉及哪9种数据结构</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">SDS<br>双向链表<br>压缩列表ziplist<br>哈希表<span class="hljs-built_in">hash</span><br>跳表zskiplist<br>整数集合inset<br>quicklist<br>listpack<br></code></pre></td></tr></table></figure><h3 id="Redis所有的Key存储是什么数据结构，查找时间复杂度是啥"><a href="#Redis所有的Key存储是什么数据结构，查找时间复杂度是啥" class="headerlink" title="Redis所有的Key存储是什么数据结构，查找时间复杂度是啥"></a>Redis所有的Key存储是什么数据结构，查找时间复杂度是啥</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">哈希表hash<br><span class="hljs-function"><span class="hljs-title">O</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span><br></code></pre></td></tr></table></figure><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">散列函数 <span class="hljs-built_in">f</span>(key)<br>数组存放记录 - 数组也称为散列表<br>给定表M，任意key通过<span class="hljs-built_in">f</span>(key)直接获取表中的地址，则为哈希表<br></code></pre></td></tr></table></figure><h3 id="Redis的对象"><a href="#Redis的对象" class="headerlink" title="Redis的对象"></a>Redis的对象</h3><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">struct</span>&#123; <span class="hljs-keyword">type</span>, encoding, pointer &#125;<br></code></pre></td></tr></table></figure><h3 id="C语言字符串"><a href="#C语言字符串" class="headerlink" title="C语言字符串"></a>C语言字符串</h3><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs isbl">获取长度时间复杂度<span class="hljs-function"><span class="hljs-title">O</span>(<span class="hljs-variable">N</span>)</span><br>不能有<span class="hljs-string">&#x27;\0&#x27;</span>所以无法保存二进制数据<br>字符串操作有缓冲区溢出风险<br></code></pre></td></tr></table></figure><h3 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">simple dynamis <span class="hljs-type">string</span> 简单动态字符串<br><br>&#123;<span class="hljs-built_in">len</span>,alloc,flags,buf[]&#125;<br></code></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">Redis之中是双向链表<br>表头表尾节点获取时间复杂度都是<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>节点可以存储不同类型的值<br><br>链表因为内存不连续无法很好利用CPU缓存(数组因为内存是连续所以可以充分利用CPU缓存)<br></code></pre></td></tr></table></figure><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">内存紧凑型<br><br>过多元素查询效率会降低<br>新增修改需要内存空间重新分配<br></code></pre></td></tr></table></figure><h3 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">zset对象底层用到了<br><br>zrangebyscore范围查找就是用到了跳表，而查找元素用到了哈希表<br></code></pre></td></tr></table></figure><p>原理</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">跳表是链表基础上改进，号称 <span class="hljs-selector-attr">[多层]</span> 的有序链表<br><br>查找复杂度是 <span class="hljs-built_in">O</span>(logN)<br><br>struct&#123; <span class="hljs-selector-attr">[]</span>skiplistlevl&#123;*pointer...&#125; &#125;<br></code></pre></td></tr></table></figure><h3 id="为什么用跳表而不用平衡树-AVL树-红黑树"><a href="#为什么用跳表而不用平衡树-AVL树-红黑树" class="headerlink" title="为什么用跳表而不用平衡树(AVL树\红黑树)"></a>为什么用跳表而不用平衡树(AVL树\红黑树)</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">内存灵活<br>范围查找简单<br>经常更新消耗更小<br>实现难度更简单<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/"/>
    <url>/2023/12/08/redis/%E8%BF%87%E6%9C%9F%E5%88%A0%E9%99%A4%E5%92%8C%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis的过期删除和内存淘汰"><a href="#Redis的过期删除和内存淘汰" class="headerlink" title="Redis的过期删除和内存淘汰"></a>Redis的过期删除和内存淘汰</h1><h3 id="过期字典"><a href="#过期字典" class="headerlink" title="过期字典"></a>过期字典</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gauss">哈希表<br><span class="hljs-keyword">struct</span>&#123; <span class="hljs-built_in">key</span>,expired_timestamp &#125;<br><span class="hljs-built_in">key</span>存在过期字典之中且 system_timestamp &gt; expired_timestamp 表示已经过期<br></code></pre></td></tr></table></figure><h3 id="过期删除策略"><a href="#过期删除策略" class="headerlink" title="过期删除策略"></a>过期删除策略</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss">定时(设置<span class="hljs-built_in">key</span>过期就针对这个<span class="hljs-built_in">key</span>创建定时事件，CPU开销大但内存删除很及时)<br><br>惰性(<span class="hljs-built_in">key</span>被访问时如果过期了就删除)<br><br>定期(隔段时间随机检查一定数量的<span class="hljs-built_in">key</span>过期就删除)<br></code></pre></td></tr></table></figure><h3 id="Redis的是-惰性-定期"><a href="#Redis的是-惰性-定期" class="headerlink" title="Redis的是 惰性 + 定期"></a>Redis的是 惰性 + 定期</h3><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">间隔每秒<span class="hljs-number">10</span>次 <span class="hljs-comment">(redis.conf.hz 10)</span><br>随机抽查的数量<span class="hljs-number">20</span> <span class="hljs-comment">(过期数量&gt;25%就立刻再查一次)</span><br></code></pre></td></tr></table></figure><h3 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h3><blockquote><p>redis运行内存达到阙值就会删除符合条件的key</p></blockquote><h3 id="内存阙值"><a href="#内存阙值" class="headerlink" title="内存阙值"></a>内存阙值</h3><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp">redis.conf.maxmemory<br><br><span class="hljs-number">64</span>bit <span class="hljs-keyword">system</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span> 无限制<br><span class="hljs-number">32</span>bit <span class="hljs-keyword">system</span> <span class="hljs-keyword">default</span> <span class="hljs-number">3</span>G<br></code></pre></td></tr></table></figure><h3 id="默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误"><a href="#默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误" class="headerlink" title="默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误"></a>默认是不进行内存淘汰，达到阙值后不再提供服务直接返回错误</h3><blockquote><p>redis.conf.maxmemory-policy</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino">noeviction 不淘汰而是拒绝服务(Reids3<span class="hljs-number">.0</span> 之后默认)<br><br><span class="hljs-keyword">volatile</span>-random 设置了过期的随机淘汰<br><span class="hljs-keyword">volatile</span>-ttl 优先早过期的淘汰<br>allkeys-lru 淘汰最少使用的(important)<br>allkeys-random 随机淘汰<br></code></pre></td></tr></table></figure><h3 id="LRU算法-Least-Recently-Used-最近最少使用"><a href="#LRU算法-Least-Recently-Used-最近最少使用" class="headerlink" title="LRU算法( Least Recently Used ) 最近最少使用"></a>LRU算法( Least Recently Used ) 最近最少使用</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">链表实现<br>访问过的数据移动到链表头部<br></code></pre></td></tr></table></figure><h3 id="LFU算法-Least-Frequently-Used-最近最不常用通过记录访问频次"><a href="#LFU算法-Least-Frequently-Used-最近最不常用通过记录访问频次" class="headerlink" title="LFU算法(Least Frequently Used) 最近最不常用通过记录访问频次"></a>LFU算法(Least Frequently Used) 最近最不常用通过记录访问频次</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/12/08/redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="哨兵机制-Redis-Sendtinel"><a href="#哨兵机制-Redis-Sendtinel" class="headerlink" title="哨兵机制 Redis Sendtinel"></a>哨兵机制 Redis Sendtinel</h1><blockquote><p>哨兵的核心功能是主节点的自动故障转移</p></blockquote><h3 id="哨兵机制原理"><a href="#哨兵机制原理" class="headerlink" title="哨兵机制原理"></a>哨兵机制原理</h3><ol><li>哨兵之间集群建立、哨兵与主从库连接建立</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">哨兵实例之间可以相互发现，要归功于 Redis 提供的 pub/<span class="hljs-keyword">sub</span> 机制，也就是发布 / 订阅机制，他们共同订阅Redis的同一个频道，获取对方的<span class="hljs-built_in">IP</span>和端口号从而建立网络连接<br><br>每个哨兵发送<span class="hljs-meta">INFO</span>给主库，收到从库列表，进而与从库建立连接<br></code></pre></td></tr></table></figure><ol start="2"><li>哨兵之间通讯 send is-master-down-by-addr 收到的Y&#x2F;N判定各个哨兵主观下线是否存在</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">赞成票数如果大于或者等于哨兵配置之中的 quorum 配置项，则客观下线<br></code></pre></td></tr></table></figure><h3 id="哨兵选举"><a href="#哨兵选举" class="headerlink" title="哨兵选举"></a>哨兵选举</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Raft</span>选举算法： 选举的票数大于等于num(sentinels)/<span class="hljs-number">2</span>+<span class="hljs-number">1</span>时，将成为领导者，如果没有超过，继续选举<br></code></pre></td></tr></table></figure><h3 id="1主4从，5个哨兵，3个哨兵故障，主库宕机，只能标记主库下线，无法完成主从切换，为什么"><a href="#1主4从，5个哨兵，3个哨兵故障，主库宕机，只能标记主库下线，无法完成主从切换，为什么" class="headerlink" title="1主4从，5个哨兵，3个哨兵故障，主库宕机，只能标记主库下线，无法完成主从切换，为什么"></a>1主4从，5个哨兵，3个哨兵故障，主库宕机，只能标记主库下线，无法完成主从切换，为什么</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">哨兵只能获得2票没法获取 5/2 + 1</span>=<span class="hljs-string"> 3票</span><br></code></pre></td></tr></table></figure><h3 id="新主库的选出"><a href="#新主库的选出" class="headerlink" title="新主库的选出"></a>新主库的选出</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 选择redis.conf.salve-priority从节点优先级最高的<br><span class="hljs-bullet">2.</span> 选择复制偏移量最大，只复制最完整的从节点<br></code></pre></td></tr></table></figure><h3 id="哨兵如何切换从库为主库的呢"><a href="#哨兵如何切换从库为主库的呢" class="headerlink" title="哨兵如何切换从库为主库的呢"></a>哨兵如何切换从库为主库的呢</h3><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta">sentinels<span class="hljs-number">-3</span>通知<span class="hljs-keyword">client</span>切换主库<br>新主库执行 slaveof no one<br>其他从库执行 slaveof <span class="hljs-keyword">new</span> master<br></code></pre></td></tr></table></figure><h1 id="Full-stack-knowledge-system"><a href="#Full-stack-knowledge-system" class="headerlink" title="Full_stack_knowledge_system"></a>Full_stack_knowledge_system</h1><p><a href="https://pdai.tech/">pdai.tech</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/%E6%8C%81%E4%B9%85%E5%8C%96RDB%E5%BF%AB%E7%85%A7/"/>
    <url>/2023/12/08/redis/%E6%8C%81%E4%B9%85%E5%8C%96RDB%E5%BF%AB%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<h1 id="RDB快照"><a href="#RDB快照" class="headerlink" title="RDB快照"></a>RDB快照</h1><blockquote><p>某一个瞬间的内存数据</p></blockquote><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">SAVE</span><br><span class="hljs-attribute">BGSAVE</span><br></code></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">二进制<br>数据恢复效率更高<br></code></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arcade">全量快照开销大<br>通常<span class="hljs-number">5</span><span class="hljs-built_in">min</span>快照一次，数据丢失量也大<br></code></pre></td></tr></table></figure><h3 id="记录快照和数据修改的冲突"><a href="#记录快照和数据修改的冲突" class="headerlink" title="记录快照和数据修改的冲突"></a>记录快照和数据修改的冲突</h3><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">写时复制技术（<span class="hljs-keyword">Copy</span>-<span class="hljs-keyword">On</span>-<span class="hljs-keyword">Write</span>, COW）<br><br>主进程(写读命令)和bgsave子进程共享所有内存数据<br><br>主进程更改数据前是将共享数据复制一份出来修改的(写时复制),极端情况所有内存修改那么所有内存都要复制<br><br>谨防内存占满<br></code></pre></td></tr></table></figure><h3 id="Redis4-0-混合持久化"><a href="#Redis4-0-混合持久化" class="headerlink" title="Redis4.0 混合持久化"></a>Redis4.0 混合持久化</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis.<span class="hljs-keyword">conf</span>.aof-<span class="hljs-keyword">use</span>-rdb-preamble yes<br></code></pre></td></tr></table></figure><blockquote><p>准确来说就是既记录内存快照，也记录增量命令到AOF</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/Key/"/>
    <url>/2023/12/08/redis/Key/</url>
    
    <content type="html"><![CDATA[<h1 id="Reids-键-Key"><a href="#Reids-键-Key" class="headerlink" title="Reids 键 Key"></a>Reids 键 Key</h1><ol><li><p>删除Key</p></li><li><p>检查Key是否存在</p></li><li><p>设置Key过期时间</p></li><li><p>查找所有符合给定模式( pattern)的Key</p></li><li><p>获取Key的过期时间(ms&#x2F;s)</p></li><li><p>修改Key的名称</p></li><li><p>返回Key存储的值的类型</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/List/"/>
    <url>/2023/12/08/redis/List/</url>
    
    <content type="html"><![CDATA[<h1 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h1><ol><li><p>往Key列表PUSH指定元素(头部\尾部)</p></li><li><p>移出并获取列表Key的第一个元素\最后一个元素</p></li><li><p>获取列表指定返回的元素</p></li><li><p>获取列表指定索引的元素</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/Blogs/"/>
    <url>/2023/12/08/redis/Blogs/</url>
    
    <content type="html"><![CDATA[<h1 id="使用Redis搭建博客"><a href="#使用Redis搭建博客" class="headerlink" title="使用Redis搭建博客"></a>使用Redis搭建博客</h1><ol><li><p>存储文章内容k-v形式存储字符串(序列化内容)</p></li><li><p>文章访问量自增 INCRBY</p></li><li><p>文章内容访问或更改属性麻烦更换为散列 HSET key field value</p></li><li><p>获取文章列表使用列表类型list LPUSH RPUSH LPOP RPOP</p></li><li><p>文章的标签tags存储使用集合类型 SCARD key</p></li><li><p>文章按照访问量排序 - 有序集合 ZCOUNT key min max</p></li></ol><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><ol><li>字符串类型<br> 简单的一对一映射关系，刚开始采用序列化数组为字符串存储 { name &#x3D;&gt; ‘jck’ }</li><li>哈希类型<br> 存储对象，并且可以直接对对象的某一个属性进行增删改查 {id &#x3D;&gt; {‘name’:’jack’,’title’&#x3D;&gt;’taitannike’,’time’&#x3D;&gt;’2018-08-08 15:20’}}</li><li>列表类型（改变某一个的顺序需要把列表的每一个元素全部重新排列）<br> 获取文章列表分页数据的时候，需要用列表，但是依然需要解决排序、取中间片段速度缓慢的问题  [1,2,3,4,5]</li><li>集合类型<br> 存储文章标签的时候，如何做到标签唯一，有就无操作无就存入. id &#x3D;&gt; {“美食”,”旅行”,”装饰”}</li><li>有序集合类型 - (散列+跳跃表实现，所以中间存取也是极快)<br> 号称最高级的数据类型，就是序号加值，但是他可以做到按序号大小获取中间片段，以及按大小排序 {score &#x3D;&gt; {[‘89’,’tom’],[‘99’,’marry’]}}</li></ol><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis 提供了丰富的数据类型，常见的有五种数据类型：</p><p>String（字符串）</p><p>Hash（哈希）</p><p>List（列表）</p><p>Set（集合）</p><p>Zset（有序集合）。</p><h1 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h1><p>1、事务</p><p>2、生存时间</p><p>3、排序</p><p>4、消息通知</p><h1 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h1><p>1、持久化</p><p>2、复制</p><p>3、安全</p><p>4、通信协议</p><p>5、管理工具</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/redis/Hash/"/>
    <url>/2023/12/08/redis/Hash/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis-哈希-hash"><a href="#Redis-哈希-hash" class="headerlink" title="Redis 哈希(hash)"></a>Redis 哈希(hash)</h1><ol><li><p>获取哈希表之中所有的字段和值</p></li><li><p>查看哈希表之中指定的Key是否存在</p></li><li><p>删除哈希表字段Key</p></li><li><p>哈希表的指定Key的指定字段field设置增量increment</p></li><li><p>获取哈希表中所有字段</p></li><li><p>设置哈希表之中Key的指定的字段field值</p></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/infoq/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/"/>
    <url>/2023/12/08/infoq/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%9A%84%E8%89%BA%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<ol><li>如何优雅的写单元测试</li><li>为什么单元测试不止是验证，而是可以提升代码质量必备技能</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/etcd/docker%E5%90%AF%E5%8A%A8etcd2/"/>
    <url>/2023/12/08/etcd/docker%E5%90%AF%E5%8A%A8etcd2/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/etcd/docker%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%BC%80%E5%90%AFssl%E9%AA%8C%E8%AF%81/"/>
    <url>/2023/12/08/etcd/docker%E7%94%9F%E6%88%90%E8%AF%81%E4%B9%A6%E5%BC%80%E5%90%AFssl%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h1 id="docker生成证书开启ssl验证"><a href="#docker生成证书开启ssl验证" class="headerlink" title="docker生成证书开启ssl验证"></a>docker生成证书开启ssl验证</h1><h3 id="1-docker生成证书"><a href="#1-docker生成证书" class="headerlink" title="1. docker生成证书"></a>1. docker生成证书</h3><h3 id="2-使用生成的证书和密钥启动客户端"><a href="#2-使用生成的证书和密钥启动客户端" class="headerlink" title="2. 使用生成的证书和密钥启动客户端"></a>2. 使用生成的证书和密钥启动客户端</h3><h3 id="3-使用证书和密钥连接服务端"><a href="#3-使用证书和密钥连接服务端" class="headerlink" title="3. 使用证书和密钥连接服务端"></a>3. 使用证书和密钥连接服务端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -it -v $(<span class="hljs-built_in">pwd</span>)/etcd:/root centos:centos7 sh<br>$ yum install wget<br>$ wget https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssljson_1.6.4_linux_arm64<br>$ wget https://github.com/cloudflare/cfssl/releases/download/v1.6.4/cfssl_1.6.4_linux_arm64<br>$ <span class="hljs-built_in">cp</span> cfssl_1.6.4_linux_arm64 /usr/local/bin/cfssl<br>$ <span class="hljs-built_in">cp</span> cfssljson_1.6.4_linux_arm64 /usr/local/bin/cfssljson<br>$ <span class="hljs-built_in">chmod</span> +x /usr/local/bin/cfssl &amp;&amp; <span class="hljs-built_in">chmod</span> +x /usr/local/bin/cfssljson<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// config.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;signing&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;default&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;usages&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>          <span class="hljs-string">&quot;signing&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-string">&quot;key encipherment&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-string">&quot;server auth&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-string">&quot;client auth&quot;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;expiry&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;87600h&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// ca-csr.json </span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;algo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rsa&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2048</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;names&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;O&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;etcd&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;OU&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;etcd&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;L&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;apisix&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;ST&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;apisix&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;C&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;china&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;CN&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;etcd&quot;</span><br><span class="hljs-punctuation">&#125;</span> <br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// server.json </span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;key&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;algo&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rsa&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2048</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;names&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;O&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;etcd&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;OU&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;etcd&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;L&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;apisix&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;ST&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;apisix&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;C&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;china&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;CN&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;etcd&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;hosts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;192.168.4.61&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成 CA 证书和密钥 </span><br><span class="hljs-comment"># ca-key.pem 文件是 CA 私钥文件。CA 私钥用于签署服务器证书。CA 私钥是敏感文件，请妥善保管。</span><br><span class="hljs-comment"># ca.pem 文件是 CA 证书文件。CA 证书用于验证服务器证书。CA 证书是可公开访问的文件。</span><br><span class="hljs-comment"># server-key.pem 文件是服务器私钥文件。服务器私钥用于加密客户端数据。服务器私钥是敏感文件，请妥善保管。</span><br><span class="hljs-comment"># ca.csr 文件是 CA 证书请求文件。CA 证书请求文件包含服务器的信息，用于 CA 签署服务器证书。</span><br><span class="hljs-comment"># server.csr 文件是服务器证书请求文件。服务器证书请求文件包含服务器的信息，用于 CA 签署服务器证书。</span><br><span class="hljs-comment"># server.pem 文件是服务器证书文件。服务器证书用于验证客户端连接。服务器证书是可公开访问的文件</span><br>cfssl gencert --initca=<span class="hljs-literal">true</span> ca-csr.json | cfssljson --bare ca<br><br><br><span class="hljs-comment"># 生成服务器证书和密钥的命令</span><br><span class="hljs-comment"># 查看服务器证书和密钥 ls -al server*</span><br>cfssl gencert --ca ca.pem --ca-key ca-key.pem --config config.json server.json | cfssljson --bare server<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># vim /app/etcd/conf/conf.yml</span><br>name: etcd01<br>data-dir: /app/etcd/data<br>initial-advertise-peer-urls: https://192.168.4.61:2380<br>listen-peer-urls: https://192.168.4.61:2380<br>listen-client-urls: https://192.168.4.61:2379,http://127.0.0.1:2379<br>advertise-client-urls: https://192.168.4.61:2379<br>initial-cluster-token: apisix-etcd-cluster<br>initial-cluster: etcd01=https://192.168.4.61:238<br>initial-cluster-state: new<br><br><span class="hljs-comment"># [security]</span><br>client-transport-security:<br>  client-cert-auth: <span class="hljs-literal">true</span><br>  trusted-ca-file: /app/etcd/cfssl/ca.pem<br>  cert-file: /app/etcd/cfssl/server.pem<br>  key-file: /app/etcd/cfssl/server-key.pem<br>peer-transport-security: <br>  client-cert-auth: <span class="hljs-literal">true</span><br>  trusted-ca-file: /app/etcd/cfssl/ca.pem<br>  cert-file: /app/etcd/cfssl/server.pem<br>  key-file: /app/etcd/cfssl/server-key.pem<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create app-tier --driver bridge<br><br><span class="hljs-comment"># 启动服务端</span><br>docker run -d --name Etcd-server \<br>    --network app-tier \<br>    -v $(<span class="hljs-built_in">pwd</span>)/data:/bitnami/etcd/data \<br>    -v $(<span class="hljs-built_in">pwd</span>)/etcd/ca.pem:/bitnami/etcd/certs/ca.pem \<br>    -v $(<span class="hljs-built_in">pwd</span>)/etcd/server.pem:/bitnami/etcd/certs/server.pem \<br>    -v $(<span class="hljs-built_in">pwd</span>)/etcd/server-key.pem:/bitnami/etcd/certs/server-key.pem \<br>    -v $(<span class="hljs-built_in">pwd</span>)/conf.yml:/opt/bitnami/etcd/conf/etcd.conf.yml \<br>    --<span class="hljs-built_in">env</span> ALLOW_NONE_AUTHENTICATION=<span class="hljs-built_in">yes</span> \<br>    --<span class="hljs-built_in">env</span> ETCD_ADVERTISE_CLIENT_URLS=https://etcd-server:2379 \<br>    bitnami/etcd:latest<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --<span class="hljs-built_in">rm</span> \<br>    bitnami/etcd:latest etcdctl cert create-ca --out ca.pem<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><br><span class="hljs-comment"># 启动客户端</span><br>docker run -it --<span class="hljs-built_in">rm</span> \<br>    --network app-tier \<br>    -v $(<span class="hljs-built_in">pwd</span>)/etcd:/home/etcd \<br>    bitnami/etcd:latest etcdctl --cacert=/home/etcd/ca.pem \<br>    --cert=/home/etcd/server.pem --key=/home/etcd/server-key.pem \<br>    --endpoints https://etcd-server:2379 put /message Hello<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/12/08/docker/%E5%A6%82%E4%BD%95%E6%8B%89%E5%8F%96%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <url>/2023/12/08/docker/%E5%A6%82%E4%BD%95%E6%8B%89%E5%8F%96%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F%E5%B9%B6%E5%AD%98%E5%82%A8%E5%88%B0%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="如何存储多架构镜像到私有库"><a href="#如何存储多架构镜像到私有库" class="headerlink" title="如何存储多架构镜像到私有库"></a>如何存储多架构镜像到私有库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 多架构镜像</span><br><span class="hljs-comment"># quay.io/coreos/etcd:v3.5.0</span><br><br>$ docker pull --platform=linux/amd64 quay.io/coreos/etcd:v3.5.0 <br><br>$ docker tag quay.io/coreos/etcd:v3.5.0 registry.bingosoft.net/bingokube/etcd:v3.5.0-amd64<br><br>$ docker pull --platform=linux/arm64 quay.io/coreos/etcd:v3.5.0 <br><br>$ docker tag quay.io/coreos/etcd:v3.5.0 registry.bingosoft.net/bingokube/etcd:v3.5.0-arm64<br><br><br>$ docker push registry.bingosoft.net/bingokube/etcd:v3.5.0-amd64<br><br>$ docker push registry.bingosoft.net/bingokube/etcd:v3.5.0-arm64<br><br><span class="hljs-comment"># 此时无法拉取镜像下面的无法执行</span><br>$ docker pull registry.bingosoft.net/bingokube/etcd:v3.5.0<br><br><span class="hljs-comment"># 制作清单</span><br>$ docker manifest create --insecure registry.bingosoft.net/bingokube/etcd:v3.5.0 registry.bingosoft.net/bingokube/etcd:v3.5.0-amd64 registry.bingosoft.net/bingokube/etcd:v3.5.0-arm64<br><br><span class="hljs-comment"># 推送清单</span><br>$ docker manifest push --insecure registry.bingosoft.net/bingokube/etcd:v3.5.0<br><br><span class="hljs-comment"># 查看清单</span><br>$ docker manifest inspect registry.bingosoft.net/bingokube/etcd:v3.5.0<br>&#123;<br>   <span class="hljs-string">&quot;schemaVersion&quot;</span>: 2,<br>   <span class="hljs-string">&quot;mediaType&quot;</span>: <span class="hljs-string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,<br>   <span class="hljs-string">&quot;manifests&quot;</span>: [<br>      &#123;<br>         <span class="hljs-string">&quot;mediaType&quot;</span>: <span class="hljs-string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,<br>         <span class="hljs-string">&quot;size&quot;</span>: 1783,<br>         <span class="hljs-string">&quot;digest&quot;</span>: <span class="hljs-string">&quot;sha256:abc&quot;</span>,<br>         <span class="hljs-string">&quot;platform&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;architecture&quot;</span>: <span class="hljs-string">&quot;amd64&quot;</span>,<br>            <span class="hljs-string">&quot;os&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span><br>         &#125;<br>      &#125;,<br>      &#123;<br>         <span class="hljs-string">&quot;mediaType&quot;</span>: <span class="hljs-string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,<br>         <span class="hljs-string">&quot;size&quot;</span>: 1576,<br>         <span class="hljs-string">&quot;digest&quot;</span>: <span class="hljs-string">&quot;sha256:abc&quot;</span>,<br>         <span class="hljs-string">&quot;platform&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;architecture&quot;</span>: <span class="hljs-string">&quot;arm64&quot;</span>,<br>            <span class="hljs-string">&quot;os&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span><br>         &#125;<br>      &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DNS服务配置有哪些</title>
    <link href="/2023/09/15/network/DNS%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <url>/2023/09/15/network/DNS%E6%9C%8D%E5%8A%A1%E9%85%8D%E7%BD%AE%E6%9C%89%E5%93%AA%E4%BA%9B/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是DNS"><a href="#一、什么是DNS" class="headerlink" title="一、什么是DNS"></a>一、什么是DNS</h3><ol><li>DNS（Domain Name System）是一个用于将域名转换为与之关联的IP地址的分布式系统。</li></ol><p>在Linux上，有几个与DNS相关的配置：</p><h3 id="二、Linux与DNS相关命令"><a href="#二、Linux与DNS相关命令" class="headerlink" title="二、Linux与DNS相关命令"></a>二、Linux与DNS相关命令</h3><ol><li><code>/etc/resolv.conf</code>文件：这个文件包含了DNS服务器的配置信息，如名称服务器的IP地址、搜索域等。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 未配置DNS Server的</span><br>[root@i-62BEC048 ~]<span class="hljs-comment"># cat /etc/resolv.conf</span><br><span class="hljs-comment"># Generated by NetworkManager</span><br><br><br><span class="hljs-comment"># 已经配置了DNS Server的</span><br>[root@i-62BEC048 ~]<span class="hljs-comment"># cat /etc/resolv.conf</span><br><span class="hljs-comment"># Generated by NetworkManager</span><br>nameserver 114.114.114.114<br></code></pre></td></tr></table></figure><ol start="2"><li>Ubuntu 下 DNS 解析相关的命令<code>systemd-resolve</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.查看 DNS 服务状态</span><br>$ systemd-resolve --status<br><br><span class="hljs-comment"># 2.解析域名的的 IP</span><br>$ systemd-resolve DOMAIN<br><br><span class="hljs-comment"># 3.nslookup 解析domain</span><br>$ nslookup baidu.com<br><br><span class="hljs-comment"># 4.设置网卡的 DNS Server</span><br>$ systemd-resolve --set-dns=&#123;DNS_SERVER_IP&#125; --interface &#123;ITERFACE_NAME&#125;<br><br><span class="hljs-comment"># 5.重置网卡DNS配置</span><br>$ systemd-resolve --revert --interface &#123;ITERFACE_NAME&#125;<br><br><span class="hljs-comment"># 6.刷新网卡DNS缓存</span><br>$ systemd-resolve --flush-caches<br><br><span class="hljs-comment"># 7.查看DNS相关配置</span><br>$ systemd-resolve --statistics<br></code></pre></td></tr></table></figure><ol start="3"><li>hosts文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>nameserver 114.114.114.114是什么来的</li></ol><p>114.114.114.114是中国电信运营商提供的公共的DNS服务器。DNS服务器用于转换域名（如<a href="http://www.google.com)和ip地址之间的对应关系,以便让计算机能够在互联网上进行通信.通过指定114.114.114.114作为dns服务器,可以使用中国电信的dns服务来解析域名./">www.google.com）和IP地址之间的对应关系，以便让计算机能够在互联网上进行通信。通过指定114.114.114.114作为DNS服务器，可以使用中国电信的DNS服务来解析域名。</a></p><ol start="2"><li>server 8.8.8.8</li></ol><p><code>dns-nameservers 8.8.8.8</code>是用来指定DNS服务器的IP地址，其中8.8.8.8是Google提供的公共DNS服务器的IP地址。DNS服务器用于将域名解析为对应的IP地址。</p><p>在Linux上，可以通过设置<code>dns-nameservers</code>来指定所使用的DNS服务器。在上述示例中，<code>dns-nameservers 8.8.8.8</code>表示使用Google的DNS服务器进行域名解析。</p><p>在与<code>nameserver 114.114.114.114</code>的关系上，<code>nameserver 114.114.114.114</code>是指定的另一个DNS服务器的IP地址，由中国电信提供。不同的<code>nameserver</code>配置指定了不同的DNS服务器，用于解析域名。根据需要，可以根据实际情况选择使用不同的DNS服务器进行域名解析。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是DHCP</title>
    <link href="/2023/09/14/network/%E4%BB%80%E4%B9%88%E6%98%AFDHCP/"/>
    <url>/2023/09/14/network/%E4%BB%80%E4%B9%88%E6%98%AFDHCP/</url>
    
    <content type="html"><![CDATA[<h3 id="DHCP概念"><a href="#DHCP概念" class="headerlink" title="DHCP概念"></a>DHCP概念</h3><p>DHCP（Dynamic Host Configuration Protocol）是一种网络协议，用于自动分配IP地址和其他网络配置参数给计算机设备。静态IP地址是由管理员手动分配给设备的固定IP地址，不通过DHCP协议进行动态分配。</p><h3 id="静态IP"><a href="#静态IP" class="headerlink" title="静态IP"></a>静态IP</h3><h5 id="1-更新网卡配置文件"><a href="#1-更新网卡配置文件" class="headerlink" title="1.更新网卡配置文件"></a>1.更新网卡配置文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 系统信息</span><br>$ hostnamectl<br>        Virtualization: kvm<br>    Operating System: openEuler 22.03 (LTS-SP1)<br>    Kernel: Linux 5.10.0-136.12.0.86.oe2203sp1.x86_64<br>        Architecture: x86-64<br><br><span class="hljs-comment"># 网卡配置</span><br>vi /etc/sysconfig/network-scripts/ifcfg-ens8<br></code></pre></td></tr></table></figure><h4 id="2-网卡配置内容"><a href="#2-网卡配置内容" class="headerlink" title="2.网卡配置内容"></a>2.网卡配置内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">TYPE=Ethernet<br>PROXY_METHOD=none<br>BROWSER_ONLY=no<br>BOOTPROTO=static<br>DEFROUTE=no<br>IPV4_FAILURE_FATAL=no<br>NAME=enp8s0<br>DEVICE=enp8s0<br>ONBOOT=<span class="hljs-built_in">yes</span><br>IPADDR=192.168.1.7<br>NETMASK=255.255.255.0<br>GATEWAY=192.168.1.1<br></code></pre></td></tr></table></figure><h4 id="3-重启网络服务"><a href="#3-重启网络服务" class="headerlink" title="3.重启网络服务"></a>3.重启网络服务</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl restart network<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ebpf钩子</title>
    <link href="/2023/09/07/ebpf/%E9%92%A9%E5%AD%90/"/>
    <url>/2023/09/07/ebpf/%E9%92%A9%E5%AD%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、eBPF程序处理"><a href="#一、eBPF程序处理" class="headerlink" title="一、eBPF程序处理"></a>一、eBPF程序处理</h3><ol><li>用户编写 eBPF 程序，可以使用 eBPF 汇编或者 eBPF 特有的 C 语言来编写。</li><li>使用 LLVM&#x2F;CLang 编译器，将 eBPF 程序编译成 eBPF 字节码。</li><li>调用 bpf() 系统调用把 eBPF 字节码加载到内核。</li></ol><h3 id="二、start"><a href="#二、start" class="headerlink" title="二、start"></a>二、start</h3><ol><li>install bcc</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install bcc-tools<br>$ bcc -v<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">hello_world</span><span class="hljs-params">(<span class="hljs-type">void</span> *ctx)</span><br>&#123;<br>    bpf_trace_printk(<span class="hljs-string">&quot;Hello, World!&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># 1) 加载 BCC 库</span><br><span class="hljs-keyword">from</span> bcc <span class="hljs-keyword">import</span> BPF<br><br><span class="hljs-comment"># 2) 加载 eBPF 内核态程序</span><br>b = BPF(src_file=<span class="hljs-string">&quot;hello.c&quot;</span>)<br><br><span class="hljs-comment"># 3) 将 eBPF 程序挂载到 kprobe</span><br>b.attach_kprobe(event=<span class="hljs-string">&quot;do_sys_openat2&quot;</span>, fn_name=<span class="hljs-string">&quot;hello_world&quot;</span>)<br><br><span class="hljs-comment"># 4) 读取并且打印 eBPF 内核态程序输出的数据</span><br>b.trace_print()<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo python3 hello.py<br></code></pre></td></tr></table></figure><p><a href="https://github.com/iovisor/bcc/blob/master/INSTALL.md">https://github.com/iovisor/bcc/blob/master/INSTALL.md</a></p><h3 id="当eBPF遇上Linux内核网络"><a href="#当eBPF遇上Linux内核网络" class="headerlink" title="当eBPF遇上Linux内核网络"></a>当eBPF遇上Linux内核网络</h3><h3 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h3><p><a href="https://zhuanlan.zhihu.com/p/480811707">https://zhuanlan.zhihu.com/p/480811707</a></p>]]></content>
    
    
    <categories>
      
      <category>ebpf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ebpf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用tun设备隧道通信</title>
    <link href="/2023/08/25/network/%E4%BD%BF%E7%94%A8tun%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0VPN%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/08/25/network/%E4%BD%BF%E7%94%A8tun%E8%AE%BE%E5%A4%87%E5%AE%9E%E7%8E%B0VPN%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><h5 id="1-什么是TUN设备"><a href="#1-什么是TUN设备" class="headerlink" title="1.什么是TUN设备"></a>1.什么是TUN设备</h5><p>在计算机网络中，TUN 与 TAP 是操作系统内核中的虚拟网络设备。</p><ul><li><p>tun是网络层的虚拟网络设备，可以收发第三层数据报文包，如IP封包，因此常用于一些点对点IP隧道等。</p></li><li><p>tap是链路层的虚拟网络设备，等同于一个以太网设备，它可以收发第二层数据报文包，如以太网数据帧。Tap最常见的用途就是做为虚拟机的网卡，因为它和普通的物理网卡更加相近，也经常用作普通机器的虚拟网卡。</p></li></ul><p>用户空间的程序可以通过 TUN&#x2F;TAP 设备发送数据。常见于基于TUN&#x2F;TAP设备实现的VPN。比如VPN软件在用户空间创建一个TUN&#x2F;TAP设备，并将其配置为将网络流量导入到VPN隧道中。然后，VPN软件可以通过TUN&#x2F;TAP设备读取和写入数据，将它们加密并通过隧道发送到VPN服务器。在服务器端，VPN软件将收到的数据解密并通过TUN&#x2F;TAP设备发送到网络接口，从而实现了VPN连接。</p><h5 id="2-特点"><a href="#2-特点" class="headerlink" title="2.特点"></a>2.特点</h5><p>TUN：三层设备、IP数据包、实现三层的ip隧道<br>TAP：二层设备、MAC地址、通常接入到虚拟交换机(bridge)上作为局域网的一个节点</p><h5 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3.隧道"></a>3.隧道</h5><p>Linux 原生支持多种多种层隧道，大部分底层实现原理都是基于 tun 设备。我们可以通过命令 ip tunnel help 查看 IP 隧道的相关操作。</p><p>Linux 原生一共支持 5 种 IP 隧道（常见的隧道协议）。</p><p>ipip：即 IPv4 in IPv4，在 IPv4 报文的基础上再封装一个 IPv4 报文。<br>gre：即通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装其他任意一种网络层协议的机制，IPv4 和 IPv6 都适用。<br>sit：和 ipip 类似，不同的是 sit 是用 IPv4 报文封装 IPv6 报文，即 IPv6 over IPv4。<br>isatap：即站内自动隧道寻址协议（Intra-Site Automatic Tunnel Addressing Protocol），和 sit 类似，也是用于 IPv6 的隧道封装。<br>vti：即虚拟隧道接口（Virtual Tunnel Interface），是 cisco 提出的一种 IPsec 隧道技术。</p><h5 id="4-用途"><a href="#4-用途" class="headerlink" title="4.用途"></a>4.用途</h5><ol><li>VPN连接：可以将tun设备配置为VPN客户端或服务器，并通过该设备在不同网络之间建立安全的隧道连接，实现远程访问或局域网间互通。tun&#x2F;tap设备最常用的场景是VPN，比较有名的项目有<a href="https://vtun.sourceforge.net/">vTun</a>、<a href="https://openvpn.net/">openVPN</a>。</li><li>隧道连接：可以将tun设备配置为网络隧道的一部分，用于将数据从一个网络传输到另一个网络，通常用于连接不同物理网络的互联，如通过互联网连接不同地区的局域网。</li><li>虚拟化网络：可以使用tun设备实现虚拟化网络，通过创建多个tun设备和对应的网络命名空间，可以将不同容器或虚拟机之间隔离的网络连接起来。</li><li>流量监控和过滤：可以使用tun设备来捕获传入和传出的网络流量，并进行流量监控或过滤，例如实现防火墙功能等。</li></ol><p><a href="/images/Tun-tap-osilayers-diagram.png">tun-tap工作层图</a></p><h5 id="5-图解Tun与应用程序"><a href="#5-图解Tun与应用程序" class="headerlink" title="5.图解Tun与应用程序"></a>5.图解Tun与应用程序</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs txt">+----------------------------------------------------------------+<br>|                                                                |<br>|  +--------------------+      +--------------------+            |<br>|  | User Application A |      | User Application B |&lt;-----+     |<br>|  +--------------------+      +--------------------+      |     |<br>|               | 1                    | 5                 |     |<br>|...............|......................|...................|.....|<br>|               ↓                      ↓                   |     |<br>|         +----------+           +----------+              |     |<br>|         | socket A |           | socket B |              |     |<br>|         +----------+           +----------+              |     |<br>|                 | 2               | 6                    |     |<br>|.................|.................|......................|.....|<br>|                 ↓                 ↓                      |     |<br>|             +------------------------+                 4 |     |<br>|             | Newwork Protocol Stack |                   |     |<br>|             +------------------------+                   |     |<br>|                | 7                 | 3                   |     |<br>|................|...................|.....................|.....|<br>|                ↓                   ↓                     |     |<br>|        +----------------+    +----------------+          |     |<br>|        |      eth0      |    |      tun0      |          |     |<br>|        +----------------+    +----------------+          |     |<br>|    10.32.0.11  |                   |   192.168.3.11      |     |<br>|                | 8                 +---------------------+     |<br>|                |                                               |<br>+----------------|-----------------------------------------------+<br>                 ↓<br>         Physical Network<br></code></pre></td></tr></table></figure><blockquote><p>tun&#x2F;tap设备的用处是将协议栈中的部分数据包转发给用户空间的应用程序，给用户空间的程序一个处理数据包的机会(数据压缩，加密)</p></blockquote><h3 id="二、VPN"><a href="#二、VPN" class="headerlink" title="二、VPN"></a>二、VPN</h3><ol><li>创建Tun设备</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 虚拟机 1 作为服务端</span><br>sudo ip tuntap add dev tun-server mode tun<br>sudo ip addr add 172.16.1.1/24 dev tun-server<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tun-server up<br>gcc ./src/c/05-tun-tap/simpletun.c &amp;&amp; sudo ./a.out -d -i tun-server -s<br><br><br><span class="hljs-comment"># 虚拟机 2 作为客户端</span><br>sudo ip tuntap add dev tun-client mode tun<br>sudo ip addr add 172.16.1.2/24 dev tun-client<br>sudo ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tun-client up<br>gcc ./src/c/05-tun-tap/simpletun.c &amp;&amp; sudo ./a.out -d -i tun-client -c 192.168.57.3<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ip tuntap add dev tun2 mode tun</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip tuntap add dev tun2 mode tun<br><br><span class="hljs-comment"># set up tun2</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev tun2 up<br><br><span class="hljs-comment"># ip addr add &lt;IP地址&gt;/&lt;子网掩码&gt; dev tun2</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 172.16.0.8/24 dev tun2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ping &lt;B的隧道IP地址&gt;</span><br><span class="hljs-comment"># 验证container1和container2之间通讯</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 172.16.0.8<br></code></pre></td></tr></table></figure><blockquote><p>通过TUN的IP隧道，在物理网络上构建一条加密隧道。</p></blockquote><h3 id="四、程序监听TUN设备数据"><a href="#四、程序监听TUN设备数据" class="headerlink" title="四、程序监听TUN设备数据"></a>四、程序监听TUN设备数据</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br><br><span class="hljs-string">&quot;github.com/songgao/packets/ethernet&quot;</span><br><span class="hljs-string">&quot;github.com/songgao/water&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>config := water.Config&#123;<br>DeviceType: water.TUN,<br>&#125;<br>config.Name = <span class="hljs-string">&quot;tun-client&quot;</span><br><br>ifCe, err := water.New(config)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;new err=%s&quot;</span>, err)<br>&#125;<br><br>log.Printf(<span class="hljs-string">&quot;name=%s&quot;</span>, ifCe.Name())<br><span class="hljs-keyword">if</span> err := exec.Command(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-string">&quot;link&quot;</span>, <span class="hljs-string">&quot;set&quot;</span>, ifCe.Name(), <span class="hljs-string">&quot;up&quot;</span>).Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;up err=%s&quot;</span>, err)<br>&#125;<br><span class="hljs-keyword">if</span> err := exec.Command(<span class="hljs-string">&quot;ip&quot;</span>, <span class="hljs-string">&quot;addr&quot;</span>, <span class="hljs-string">&quot;add&quot;</span>, <span class="hljs-string">&quot;10.0.42.1&quot;</span>, <span class="hljs-string">&quot;dev&quot;</span>, ifCe.Name()).Run(); err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;addr add err=%s&quot;</span>, err)<br>&#125;<br><br><span class="hljs-keyword">var</span> frame ethernet.Frame<br><br><span class="hljs-keyword">for</span> &#123;<br>frame.Resize(<span class="hljs-number">1500</span>)<br>n, err := ifCe.Read([]<span class="hljs-type">byte</span>(frame))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;read catch=%s&quot;</span>, err)<br>&#125;<br>frame = frame[:n]<br>log.Printf(<span class="hljs-string">&quot;Dst: %s\n&quot;</span>, frame.Destination())<br>log.Printf(<span class="hljs-string">&quot;Src: %s\n&quot;</span>, frame.Source())<br>log.Printf(<span class="hljs-string">&quot;Ethertype: % x\n&quot;</span>, frame.Ethertype())<br>log.Printf(<span class="hljs-string">&quot;Payload: %s\n&quot;</span>, <span class="hljs-type">string</span>(frame.Payload()))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、tun设备数据转tap经vrouter三层转发"><a href="#五、tun设备数据转tap经vrouter三层转发" class="headerlink" title="五、tun设备数据转tap经vrouter三层转发"></a>五、tun设备数据转tap经vrouter三层转发</h3><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>客户端使用openvpn访问web服务流程</li></ul><p><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-tuntap-veth/">openvpn访问过程</a></p><ul><li>ipv4转发打开持久</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/sysctl.conf<br><br>net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure><ul><li>为什么监听container1的网卡veth2时候，container1 ping无输出而container2 ping有输出</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># veth2 的 ip 10.1.1.5</span><br><span class="hljs-comment"># listen veth2 </span><br>ip netns <span class="hljs-built_in">exec</span> container1 tcpdump -nei veth2<br><br><span class="hljs-comment"># 无数据包</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.1.1.5<br><br><span class="hljs-comment"># 有数据包</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ping 10.1.1.5<br><br><span class="hljs-comment"># lo接口本机ping又有</span><br>ip netns <span class="hljs-built_in">exec</span> container1 tcpdump -nei lo<br>ip netns <span class="hljs-built_in">exec</span> container1 ping 127.0.0.1<br></code></pre></td></tr></table></figure><p>tcpdump 只能捕获进入它所在网络命名空间的接口的数据包，而无法捕获离开它所在网络命名空间的接口的数据包。</p><ul><li>命名空间的tun设备如何使用<code>github.com/songgao/water</code>监听</li></ul><p>创建并配置TUN设备：在命名空间中运行以下命令来创建和配置TUN设备：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;namespace&gt;是命名空间的名称</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;devicename&gt;是TUN设备的名称</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;ipaddress&gt;和&lt;netmask&gt;是TUN设备的IP地址和子网掩码</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;gateway&gt;是TUN设备的默认网关IP地址</span><br>ip netns exec &lt;namespace&gt; ip tuntap add &lt;devicename&gt; mode tun<br>ip netns exec &lt;namespace&gt; ip addr add &lt;ipaddress&gt;/&lt;netmask&gt; dev &lt;devicename&gt;<br>ip netns exec &lt;namespace&gt; ip link set &lt;devicename&gt; up<br>ip netns exec &lt;namespace&gt; ip route add default via &lt;gateway&gt;<br></code></pre></td></tr></table></figure><p>编写的golang程序在默认命名空间中运行的应用程序。如果要在命名空间中运行该应用程序，请使用<code>ip netns exec &lt;namespace&gt;</code>来执行golang程序.</p><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1680749">Tun&#x2F;Tap接口使用指导</a></li><li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-tuntap-veth/">云计算底层技术-虚拟网络设备(tun&#x2F;tap,veth)</a></li><li><a href="https://www.baeldung.com/linux/tun-interface-purpose">TUN接口有什么用？</a></li><li><a href="https://blog.csdn.net/weixin_39094034/article/details/103810351">Linux虚拟网络基础——tun</a></li><li><a href="https://backreference.org/2010/03/26/tuntap-interface-tutorial/index.html">Tun&#x2F;Tap 接口教程</a></li><li><a href="https://nsl.cz/using-tun-tap-in-go-or-how-to-write-vpn/">在go中使用TUN&#x2F;TAP或如何编写VPN</a></li><li><a href="https://github.com/kanocz/lcvpn">https://github.com/kanocz/lcvpn</a></li><li><a href="https://www.rectcircle.cn/posts/linux-net-virual-05-tunnel/">Linux 网络虚拟化技术（五）隧道技术</a></li><li><a href="https://segmentfault.com/a/1190000009249039">Linux虚拟网络设备之tun&#x2F;tap</a></li><li><a href="https://github.com/go-gost/gost">https://github.com/go-gost/gost</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ipip隧道通讯</title>
    <link href="/2023/08/25/network/ipip%E9%9A%A7%E9%81%93%E9%80%9A%E8%AE%AF/"/>
    <url>/2023/08/25/network/ipip%E9%9A%A7%E9%81%93%E9%80%9A%E8%AE%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol><li>IP 隧道</li></ol><p>Linux 原生支持多种三层隧道，其底层实现原理都是基于 tun 设备。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看tunnel操作指引</span><br>ip tunnel <span class="hljs-built_in">help</span><br>[ mode &#123; ipip | gre | sit | isatap | vti &#125; ] [ remote ADDR ] [ <span class="hljs-built_in">local</span> ADDR ]<br></code></pre></td></tr></table></figure><ol start="2"><li>Linux 原生一共支持 5 种 IP 隧道。</li></ol><ul><li>ipip：即 IPv4 in IPv4，在 IPv4 报文的基础上再封装一个 IPv4 报文。</li><li>gre：即通用路由封装（Generic Routing Encapsulation），定义了在任意一种网络层协议上封装其他任意一种网络层协议的机制，IPv4 和 IPv6 都适用。</li><li>sit：和 ipip 类似，不同的是 sit 是用 IPv4 报文封装 IPv6 报文，即 IPv6 over IPv4。</li><li>isatap：即站内自动隧道寻址协议（Intra-Site Automatic Tunnel Addressing Protocol），和 sit 类似，也是用于 IPv6 的隧道封装。</li><li>vti：即虚拟隧道接口（Virtual Tunnel Interface），是 cisco 提出的一种 IPsec 隧道技术。</li></ul><h3 id="二、初始化环境"><a href="#二、初始化环境" class="headerlink" title="二、初始化环境"></a>二、初始化环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bridge-utils<br>ip netns add container1<br>ip netns add container2<br>ip netns list<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> add veth3 <span class="hljs-built_in">type</span> veth peer name veth4<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 netns container1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 netns container2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 10.1.1.5/24 dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add default via 10.1.1.1<br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 10.1.1.7/24 dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 up<br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add default via 10.1.1.1<br>brctl addbr br-link<br>brctl addif br-link veth1<br>brctl addif br-link veth3<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth3 up<br>ip addr add 10.1.1.1/24 dev br-link<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br-link up<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证环境已经配置好</span><br><span class="hljs-comment"># 检查ipv4转发</span><br>sysctl net.ipv4.ip_forward<br><br><span class="hljs-comment"># 打开ipv4转发</span><br>sysctl -w net.ipv4.ip_forward=1<br><br><span class="hljs-comment"># 测试容器之间网络互通</span><br><span class="hljs-comment"># ip netns exec container1 ping &lt;宿主机eth0&gt;</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.0.8.4<br><br><span class="hljs-comment"># ip netns exec container1 ping &lt;同交换机switch\bridge网段容器ip&gt;</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.1.1.7<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加载内核模块</span><br>modprobe ipip<br>lsmod | grep ipip<br></code></pre></td></tr></table></figure><h3 id="三、配置TUN的IP隧道"><a href="#三、配置TUN的IP隧道" class="headerlink" title="三、配置TUN的IP隧道"></a>三、配置TUN的IP隧道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns <span class="hljs-built_in">exec</span> container1 ip tunnel add tun1 mode ipip remote 10.1.1.7 <span class="hljs-built_in">local</span> 10.1.1.5<br><br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev tun1 up<br><br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 172.16.0.6 peer 172.16.0.8 dev tun1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">ip netns <span class="hljs-built_in">exec</span> container2 ip tunnel add tun2 mode ipip remote 10.1.1.5 <span class="hljs-built_in">local</span> 10.1.1.7<br><br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev tun2 up<br><br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 172.16.0.8 peer 172.16.0.6 dev tun2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 测试</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 172.16.0.8 -c 3<br></code></pre></td></tr></table></figure><blockquote><p>通过TUN的IP隧道，在物理网络上构建一条加密隧道。</p></blockquote><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>ip route 操作</li><li><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看ip route</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip route<br><span class="hljs-comment"># 清除ip route</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip route <span class="hljs-built_in">help</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip route del &lt;router&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1432489">什么是 IP 隧道，Linux 怎么实现隧道通信？</a></li><li><a href="https://morven.life/posts/networking-3-ipip/">揭秘 IPIP 隧道</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NAT配置公网访问</title>
    <link href="/2023/08/20/network/NAT%E9%85%8D%E7%BD%AE%E5%85%AC%E7%BD%91%E8%AE%BF%E9%97%AE/"/>
    <url>/2023/08/20/network/NAT%E9%85%8D%E7%BD%AE%E5%85%AC%E7%BD%91%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><h5 id="1-NAT"><a href="#1-NAT" class="headerlink" title="1.NAT"></a>1.NAT</h5><p>NAT（网络地址转换）是一种网络技术，一般用于局域网和公网之间IP地址转换，常用iptables实现。</p><h5 id="2-DNAT"><a href="#2-DNAT" class="headerlink" title="2.DNAT"></a>2.DNAT</h5><p>DNAT（目标网络地址转换）是NAT的一种形式，它将目标IP地址和端口转换为不同的IP地址和端口，通常用于将外部请求转发到内部网络中的特定服务器上。一般通过公网IP进来公网网卡的数据包更改目的ip或端口访问到内部服务。</p><h5 id="3-SNAT"><a href="#3-SNAT" class="headerlink" title="3.SNAT"></a>3.SNAT</h5><p>SNAT（源网络地址转换）是NAT的另一种形式，它将发送方的IP地址和端口转换为不同的IP地址和端口。主要用于局域网内的多台设备通过同一个公共IP地址访问互联网时，可以使用SNAT将内部设备的源IP地址转换成公共IP地址。这样可以避免互联网上的服务器将响应发送回源IP地址时的冲突。</p><h3 id="二、配置DNAT规则让外部访问内部网络"><a href="#二、配置DNAT规则让外部访问内部网络" class="headerlink" title="二、配置DNAT规则让外部访问内部网络"></a>二、配置DNAT规则让外部访问内部网络</h3><ol><li>购买腾讯云服务器A上安装一个docker，运行一个Nginx服务，配置DNAT可以使用公网IP访问Nginx服务.</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install -y docker<br>$ systemctl start docker<br>$ docker run -itd --name nginx-test nginx<br></code></pre></td></tr></table></figure><ol start="2"><li>配置NAT使用公网IP与自定义端口可访问Nginx服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables查看NAT规则</span><br>$ iptables -t nat -L<br><br><span class="hljs-comment"># docker容器ip地址</span><br>$ docker inspect nginx-test | grep IPAddress<br><br><span class="hljs-comment"># 配置公网IP与8080端口请求转发到本机80端口</span><br><span class="hljs-comment"># 10.0.8.4 &lt;公网数据入口网卡IP&gt; 8989 &lt;公网端口号&gt; to-destination &lt;容器IP地址&gt;:&lt;容器端口&gt;</span><br>$ iptables -t nat -A PREROUTING -d 10.0.8.4 -p tcp --dport 8989 -j DNAT --to-destination 172.17.0.2:80<br><br><span class="hljs-comment"># 配置完成后可以通过腾讯云&lt;公网IP&gt;:8989访问到docker服务</span><br><span class="hljs-comment"># 如何删除iptables规则</span><br>$ iptables -t nat -D PREROUTING 1<br></code></pre></td></tr></table></figure><h3 id="三、配置SNAT从容器内部访问外网"><a href="#三、配置SNAT从容器内部访问外网" class="headerlink" title="三、配置SNAT从容器内部访问外网"></a>三、配置SNAT从容器内部访问外网</h3><ol><li>查看docker的SNAT的效果如何让容器可以访问外网的</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 工具容器</span><br>$ docker run -itd --name box-test busybox<br><br><span class="hljs-comment"># 配置docker容器访问</span><br>$ docker <span class="hljs-built_in">exec</span> -it box-test /bin/sh<br><br><span class="hljs-comment"># 容器内ping baidu.com</span><br><span class="hljs-comment"># 再次查看POSTROUTING规则发现匹配次数增多</span><br>$ iptables -t nat -nvL<br></code></pre></td></tr></table></figure><ol start="2"><li>手动分配网络和SNAT</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bridge-utils<br>ip netns add container1<br>ip netns add container2<br>ip netns list<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> add veth3 <span class="hljs-built_in">type</span> veth peer name veth4<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 netns container1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 netns container2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 10.1.1.5/24 dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add default via 10.1.1.1<br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 10.1.1.7/24 dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 up<br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add default via 10.1.1.1<br>brctl addbr br-link<br>brctl addif br-link veth1<br>brctl addif br-link veth3<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth3 up<br>ip addr add 10.1.1.1/24 dev br-link<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br-link up<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查ipv4转发</span><br>sysctl net.ipv4.ip_forward<br><br><span class="hljs-comment"># 打开ipv4转发</span><br>sysctl -w net.ipv4.ip_forward=1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此时没有配置SNAT是无法通讯的</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping baidu.com<br><br><span class="hljs-comment"># 测试容器之间网络互通</span><br><span class="hljs-comment"># ip netns exec container1 ping &lt;宿主机eth0&gt;</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.0.8.4<br><br><span class="hljs-comment"># ip netns exec container1 ping &lt;同交换机switch\bridge网段容器ip&gt;</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.1.1.7<br><br><span class="hljs-comment"># iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -o &lt;宿主机外网接口&gt; -j MASQUERADE</span><br>iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -o eth0 -j MASQUERADE<br><br><span class="hljs-comment"># 或者(xx是服务器 IP)</span><br>iptables -t nat -A POSTROUTING -s 10.1.1.0/24 -o eth0 -j SNAT --to-source x.x.x.x<br><br><span class="hljs-comment"># 删除NAT规则</span><br>iptables -t nat -D POSTROUTING 1<br>iptables -t nat -nvL<br><br><span class="hljs-comment"># ping baidu.com</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping baidu.com<br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><h5 id="1-iptables常用命令"><a href="#1-iptables常用命令" class="headerlink" title="1.iptables常用命令"></a>1.iptables常用命令</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># iptables查看NAT规则</span><br>$ iptables -t nat -L<br><br><span class="hljs-comment"># 查看iptables规则和其匹配次数</span><br>$ iptables -t nat -nvL<br></code></pre></td></tr></table></figure><h5 id="2-iptables的PREROUTING-POSTROUTING-OUTPUT-INPUT分别干嘛的"><a href="#2-iptables的PREROUTING-POSTROUTING-OUTPUT-INPUT分别干嘛的" class="headerlink" title="2.iptables的PREROUTING\POSTROUTING\OUTPUT\INPUT分别干嘛的"></a>2.iptables的PREROUTING\POSTROUTING\OUTPUT\INPUT分别干嘛的</h5><p>iptables是一个用于Linux系统的防火墙工具，用于配置和管理网络数据包过滤规则。其中的PREROUTING、POSTROUTING和OUTPUT是iptables的三个不同的表，用于不同的数据包处理阶段。</p><ul><li><p>PREROUTING表: 进入路由系统的数据包。数据包路由之前进行处理，常用目标地址的修改、端口重定向等。</p></li><li><p>POSTROUTING表: 离开路由系统的数据包。数据包路由之后进行处理，常用源地址的修改等。常见的使用场景SNAT等。</p></li><li><p>OUTPUT表: 本地产生的数据包。它在数据包从本地应用程序发送出去之前进行处理，可以对数据包进行一些操作，例如目标地址的修改、端口重定向等。常见的使用场景包括阻止&#x2F;允许本地应用程序访问特定的目标地址&#x2F;端口等。</p></li><li><p>INPUT表: 是 iptables 规则中的一个 chain（链），它用于控制数据包进入系统的行为。当一个数据包进入系统时，它首先会经过 INPUT chain 中的规则进行过滤和处理。</p></li></ul><p>综上所述，PREROUTING表用于处理进入路由系统的数据包，POSTROUTING表用于处理离开路由系统的数据包，OUTPUT表用于处理本地产生的数据包。</p><h5 id="3-什么是静态NAT和动态NAT"><a href="#3-什么是静态NAT和动态NAT" class="headerlink" title="3.什么是静态NAT和动态NAT"></a>3.什么是静态NAT和动态NAT</h5><p>一个私有IP固定映射一个公有IP地址，提供内网服务器的对外访问服务是静态。动态NAT是私有IP映射地址池中的公有IP，映射关系是动态的，临时的。</p><h5 id="4-如何删除iptables-NAT规则"><a href="#4-如何删除iptables-NAT规则" class="headerlink" title="4.如何删除iptables NAT规则"></a>4.如何删除iptables NAT规则</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">数字1是链的index索引</span><br>iptables -t nat -D PREROUTING 1<br><br>iptables -t nat -D OUTPUT 1<br></code></pre></td></tr></table></figure><h5 id="5-本机器curl本机器网卡会经过iptables吗"><a href="#5-本机器curl本机器网卡会经过iptables吗" class="headerlink" title="5.本机器curl本机器网卡会经过iptables吗"></a>5.本机器curl本机器网卡会经过iptables吗</h5><p>在本机上使用curl命令访问IP地址为本机网卡IP<code>10.0.8.4</code>的服务端口8989，那么这个请求不会经过iptables防火墙。iptables是Linux操作系统中的一个防火墙管理工具，在本机上进行网络请求，请求的目标IP地址是本机的网卡IP地址，那么这个请求是走本机的网络协议栈直接发送和接收的，不会经过iptables的过滤。iptables主要针对通过本机的网络数据流量进行过滤和管理。</p><h5 id="6-output-input表常用规则"><a href="#6-output-input表常用规则" class="headerlink" title="6.output\input表常用规则"></a>6.output\input表常用规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 允许所有出站数据包</span><br>iptables -A OUTPUT -j ACCEPT<br><br><span class="hljs-comment"># 允许源IP地址为192.168.1.100的出站数据包</span><br>iptables -A OUTPUT -s 192.168.1.100 -j ACCEPT<br><br><span class="hljs-comment"># 拒绝目标端口为80的出站数据包</span><br>iptables -A OUTPUT -p tcp --dport 80 -j REJECT<br><br><span class="hljs-comment"># 重定向目标端口为8080的出站数据包到本地的1234端口</span><br><span class="hljs-comment"># 所有从系统中发出的目标端口为 8080 的 TCP 连接重定向到端口号为 1234 的端口</span><br>iptables -A OUTPUT -p tcp --dport 8080 -j REDIRECT --to-ports 1234<br><br><span class="hljs-comment"># 允许所有来源地址的 SSH 连接进入系统</span><br>iptables -A INPUT -p tcp --dport 22 -j ACCEPT<br></code></pre></td></tr></table></figure><h5 id="7-output和postrouting之间的区别是什么"><a href="#7-output和postrouting之间的区别是什么" class="headerlink" title="7.output和postrouting之间的区别是什么"></a>7.output和postrouting之间的区别是什么</h5><ol><li>output链：</li></ol><ul><li>位置：output链是在数据包被<code>本地计算机发出之前</code>执行的。</li><li>功能：output链用于处理从本地计算机发出的数据包，常用于对本地出站流量进行过滤和控制。</li><li>示例：限制本地计算机上的某个应用程序只能访问特定的目的地地址和端口(linux用户访问端口\SSH访问限制等)。</li></ul><ol start="2"><li>postrouting链：</li></ol><ul><li>位置：postrouting链是在数据包<code>离开本地计算机之前</code>执行的。</li><li>功能：postrouting链用于对数据包进行NAT操作，主要是对数据包的源地址或目标地址进行转换。</li><li>示例：配置网络地址转换以实现多台内部主机共享一个公共IP地址(SNAT)。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 限制username用户只能访问80端口的HTTP服务，其他端口将被丢弃</span><br>iptables -A OUTPUT -p tcp --dport 80 -m owner --uid-owner username -j DROP<br><br><span class="hljs-comment"># 将内部网络192.168.0.0/24的源地址转换为本地计算机上eth0接口的IP地址</span><br>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE<br></code></pre></td></tr></table></figure><h5 id="8-MASQUERADE是什么意思"><a href="#8-MASQUERADE是什么意思" class="headerlink" title="8.MASQUERADE是什么意思"></a>8.MASQUERADE是什么意思</h5><p>MASQUERADE是一种网络地址转换（NAT）技术，在iptables中表示对源IP地址进行伪装的操作。当数据包从内部网络转发到外部网络时，使用MASQUERADE可以将源IP地址替换为出口接口的IP地址，常使用MASQUERADE来处理出站流量。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当数据包源IP是192.168.0.0/24网段内的IP，并且从eth0接口发送出去时，将源IP地址进行伪装（使用eth0接口的IP地址）</span><br><span class="hljs-comment"># 从内部网络发出的数据包都会经过MASQUERADE操作，并将源IP地址替换为eth0接口的IP地址，从而隐藏了内部网络的真实IP地址</span><br><span class="hljs-comment"># 就是对ip段192.168.0.0/24进行SNAT</span><br>iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE<br></code></pre></td></tr></table></figure><h5 id="9-读懂iptables的意思"><a href="#9-读懂iptables的意思" class="headerlink" title="9.读懂iptables的意思"></a>9.读懂iptables的意思</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建docker之后有这样一条规则，当docker内容器访问外网的时候匹配次数pkts会增大</span><br><span class="hljs-comment"># 用于将来自docker0接口以外的172.17.0.0/16子网的流量进行MASQUERADE伪装处理（SNAT操作）</span><br><span class="hljs-comment"># 允许从docker0接口以外发出的流量通过iptables进行NAT</span><br>Chain POSTROUTING (policy ACCEPT 339 packets, 21398 bytes)<br> pkts bytes target     prot opt <span class="hljs-keyword">in</span>     out     <span class="hljs-built_in">source</span>               destination         <br>    6   417 MASQUERADE  all  --  *      !docker0  172.17.0.0/16        0.0.0.0/0<br></code></pre></td></tr></table></figure><h5 id="10-docker如何让容器可访问外部网络的"><a href="#10-docker如何让容器可访问外部网络的" class="headerlink" title="10.docker如何让容器可访问外部网络的"></a>10.docker如何让容器可访问外部网络的</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># SNAT</span><br>iptables -t nat -A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE<br></code></pre></td></tr></table></figure><h5 id="11-tcpdump如何指定目标和源"><a href="#11-tcpdump如何指定目标和源" class="headerlink" title="11.tcpdump如何指定目标和源"></a>11.tcpdump如何指定目标和源</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">tcpdump -nei br-link src &lt;<span class="hljs-built_in">source</span> ip&gt;<br>tcpdump -nei br-link dst &lt;destination ip&gt;<br>tcpdump -nei eth0 src &lt;src ip&gt; and dst &lt;dst ip&gt;<br>tcpdump -nei eth0 port &lt;port&gt;<br></code></pre></td></tr></table></figure><h5 id="12-net-ipv4-ip-forward和iptables的snat有什么关系"><a href="#12-net-ipv4-ip-forward和iptables的snat有什么关系" class="headerlink" title="12.net.ipv4.ip_forward和iptables的snat有什么关系"></a>12.net.ipv4.ip_forward和iptables的snat有什么关系</h5><p><code>net.ipv4.ip_forward</code>和<code>iptables</code>的SNAT（Source Network Address Translation）功能是网络中的两个不同的概念，但它们在实现网络转发和网络地址转换方面存在一定的关系。</p><ol><li><p><code>net.ipv4.ip_forward</code>：此参数用于控制Linux系统是否启用IPv4转发功能。通过将其值设置为1，可以启用IPv4转发，从而允许Linux系统作为路由器来转发数据包。当数据包到达Linux系统时，但不是目标主机的地址时，如果IPv4转发已打开，系统将尝试将数据包转发到正确的目标地址。</p></li><li><p><code>iptables</code>的SNAT：SNAT是一种网络地址转换技术，用于修改数据包的源IP地址。在Linux系统中，可以使用<code>iptables</code>命令来配置SNAT规则。通过配置适当的SNAT规则，您可以将源IP地址从内部网络转换成外部网络的IP地址，从而实现内部网络与外部网络之间的通信。</p></li></ol><p>关系：</p><ul><li>当启用了<code>net.ipv4.ip_forward</code>参数，Linux系统将充当路由器，并根据路由表将数据包转发到正确的目标地址。</li><li>当数据包在转发过程中经过Linux系统时，<code>iptables</code>的SNAT规则可以用于修改数据包的源IP地址，以便正确进行地址转换，从而实现数据包在不同网络之间的传递。</li></ul><p>总结来说，<code>net.ipv4.ip_forward</code>参数用于启用Linux系统的IPv4转发功能，而<code>iptables</code>的SNAT功能则涉及修改数据包的源IP地址，以便进行网络地址转换。这两者一起使用可以实现跨网络的数据包转发和地址转换。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何构建vxlan网络</title>
    <link href="/2023/08/20/network/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAvxlan%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/08/20/network/%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BAvxlan%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol><li>什么是VXLAN</li></ol><p>一种网络虚拟化技术。</p><ol start="2"><li>GRE隧道是什么</li></ol><p>一种隧道协议，将原始的数据包封装在一个新的IP头中实现跨越多个网络端口传输。</p><ol start="3"><li>两者之间的关系是什么</li></ol><p>在VXLAN网络中，通过使用GRE隧道技术可以实现虚拟网络之间的隔离。</p><ol start="4"><li>原理</li></ol><p>GRE协议将原始的数据包封装在一个新的IP头中，使得数据包能够跨越多个网络端口传输，借助IP协议中的IP数据报文来传输数据。要实现VXLAN网络隔离，需要使用Linux中的网络命名空间来创建多个隔离的虚拟网络环境，并将VXLAN设备连接到相应的命名空间。</p><h3 id="二、使用vxlan建立点对点通信"><a href="#二、使用vxlan建立点对点通信" class="headerlink" title="二、使用vxlan建立点对点通信"></a>二、使用vxlan建立点对点通信</h3><p><img src="/images/dianduidian.jpeg" alt="点对点隧道通讯拓扑图"></p><ol><li>创建两个命名空间通过bridge和veth pair对让其网络可以互相通讯</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bridge-utils<br>ip netns add container1<br>ip netns add container2<br>ip netns list<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> add veth3 <span class="hljs-built_in">type</span> veth peer name veth4<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 netns container1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 netns container2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 10.1.1.5/24 dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add default via 10.1.1.1<br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 10.1.1.7/24 dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 up<br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add default via 10.1.1.1<br>brctl addbr br-link<br>brctl addif br-link veth1<br>brctl addif br-link veth3<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth3 up<br>ip addr add 10.1.1.1/24 dev br-link<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br-link up<br></code></pre></td></tr></table></figure><ol start="2"><li>两个容器网络分配vxlan设备</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># container1</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> add vxlan0 <span class="hljs-built_in">type</span> vxlan \<br>    <span class="hljs-built_in">id</span> 42 \<br>    dstport 4789 \<br>    remote 10.1.1.7 \<br>    <span class="hljs-built_in">local</span> 10.1.1.5 \<br>    dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip -d <span class="hljs-built_in">link</span> <br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 172.1.1.2/24 dev vxlan0<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vxlan0 up<br><br><span class="hljs-comment"># container2</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> add vxlan0 <span class="hljs-built_in">type</span> vxlan \<br>    <span class="hljs-built_in">id</span> 42 \<br>    dstport 4789 \<br>    remote 10.1.1.5 \<br>    <span class="hljs-built_in">local</span> 10.1.1.7 \<br>    dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip -d <span class="hljs-built_in">link</span> <br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 172.1.1.3/24 dev vxlan0<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vxlan0 up<br><br><span class="hljs-comment"># ping test</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 172.1.1.3<br></code></pre></td></tr></table></figure><h3 id="多播vxlan"><a href="#多播vxlan" class="headerlink" title="多播vxlan"></a>多播vxlan</h3><p><img src="/images/duobovxlan.jpeg" alt="多播网络拓扑"></p><ol><li>宿主机上创建两个容器网络</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bridge-utils<br>ip netns add container1<br>ip netns add container2<br>ip netns list<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> add veth3 <span class="hljs-built_in">type</span> veth peer name veth4<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 netns container1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 netns container2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 10.1.1.5/24 dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add default via 10.1.1.1<br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 10.1.1.7/24 dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 up<br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add default via 10.1.1.1<br>brctl addbr br-link<br>brctl addif br-link veth1<br>brctl addif br-link veth3<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth3 up<br>ip addr add 10.1.1.1/24 dev br-link<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br-link up<br></code></pre></td></tr></table></figure><ol start="2"><li>创建多播组实现多个同组vxlan互相通讯</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># contianer1</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> add vxlan0 <span class="hljs-built_in">type</span> vxlan \<br>    <span class="hljs-built_in">id</span> 42 \<br>    dstport 4789 \<br>    group 239.1.1.1 \<br>    dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip -d <span class="hljs-built_in">link</span> <br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 172.1.1.2/24 dev vxlan0<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vxlan0 up<br><br><span class="hljs-comment"># container2</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> add vxlan0 <span class="hljs-built_in">type</span> vxlan \<br>    <span class="hljs-built_in">id</span> 42 \<br>    dstport 4789 \<br>    group 239.1.1.1 \<br>    dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip -d <span class="hljs-built_in">link</span> <br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 172.1.1.3/24 dev vxlan0<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> vxlan0 up<br><br><span class="hljs-comment"># test</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 172.1.1.3<br></code></pre></td></tr></table></figure><ol start="3"><li>备注</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如何删除vxlan设备</span><br>ip netns <span class="hljs-built_in">exec</span> [namespace] ip <span class="hljs-built_in">link</span> delete [vxlan name]<br><br><span class="hljs-comment"># 如何查看ip路由</span><br>ip netns <span class="hljs-built_in">exec</span> [namespace] ip route<br><br><span class="hljs-comment"># 查看fdb表</span><br>ip netns <span class="hljs-built_in">exec</span> [namespace] bridge fdb<br></code></pre></td></tr></table></figure><h4 id="三、生产环境下常用的多bridge多vxlan多播网络"><a href="#三、生产环境下常用的多bridge多vxlan多播网络" class="headerlink" title="三、生产环境下常用的多bridge多vxlan多播网络"></a>三、生产环境下常用的多bridge多vxlan多播网络</h4><p>其实就是上面的，在一个宿主机上可以建设多个bridge，每个bridge上面负责一个vxlan的网络。</p><p><img src="/images/duovxlanwangluo.jpeg" alt="多VXLAN下面的网络拓扑"></p><ol><li>上面添加type vxlan的时候填写的remote最终会配置到 FDB 表之中,这表的VTEP 的地址可以决定arp查找mac地址的数据走向</li><li>可以手动维护 fdb 表 <code>bridge fdb append 52:5e:55:58:9a:ab dev vxlan0 dst 192.168.8.101</code></li><li>手动维护 ARP 表 <code>ip neigh add 10.20.1.3 lladdr d6:d9:cd:0a:a4:28 dev vxlan0</code></li></ol><blockquote><p>主机会根据 VNI 来区别不同的 vxlan 网络，不同的 vxlan 网络之间不会相互影响。如果再加上 network namespace，就能实现更复杂的网络结构。</p></blockquote><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul><li><a href="https://cizixs.com/2017/09/28/linux-vxlan/">https://cizixs.com/2017/09/28/linux-vxlan/</a></li><li><a href="https://www.wxkcg.com/gre/greb74bf1660464437abf112f3752358332">如何利用GRE隧道建立VXLAN</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes的ingress-nginx配置会话粘性</title>
    <link href="/2023/08/19/cni/kubernetes%E7%9A%84ingress-nginx%E9%85%8D%E7%BD%AE%E4%BC%9A%E8%AF%9D%E7%B2%98%E6%80%A7/"/>
    <url>/2023/08/19/cni/kubernetes%E7%9A%84ingress-nginx%E9%85%8D%E7%BD%AE%E4%BC%9A%E8%AF%9D%E7%B2%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ol><li>安装ingress-nginx</li></ol>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置Nginx负载均衡和保持会话粘性</title>
    <link href="/2023/08/19/cni/%E9%85%8D%E7%BD%AENginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E4%BF%9D%E6%8C%81%E4%BC%9A%E8%AF%9D%E7%B2%98%E6%80%A7/"/>
    <url>/2023/08/19/cni/%E9%85%8D%E7%BD%AENginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%92%8C%E4%BF%9D%E6%8C%81%E4%BC%9A%E8%AF%9D%E7%B2%98%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、如何配置负载均衡同一个域名均衡给多个服务"><a href="#一、如何配置负载均衡同一个域名均衡给多个服务" class="headerlink" title="一、如何配置负载均衡同一个域名均衡给多个服务"></a>一、如何配置负载均衡同一个域名均衡给多个服务</h3><h5 id="1-开启多个服务端"><a href="#1-开启多个服务端" class="headerlink" title="1.开启多个服务端"></a>1.开启多个服务端</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network create nginx-test<br><br>$ docker run --network nginx-test -itd \<br>  --network-alias one \<br>  435861851/gin:v0.0.1<br><br>$ docker run --network nginx-test -itd \<br>  --network-alias two \<br>  hashicorp/http-echo -text=<span class="hljs-string">&quot;hello world&quot;</span><br></code></pre></td></tr></table></figure><h5 id="2-启动Nginx"><a href="#2-启动Nginx" class="headerlink" title="2.启动Nginx"></a>2.启动Nginx</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --name nginx \<br>  --network nginx-test -itd \<br>  -p 80:80 \<br>  -v ./nginx.conf:/etc/nginx/conf.d/proxy.conf \<br>  nginx:1.25.1<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs nginx.conf">###定义上游服务器(需要被nginx真实代理访问的服务器) 默认是轮训机制<br>upstream backServer&#123;<br>    server one:8080;<br>    server two:5678;<br>&#125;<br><br>server &#123;<br>    listen       80;<br>    server_name  testnginx.com;<br>    location / &#123;<br>        ### 指定上游服务器负载均衡服务器<br>        proxy_pass http://backServer;<br>        index  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-访问服务会输出不同的结果"><a href="#3-访问服务会输出不同的结果" class="headerlink" title="3.访问服务会输出不同的结果"></a>3.访问服务会输出不同的结果</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意需要先配置/etc/hosts</span><br>127.0.0.1 testnginx.com<br><br>$ curl testnginx.com<br>&#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;Hello Gin!&quot;</span>&#125;<br>                                                                          $ curl testnginx.com<br>hello world<br></code></pre></td></tr></table></figure><h3 id="二、负载均衡算法"><a href="#二、负载均衡算法" class="headerlink" title="二、负载均衡算法"></a>二、负载均衡算法</h3><blockquote><p>默认轮询</p></blockquote><h5 id="1-weight设置权重"><a href="#1-weight设置权重" class="headerlink" title="1.weight设置权重"></a>1.weight设置权重</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">upstream backServer&#123;<br>    server one:8080 weight=1;<br>    server two:5678 weight=2;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-ip-hash"><a href="#2-ip-hash" class="headerlink" title="2.ip_hash"></a>2.ip_hash</h5><blockquote><p>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。俗称IP绑定。可以用于实现会话粘性。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">upstream backServer&#123;<br>    server one:8080;<br>    server two:5678;<br>    ip_hash;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置了以后下面访问会一直访问到同一个服务</span><br>curl testnginx.com<br><br><span class="hljs-comment"># 配置使用不同的http client host访问服务验证粘性</span><br><span class="hljs-comment"># 暂时没验证成功，每次都转发到one服务...</span><br>curl --header <span class="hljs-string">&quot;X-Forwarded-For:192.168.1.1&quot;</span> testnginx.com<br>curl --header <span class="hljs-string">&quot;X-Forwarded-For:192.168.1.2&quot;</span> testnginx.com<br>curl --header <span class="hljs-string">&quot;X-Forwarded-For:192.168.1.5&quot;</span> testnginx.com<br></code></pre></td></tr></table></figure><blockquote><p>如果会话粘性保持在one，当one服务宕机会转发到其他，但是当one服务重启会重新转发回one服务。</p></blockquote><h5 id="3-其他算法"><a href="#3-其他算法" class="headerlink" title="3.其他算法"></a>3.其他算法</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">fair（第三方）。比weight、ip_hash更加智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身不支持fair，如果需要这种调度算法，则必须安装upstream_fair模块。<br><br>url_hash（第三方）。按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的<span class="hljs-built_in">hash</span>软件包<br></code></pre></td></tr></table></figure><h3 id="三、故障转移"><a href="#三、故障转移" class="headerlink" title="三、故障转移"></a>三、故障转移</h3><blockquote><p>当上游服务器（真实访问服务器）出现故障或者是没有及时相应的话，直接轮训到下一台服务器。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">upstream backServer&#123;<br>    server one:8080;<br>    server two:5678;<br>&#125;<br><br>server &#123;<br>    listen       80;<br>    server_name  testnginx.com;<br>    location / &#123;<br>        <span class="hljs-comment">### 指定上游服务器负载均衡服务器</span><br>        proxy_pass http://backServer;<br><br>        <span class="hljs-comment">###nginx与上游服务器(真实访问的服务器)超时时间</span><br>        <span class="hljs-comment">###后端服务器连接的超时时间_发起握手等候响应超时时间</span><br>        proxy_connect_timeout 1s;<br>        <br>        <span class="hljs-comment">###nginx发送给上游服务器(真实访问的服务器)超时时间</span><br>        proxy_send_timeout 1s;<br>        <br>        <span class="hljs-comment">### nginx接受上游服务器(真实访问的服务器)超时时间</span><br>        proxy_read_timeout 1s;<br>        index  index.html index.htm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">启动服务后将服务one关闭，继续访问服务 curl testnginx.com，即使没有配置故障转移也会在一段时间后转发到正常的服务下。<br><br>配置了可以更快速的切换访问到其他节点服务。<br></code></pre></td></tr></table></figure><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://blog.csdn.net/qq_20042935/article/details/103052606">Nginx Upstream Server 负载均衡</a><br><a href="https://cloud.tencent.com/developer/article/2333364">如何保持会话粘性，看看Nginx怎么做的</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用GRE隧道通信</title>
    <link href="/2023/07/06/network/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GRE%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/07/06/network/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8GRE%E9%9A%A7%E9%81%93%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><ol><li>什么是VXLAN</li></ol><p>一种网络虚拟化技术</p><ol start="2"><li>GRE隧道是什么</li></ol><p>一种隧道协议。（将原始的数据包封装在一个新的IP头中实现跨越多个网络端口传输）</p><ol start="3"><li>两者之间的关系是什么</li></ol><p>在VXLAN网络中，通过使用GRE隧道技术可以实现虚拟网络之间的隔离。</p><ol start="4"><li>原理</li></ol><p>GRE协议将原始的数据包封装在一个新的IP头中，使得数据包能够跨越多个网络端口传输。（借助IP协议中的IP数据报文来传输数据）</p><h3 id="二、初始化环境"><a href="#二、初始化环境" class="headerlink" title="二、初始化环境"></a>二、初始化环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum install -y bridge-utils<br>ip netns add container1<br>ip netns add container2<br>ip netns list<br>ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>ip <span class="hljs-built_in">link</span> add veth3 <span class="hljs-built_in">type</span> veth peer name veth4<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 netns container1<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 netns container2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 10.1.1.5/24 dev veth2<br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>ip netns <span class="hljs-built_in">exec</span> container1 ip route add default via 10.1.1.1<br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 10.1.1.7/24 dev veth4<br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 up<br>ip netns <span class="hljs-built_in">exec</span> container2 ip route add default via 10.1.1.1<br>brctl addbr br-link<br>brctl addif br-link veth1<br>brctl addif br-link veth3<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth3 up<br>ip addr add 10.1.1.1/24 dev br-link<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br-link up<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证环境已经配置好</span><br><span class="hljs-comment"># 检查ipv4转发</span><br>sysctl net.ipv4.ip_forward<br><br><span class="hljs-comment"># 打开ipv4转发</span><br>sysctl -w net.ipv4.ip_forward=1<br><br><span class="hljs-comment"># 测试容器之间网络互通</span><br><span class="hljs-comment"># ip netns exec container1 ping &lt;宿主机eth0&gt;</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.0.8.4<br><br><span class="hljs-comment"># ip netns exec container1 ping &lt;同交换机switch\bridge网段容器ip&gt;</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 10.1.1.7<br></code></pre></td></tr></table></figure><h3 id="三、配置GRE隧道"><a href="#三、配置GRE隧道" class="headerlink" title="三、配置GRE隧道"></a>三、配置GRE隧道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ip tunnel add gre1 mode gre remote &lt;B的IP地址&gt; local &lt;A的IP地址&gt; ttl 255</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip tunnel add gre1 mode gre remote 10.1.1.7 <span class="hljs-built_in">local</span> 10.1.1.5 ttl 255<br><br>ip netns <span class="hljs-built_in">exec</span> container1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> gre1 up<br><br><span class="hljs-comment"># ip netns exec container1 ip addr add &lt;A的隧道IP地址&gt;/24 dev gre1</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ip addr add 172.16.0.2/24 dev gre1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ip tunnel add gre1 mode gre remote &lt;A的IP地址&gt; local &lt;B的IP地址&gt; ttl 255</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip tunnel add gre1 mode gre remote 10.1.1.5 <span class="hljs-built_in">local</span> 10.1.1.7 ttl 255<br><br>ip netns <span class="hljs-built_in">exec</span> container2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> gre1 up<br><br><span class="hljs-comment"># ip addr add &lt;B的隧道IP地址&gt;/24 dev gre1</span><br>ip netns <span class="hljs-built_in">exec</span> container2 ip addr add 172.16.0.8/24 dev gre1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ping &lt;B的隧道IP地址&gt;</span><br><span class="hljs-comment"># 验证container1和container2之间通讯</span><br>ip netns <span class="hljs-built_in">exec</span> container1 ping 172.16.0.8<br></code></pre></td></tr></table></figure><blockquote><p>通过GRE隧道，计算机A和B可以在公网上建立一个私有网络，安全地进行通信。注意要配置正确的IP地址和子网掩码，以及在防火墙中允许GRE流量通过。</p></blockquote><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://cizixs.com/2017/09/28/linux-vxlan/">https://cizixs.com/2017/09/28/linux-vxlan/</a></p>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>云产品标准化</title>
    <link href="/2023/07/05/%E6%A0%87%E5%87%86%E5%8C%96/"/>
    <url>/2023/07/05/%E6%A0%87%E5%87%86%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="必看产品"><a href="#必看产品" class="headerlink" title="必看产品"></a>必看产品</h3><ol><li>k8s的离线安装</li></ol><p>离线安装 Kubernetes 有两种主要方法：</p><p>使用离线安装包<br>使用本地源服务器<br>使用离线安装包</p><p>这是最常见的离线安装 Kubernetes 的方法。离线安装包通常包含了 Kubernetes 的所有安装文件，因此可以直接执行安装脚本或程序进行安装。</p><p>要获取 Kubernetes 的离线安装包，可以从 Kubernetes 官方网站下载。例如，要下载 Kubernetes 1.25.3 版本的离线安装包，可以使用以下命令：</p><p>curl -O <a href="https://dl.k8s.io/v1.25.3/kubernetes-node-linux-amd64.tar.gz">https://dl.k8s.io/v1.25.3/kubernetes-node-linux-amd64.tar.gz</a><br>下载完成后，将离线安装包复制到 Kubernetes 集群的所有节点。然后，在每个节点上执行以下命令来安装 Kubernetes：</p><p>tar -xvf kubernetes-node-linux-amd64.tar.gz<br>cd kubernetes&#x2F;install<br>.&#x2F;kubernetes-install.sh<br>使用本地源服务器</p><p>如果需要安装 Kubernetes 的特定版本或配置，可以使用本地源服务器来存储 Kubernetes 的离线安装包。</p><p>要使用本地源服务器，需要先在源服务器上创建一个存储 Kubernetes 离线安装包的目录。然后，将 Kubernetes 离线安装包上传到该目录。</p><p>在 Kubernetes 集群的所有节点上，配置 Kubernetes 的源服务器。可以使用以下命令来配置源服务器：</p><p>cat &lt;<EOF > &#x2F;etc&#x2F;kubernetes&#x2F;config.yaml<br>apiVersion: v1<br>clusters:</p><ul><li>name: local<br>cluster:<br>  server: http:&#x2F;&#x2F;&lt;源服务器 IP 地址&gt;:&lt;源服务器端口号&gt;<br>  certificate-authority: &#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.crt<br>  insecure-skip-tls-verify: true</li><li>name: default<br>cluster:<br>  server: https:&#x2F;&#x2F;&lt;Kubernetes API 服务器 IP 地址&gt;:&lt;Kubernetes API 服务器端口号&gt;<br>  certificate-authority: &#x2F;etc&#x2F;kubernetes&#x2F;ssl&#x2F;ca.crt<br>  insecure-skip-tls-verify: true<br>contexts:</li><li>name: default<br>context:<br>  cluster: local<br>  user: default<br>current-context: default<br>users:</li><li>name: default<br>user:<br>  username: admin<br>  password: &lt;密码&gt;<br>EOF<br>配置完成后，可以使用以下命令来安装 Kubernetes：</li></ul><p>kubeadm init<br>注意</p><p>使用本地源服务器安装 Kubernetes 时，需要在 Kubernetes API 服务器上配置证书。具体配置方法可以参考 Kubernetes 官方文档。</p><p>使用第三方工具</p><p>一些第三方工具可以用于离线安装 Kubernetes。这些工具可以简化离线安装的流程。</p><p>例如，可以使用 kubespray: <a href="https://github.com/kubernetes-sigs/kubespray">https://github.com/kubernetes-sigs/kubespray</a> 工具来离线安装 Kubernetes。kubespray 是一个用于自动化 Kubernetes 安装和配置的工具。使用 kubespray 可以快速和轻松地安装 Kubernetes。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kube-proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>eBPF&amp;cilium快速入门</title>
    <link href="/2023/07/05/cni/eBPF&amp;cilium%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
    <url>/2023/07/05/cni/eBPF&amp;cilium%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="一、概念"><a href="#一、概念" class="headerlink" title="一、概念"></a>一、概念</h3><p>eBPF（extended Berkeley Packet Filter）是一种在Linux内核中实现的虚拟机技术</p><h3 id="二、尝试cilium"><a href="#二、尝试cilium" class="headerlink" title="二、尝试cilium"></a>二、尝试cilium</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装Cilium CLI</span><br><br>CILIUM_CLI_VERSION=$(curl -s https://raw.githubusercontent.com/cilium/cilium-cli/master/stable.txt)<br>CLI_ARCH=amd64<br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-subst">$(uname -m)</span>&quot;</span> = <span class="hljs-string">&quot;aarch64&quot;</span> ]; <span class="hljs-keyword">then</span> CLI_ARCH=arm64; <span class="hljs-keyword">fi</span><br>curl -L --fail --remote-name-all https://github.com/cilium/cilium-cli/releases/download/<span class="hljs-variable">$&#123;CILIUM_CLI_VERSION&#125;</span>/cilium-linux-<span class="hljs-variable">$&#123;CLI_ARCH&#125;</span>.tar.gz&#123;,.<span class="hljs-built_in">sha256sum</span>&#125;<br><span class="hljs-built_in">sha256sum</span> --check cilium-linux-<span class="hljs-variable">$&#123;CLI_ARCH&#125;</span>.tar.gz.sha256sum<br>sudo tar xzvfC cilium-linux-<span class="hljs-variable">$&#123;CLI_ARCH&#125;</span>.tar.gz /usr/local/bin<br><span class="hljs-built_in">rm</span> cilium-linux-<span class="hljs-variable">$&#123;CLI_ARCH&#125;</span>.tar.gz&#123;,.<span class="hljs-built_in">sha256sum</span>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装Cilium</span><br><br>cilium install<br><br><span class="hljs-comment"># 验证安装</span><br>cilium status --<span class="hljs-built_in">wait</span><br><br><span class="hljs-comment"># 验证链接</span><br>cilium connectivity <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h6 id="1-Cilium-比-flannel-好在哪儿"><a href="#1-Cilium-比-flannel-好在哪儿" class="headerlink" title="1.Cilium 比 flannel 好在哪儿"></a>1.Cilium 比 flannel 好在哪儿</h6><p>Cilium和Flannel是Kubernetes集群中常用的两种网络插件，它们各自有着不同的特点和优势。</p><ol><li><p>性能：Cilium在性能方面表现更好。它使用Linux内核中的eBPF技术，实现了高性能的网络转发和安全功能。相比之下，Flannel使用传统的overlay网络技术，在大规模集群中可能会有性能瓶颈。</p></li><li><p>安全性：Cilium提供了更强大的网络安全功能。它可以通过定义丰富的网络策略，对容器之间的通信进行细粒度的控制和保护，包括L3&#x2F;L4层的过滤规则、应用层的协议解析和控制等。而Flannel则主要集中在网络互联的功能，安全性方面的支持相对较弱。</p></li><li><p>可观测性：Cilium提供了更丰富的可观测性功能。它可以生成详细的网络流量日志，并提供基于时间序列的指标监控。这些功能对于排查网络问题和性能优化非常有帮助。Flannel则相对简单，提供的可观测性功能较为有限。</p></li></ol><p>综上所述，Cilium相对于Flannel在性能、安全性和可观测性方面都有着更好的表现。但需要注意的是，选择网络插件应该根据具体需求和环境条件进行评估和权衡。</p><h5 id="2-网络的L3-x2F-L4层是什么意思"><a href="#2-网络的L3-x2F-L4层是什么意思" class="headerlink" title="2.网络的L3&#x2F;L4层是什么意思"></a>2.网络的L3&#x2F;L4层是什么意思</h5><p>L3和L4层是网络通信中的两个不同层次。<br>L3层，也称为网络层，是OSI（开放系统互联）模型中的第三层。它负责在不同网络之间进行数据包的路由和转发。L3层主要使用IP协议，通过IP地址来标识和寻址不同的主机和网络。<br>L4层，也称为传输层，是OSI模型中的第四层。它负责在源主机和目标主机之间提供端到端的数据传输控制和管理。L4层主要使用传输层协议（如TCP、UDP）来实现数据分段、可靠性控制、连接管理等功能。<br>在网络安全领域，L3&#x2F;L4层通常被用于网络策略和防火墙规则的制定。通过在L3&#x2F;L4层对网络数据包进行过滤和控制，可以实现对网络流量的分类、限制和保护。例如，可以根据源IP地址、目标IP地址、端口号等信息来定义规则，限制特定的网络通信或阻止潜在的恶意流量。</p><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://ebpf.io/what-is-ebpf/">https://ebpf.io/what-is-ebpf/</a><br><a href="https://www.kernel.org/doc/html/latest/bpf/index.html">BPF（Berkeley Packet Filter）</a><br><a href="https://mp.weixin.qq.com/s/WHoSyXMiaazxPhN9LXiwHg">Cilium作为K8s网络的解决方案</a><br><a href="https://cilium.io/blog/2021/05/11/cni-benchmark/">CNI基准：了解Cilium网络性能</a><br><a href="https://docs.cilium.io/en/stable/">https://docs.cilium.io/en/stable/</a><br><a href="https://atbug.com/accelerate-network-packets-transmission/">使用 eBPF 技术实现更快的网络数据包传输</a><br><a href="https://atbug.com/tracing-network-packets-in-kubernetes/">追踪 Kubernetes 中的数据包 - 宝藏博主</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ebpf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flannel接入k8s</title>
    <link href="/2023/07/05/cni/flanne%E6%8E%A5%E5%85%A5k8s/"/>
    <url>/2023/07/05/cni/flanne%E6%8E%A5%E5%85%A5k8s/</url>
    
    <content type="html"><![CDATA[<h3 id="1-kubernetes如何接入flannale"><a href="#1-kubernetes如何接入flannale" class="headerlink" title="1.kubernetes如何接入flannale"></a>1.kubernetes如何接入flannale</h3><p><a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">k8s&#x2F;概念&#x2F;扩展&#x2F;网络插件</a><br><a href="https://github.com/containerd/containerd/blob/main/script/setup/install-cni">k8s&#x2F;概念&#x2F;扩展&#x2F;网络插件&#x2F;containerd安装网络插件</a><br><a href="https://github.com/cri-o/cri-o/blob/main/contrib/cni/README.md">k8s&#x2F;概念&#x2F;扩展&#x2F;网络插件&#x2F;CRI-O安装网络插件</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy">k8s&#x2F;概念&#x2F;集群管理&#x2F;安装扩展</a><br><a href="https://github.com/flannel-io/flannel#deploying-flannel-with-kubectl">deploying-flannel-with-kubectl</a><br><a href="https://github.com/flannel-io/flannel#deploying-flannel-with-helm">deploying-flannel-with-helm</a></p><blockquote><p>安装 cni-plugins 网络插件，然后安装 flannel</p></blockquote><h3 id="2-flannel通信原理简述"><a href="#2-flannel通信原理简述" class="headerlink" title="2.flannel通信原理简述"></a>2.flannel通信原理简述</h3><ol><li>同一个Pod内的所有容器就会共享同一个网络命名空间，在同一个Pod之间的容器可以直接使用localhost进行通信；</li><li>每宿主机上运行名为flanneld，负责为宿主机预先分配一个子网，并为Pod分配IP地址；</li><li>拓扑图来看，同一个宿主机上的pod的网卡查到pair对，pair对端插docker0网桥(或者cni0)</li><li>当访问本机的cni0网段的pod的ip的时候，路由表会直接指向本机直接网关cni0</li><li>当访问其他宿主机上pod的时候，路由表会将数据指向flannel.1网卡，此时flannale.1网卡会将数据指向flanneld进程</li><li>Flannel会根据自己的路由表，将数据包封装成特定的协议（如VXLAN或UDP），并通过UDP或者其他方式将数据包发送到目标节点的Flannel网卡；</li><li>flannel.1网卡接收到数据以后不是通过iptable之类转发数据而是flanneld进程自己通过隧道或者自身的路由转发数据</li><li>同一个pod内的所有容器共享网络命名空间</li></ol><p><img src="/images/flannel-docker.webp" alt="flannel-docker拓扑图"></p><h3 id="3-flannel下网卡网桥查看"><a href="#3-flannel下网卡网桥查看" class="headerlink" title="3.flannel下网卡网桥查看"></a>3.flannel下网卡网桥查看</h3><h6 id="1-网卡列表和网段分配"><a href="#1-网卡列表和网段分配" class="headerlink" title="1.网卡列表和网段分配"></a>1.网卡列表和网段分配</h6><ul><li>Cni0网桥</li><li>每创建一个pod都会创建一对 veth pair，一端是pod中的eth0，另一端在Cni0网桥中的端口 （网卡）</li><li>Flannel.1（overlay网络设备，vxlan报文的处理（封包和解包），node之间pod流量从overlay设备以<code>隧道的形式</code>发送到对端）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip a<br><br><span class="hljs-comment"># 宿主机A输出网卡信息</span><br>1: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether d0:0d:f8:2a:2f:b2 brd ff:ff:ff:ff:ff:ff<br>    inet 10.16.203.47/21 brd 10.16.207.255 scope global dynamic noprefixroute enp1s0<br><br>2: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default <br>    <span class="hljs-built_in">link</span>/ether d6:62:0a:2f:b4:29 brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.0.0/32 brd 10.244.0.0 scope global flannel.1<br><br>3: cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether ae:87:60:9d:63:ac brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.0.1/24 brd 10.244.0.255 scope global cni0<br>4: veth6c306fc3@if3:<br>5: vethda0af07c@if3: <br><br><span class="hljs-comment"># 进入宿主机A上的容器</span><br>$ kubectl <span class="hljs-built_in">exec</span> -it loki-0 -n loki -- /bin/sh <br><br><span class="hljs-comment"># loki的网络是 inet 10.244.0.12 属于宿主机A的网段 10.244.0.1/24</span><br><span class="hljs-comment"># 而宿主机B的网段是 10.244.1.1/24 很明显不是同一个网段</span><br>$ ip a<br>3: eth0@if18: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1450 qdisc noqueue state UP <br>    <span class="hljs-built_in">link</span>/ether 5e:54:5a:33:85:5d brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.0.12/24 brd 10.244.0.255 scope global eth0<br><br><br><span class="hljs-comment"># 宿主机B网卡信息</span><br>1: enp1s0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether d0:0d:29:05:8f:ed brd ff:ff:ff:ff:ff:ff<br>    inet 10.16.203.55/21 brd 10.16.207.255 scope global dynamic noprefixroute enp1s0<br><br>2: flannel.1: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UNKNOWN group default <br>    <span class="hljs-built_in">link</span>/ether 0e:99:60:d8:96:e6 brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.1.0/32 brd 10.244.1.0 scope global flannel.1<br><br>3: cni0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1450 qdisc noqueue state UP group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether e2:e2:ee:49:c5:c8 brd ff:ff:ff:ff:ff:ff<br>    inet 10.244.1.1/24 brd 10.244.1.255 scope global cni0<br><br><span class="hljs-comment"># 很多pair对的对端插到网桥cni0上面 | 如果containerd runtime是docker那么这个是docker0</span><br><span class="hljs-comment"># 宿主机上的pod的ip都会属于网段 cni0 cidr 10.244.0.1/24</span><br>$ brctl show<br><br>bridge name     bridge <span class="hljs-built_in">id</span>               STP enabled     interfaces<br>cni0            8000.ae87609d63ac       no              veth6c306fc3<br>                                                        vethda0af07c<br></code></pre></td></tr></table></figure><h6 id="2-宿主机B访问宿主机A上面的pod数据流转"><a href="#2-宿主机B访问宿主机A上面的pod数据流转" class="headerlink" title="2.宿主机B访问宿主机A上面的pod数据流转"></a>2.宿主机B访问宿主机A上面的pod数据流转</h6><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登陆宿主机B</span><br>$ ip route<br><br><span class="hljs-comment"># 默认路由，所有无法匹配其他路由表项的数据包将通过网卡enp1s0发送到IP地址10.16.207.254。</span><br>default via 10.16.207.254 dev enp1s0 proto dhcp metric 100 <br><span class="hljs-comment"># 直连路由，表示该主机与子网10.16.200.0/21直接相连，本地IP地址为10.16.203.55。</span><br>10.16.200.0/21 dev enp1s0 proto kernel scope <span class="hljs-built_in">link</span> src 10.16.203.55 metric 100 <br><span class="hljs-comment"># 静态路由，所有目标为10.244.0.0/24的数据包将通过接口flannel.1发送到目标地址10.244.0.0。</span><br>10.244.0.0/24 via 10.244.0.0 dev flannel.1 onlink <br><span class="hljs-comment"># 直连路由，表示该主机与子网10.244.1.0/24直接相连，本地IP地址为10.244.1.1</span><br>10.244.1.0/24 dev cni0 proto kernel scope <span class="hljs-built_in">link</span> src 10.244.1.1 <br><br><br><span class="hljs-comment"># 第一步数据会一句静态路由 10.244.0.0/24 流转到flannel.1</span><br>$ ping 10.244.0.12<br></code></pre></td></tr></table></figure><h3 id="4-flannel网络通信原理实验"><a href="#4-flannel网络通信原理实验" class="headerlink" title="4.flannel网络通信原理实验"></a>4.flannel网络通信原理实验</h3><ol><li><p>同节点的pod之间通信</p><p>在容器启动前，会为容器创建一个虚拟Ethernet接口对，这个接口对类似于管道的两端，其中一端在主机命名空间中，另外一端在容器命名空间中，并命名为eth0。<br>在主机命名空间的接口会绑定到网桥。网桥的地址段会取IP赋值给容器的eth0接口。</p></li></ol><blockquote><p>利用nodeName特性将Pod调度到相同的node节点上（亲和性）</p></blockquote><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># p1.yml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">p1</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">k8s-node1</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">c1</span><br>    <span class="hljs-attr">command:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ping&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;baidu.com&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># p2.yaml</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">busybox</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">p2</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">default</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">nodeName:</span> <span class="hljs-string">k8s-node1</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">c2</span><br>    <span class="hljs-attr">command:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ping&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;baidu.com&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl apply -f p1.yaml -f p2.yaml<br>$ kubectl get pod p&#123;1,2&#125;<br>$ kubectl get pod p&#123;1,2&#125; -o wide<br><br><span class="hljs-comment"># p1 ping p2</span><br>$ kubectl <span class="hljs-built_in">exec</span> -it p1 -- ping 10.244.1.230<br><br><span class="hljs-comment"># 源容器向目标容器发送数据，数据首先发送给 cni0 网桥</span><br><br>$ kubectl <span class="hljs-built_in">exec</span> -it p1 -c c1 -- ip route<br>$ kubectl <span class="hljs-built_in">exec</span> -it p2 -c c2 -- ip route<br><br><span class="hljs-comment"># cni0 网桥接受到数据后，将其转交给 flannel.1 虚拟网卡处理</span><br><br><span class="hljs-comment"># flannel.1 接受到数据后，对数据进行封装，并发给宿主机的 ens33，再通过ens33出外网，或者访问不同node节点上的pod</span><br></code></pre></td></tr></table></figure><p><img src="/images/flannel-same-pod.png" alt="想同节点的不同pod之间的通信-基于flannel"></p><h3 id="5-flannel网络之中service是如何转发数据的"><a href="#5-flannel网络之中service是如何转发数据的" class="headerlink" title="5.flannel网络之中service是如何转发数据的"></a>5.flannel网络之中service是如何转发数据的</h3><p><img src="/images/service-flannel.webp" alt="service-flannel"></p><ol><li>service提供DNS解析、pod动态追踪更新转发表，域名规则为{服务名}.{namespace}.svc.{集群名称}，iptables维护和转发。</li><li>仅支持udp和tcp协议，所以ping的icmp协议是用不了的。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看DNS</span><br>$ kubectl get endpoints x -n x<br></code></pre></td></tr></table></figure><p><img src="/images/node-port-svc.png" alt="nodePort svc"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-什么叫做直连路由"><a href="#1-什么叫做直连路由" class="headerlink" title="1. 什么叫做直连路由"></a>1. 什么叫做直连路由</h5><ol><li>目的地与源地址直接相连的路由。</li><li>同一个子网中，可直发送到目的地，不需要任何中转设备或路由器。</li><li>在物理层或链路层上直接相连。</li><li>示例：<code>173.8.8.0/24 dev br2 proto kernel scope link src 173.8.8.1</code>因为本机网桥br2就是<code>inet 173.8.8.1</code>。</li></ol><h5 id="2-ip-route和route-n区别是什么"><a href="#2-ip-route和route-n区别是什么" class="headerlink" title="2. ip route和route -n区别是什么"></a>2. ip route和route -n区别是什么</h5><p><code>route -n</code>和<code>ip route</code>命令都是用于查看和管理系统的路由表，但有一些区别：</p><ol><li>语法：<code>route -n</code>是基于<code>net-tools</code>软件包的命令，而<code>ip route</code>是基于<code>iproute2</code>软件包的命令。<code>iproute2</code>是较新的工具集，可以提供更多的功能和选项。</li><li><code>ip route</code>命令的输出格式更为规范，以CIDR表示法显示网络和子网掩码，而不显示目标网络的广播地址。</li><li><code>ip route</code>命令更推荐使用。</li></ol><h5 id="3-flannel-1网卡接收到的流量会发给谁"><a href="#3-flannel-1网卡接收到的流量会发给谁" class="headerlink" title="3. flannel.1网卡接收到的流量会发给谁"></a>3. flannel.1网卡接收到的流量会发给谁</h5><ol><li>在flannel中，flannel.1网卡是用于虚拟网络通信的网络接口。</li><li>当flannel.1网卡接收到流量时，它会将流量转发给flannel进程。</li><li>flannel进程负责将流量封装并发送到其他节点上的flannel进程，以便在不同节点之间建立覆盖网络。</li><li>流量会达到目标节点的flannel进程，并被解封装并交给目标节点上的网络接口进行处理</li></ol><h5 id="4-flannel-1接收到的流量不会根据iptable或者其他的转发吗"><a href="#4-flannel-1接收到的流量不会根据iptable或者其他的转发吗" class="headerlink" title="4. flannel.1接收到的流量不会根据iptable或者其他的转发吗"></a>4. flannel.1接收到的流量不会根据iptable或者其他的转发吗</h5><ol><li>Flannel不会根据iptables或其他转发规则对流量进行处理;</li><li>Flannel通过隧道技术发送数据包;</li><li>容器发送网络请求时，数据包会经过容器的网卡（容器内部会根据iptable转发）然后数据包会到达宿主机的Flannel网卡(flannel.1)；</li><li>Flannel.1收到数据会到flanneld，根据自己路由表，将数据包封装成特定的协议（如VXLAN或UDP），并通过UDP或者其他方式将数据包发送到目标节点的Flannel网卡；</li></ol><h5 id="5-kube-proxy在flannel网络之中有什么用"><a href="#5-kube-proxy在flannel网络之中有什么用" class="headerlink" title="5. kube-proxy在flannel网络之中有什么用"></a>5. kube-proxy在flannel网络之中有什么用</h5><ol><li>提供服务的负载均衡和网络代理功能;</li><li>负载均衡：Service和其对应的多个Endpoint使用kube-proxy；</li><li>网络代理：将集群外部的请求转发到内部的服务（kube-proxy为Service创建虚拟IP并监听该IP）；</li><li>kube-proxy可以选择使用IPVS模式(比默认iptables性能更高)；</li></ol><h5 id="6-kube-proxy-为每个Service创建一个虚拟IP是什么意思"><a href="#6-kube-proxy-为每个Service创建一个虚拟IP是什么意思" class="headerlink" title="6. kube-proxy 为每个Service创建一个虚拟IP是什么意思"></a>6. kube-proxy 为每个Service创建一个虚拟IP是什么意思</h5><ol><li>kube-proxy负责实现服务发现和负载均衡功能。</li><li>kube-proxy会为Service创建虚拟IP（Virtual IP），这个虚拟IP是由kube-proxy自动生成的，用于代表该Service在集群内的访问地址。</li><li>pod访问svc域名时候会转发到该虚拟IP上，kube-proxy监听该IP并转发数据到svc的Endpoint；</li><li>svc的虚拟IP可以实现后端Pod的变动与Service的访问地址解耦，Pod的变化不会影响到虚拟IP；</li></ol><h5 id="7-ipvsadm-Ln是什么意思，flannel和ipvs什么关系"><a href="#7-ipvsadm-Ln是什么意思，flannel和ipvs什么关系" class="headerlink" title="7. ipvsadm -Ln是什么意思，flannel和ipvs什么关系"></a>7. ipvsadm -Ln是什么意思，flannel和ipvs什么关系</h5><p>linux系统上IPVS（IP Virtual Server）的配置和状态信息;<br>IPVS是Linux内核提供的一种高性能负载均衡技术，它可以在Linux系统上进行网络流量的分发和负载均衡。<br>IPVS可以作为kube-proxy的一种模式来实现负载均衡和代理转发功能。</p><h5 id="8-flannel和kube-proxy是什么关系"><a href="#8-flannel和kube-proxy是什么关系" class="headerlink" title="8. flannel和kube-proxy是什么关系"></a>8. flannel和kube-proxy是什么关系</h5><ol><li>Flannel（容器间的网络通信）和kube-proxy（服务发现和负载均衡功能）</li><li>Pod的IP分配：Flannel为每个Pod分配一个唯一的虚拟IP地址，并使用网络隔离技术（如VXLAN、UDP封装等）实现容器之间的通信。</li><li>跨节点通信：Flannel还负责将节点的主机网络连接起来，以便跨节点的Pod可以相互通信。</li><li>kube-proxy在service上创建虚拟IP并监听，并负载均衡转发backend的Pod。</li></ol><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://mp.weixin.qq.com/s/18bMpQjXFodfegWH3xNeKQ">Kubernetes（k8s）CNI（flannel）网络模型原理</a></li><li><a href="https://baijiahao.baidu.com/s?id=1677418078665703072">《蹲坑学K8S》之19-3：Flannel通信原理</a></li><li><a href="https://atbug.com/deep-dive-k8s-network-mode-and-communication/"> Kubernetes 网络模型和网络通信</a></li><li><a href="https://atbug.com/cross-node-traffic-on-flannel-vxlan-network/">从 Flannel 学习 Kubernetes overlay 网络 - 写的非常好</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flannel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kube-proxy设计与实现</title>
    <link href="/2023/07/05/cni/kube-proxy%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2023/07/05/cni/kube-proxy%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://zhuanlan.zhihu.com/p/337806843">一文看懂 Kube-proxy</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kube-proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chartmuseum</title>
    <link href="/2023/07/05/registry/chartmuseum/"/>
    <url>/2023/07/05/registry/chartmuseum/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name=chartmuseum --restart=always -it -d \<br>  -p 8080:8080 \<br>  -v ~/charts:/charts \<br>  -e STORAGE=<span class="hljs-built_in">local</span> \<br>  -e STORAGE_LOCAL_ROOTDIR=/charts \<br>  chartmuseum/chartmuseum:v0.12.0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在本地测试，如果helm客户端在其他机器，请修改localhost为指定ip</span><br>$ helm repo add chartrepo http://localhost:8080<br><span class="hljs-string">&quot;chartrepo&quot;</span> has been added to your repositories<br>$ helm repo list<br>NAME            URL<br>chartrepo       http://localhost:8080<br><br><br><span class="hljs-comment"># 我们创建并打包一个新的chart</span><br>$ helm create <span class="hljs-built_in">test</span><br>Creating <span class="hljs-built_in">test</span><br>$ helm package <span class="hljs-built_in">test</span><br>Successfully packaged chart and saved it to: /home/lijinyang/test-0.1.0.tgz<br><span class="hljs-comment"># 将生成的tgz文件放到chartmuseum的文件夹下</span><br>$ <span class="hljs-built_in">mv</span> test-0.1.0.tgz ~/charts/<br><br><span class="hljs-comment"># 然后helm运行helm repo update更新，并搜索</span><br>$ helm repo update<br>Hang tight <span class="hljs-keyword">while</span> we grab the latest from your chart repositories...<br>...Successfully got an update from the <span class="hljs-string">&quot;chartrepo&quot;</span> chart repository<br>Update Complete. ⎈ Happy Helming!⎈<br>$ helm search repo <span class="hljs-built_in">test</span><br>NAME            CHART VERSION   APP VERSION     DESCRIPTION<br>chartrepo/test  0.1.0           1.16.0          A Helm chart <span class="hljs-keyword">for</span> Kubernetes<br>$ helm show chart chartrepo/test<br>apiVersion: v2<br>appVersion: 1.16.0<br>description: A Helm chart <span class="hljs-keyword">for</span> Kubernetes<br>name: <span class="hljs-built_in">test</span><br><span class="hljs-built_in">type</span>: application<br>version: 0.1.0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装helm push 插件</span><br><span class="hljs-comment"># helm plugin install https://github.com/chartmuseum/helm-push.git</span><br><br><span class="hljs-comment"># helm push命令将chart发布到chartmuseum上</span><br><span class="hljs-comment"># helm push test-0.1.0.tgz chartrepo</span><br><br><span class="hljs-comment"># 更新helm repo，搜索刚刚上传的chart。</span><br><span class="hljs-comment"># helm repo upgrade</span><br><span class="hljs-comment"># helm search repo chartrepo</span><br>NAME                               CHART VERSION  APP VERSION   DESCRIPTION<br>chartmuseum/test                   0.1.0          1.16.0        A Helm chart <span class="hljs-keyword">for</span> Kubernetes<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>chartmuseum</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>registry</title>
    <link href="/2023/07/05/registry/registry/"/>
    <url>/2023/07/05/registry/registry/</url>
    
    <content type="html"><![CDATA[<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -p 5005:5000 --restart=always --name registry registry:latest<br></code></pre></td></tr></table></figure><p><a href="http://localhost:5005/v2/_catalog">http://localhost:5005/v2/_catalog</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull nginx:alpine<br><br>docker tag nginx:alpine 127.0.0.1:5005/test/mynginx:v1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://localhost:5005/v2/_catalog<br><br>&#123;<br>  <span class="hljs-string">&quot;repositories&quot;</span>: [<br>    <span class="hljs-string">&quot;test/mynginx&quot;</span><br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 其他节点拉取镜像</span><br>docker pull x.x.x.x:5005/test/mynginx:v1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>registry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何使用CNI给docker容器分配网络</title>
    <link href="/2023/06/29/cni/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CNI%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/06/29/cni/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8CNI%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1-安装docker和cni-plugins"><a href="#1-安装docker和cni-plugins" class="headerlink" title="1.安装docker和cni plugins"></a>1.安装docker和cni plugins</h3><ul><li>docker</li><li>cni plugins</li></ul><p><a href="https://github.com/containernetworking/cni/blob/main/README.md">本文参考手册CNI README.md</a></p><h3 id="2-脚本创建网络命名空间并分配网络quickStart"><a href="#2-脚本创建网络命名空间并分配网络quickStart" class="headerlink" title="2.脚本创建网络命名空间并分配网络quickStart"></a>2.脚本创建网络命名空间并分配网络quickStart</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 宿主机上验证CNI环境已经装好</span><br><span class="hljs-comment"># 下面这个脚本执行后会创建net namespace并且分配网络</span><br><span class="hljs-comment"># 然后打印出网卡信息</span><br>$ CNI_PATH=/opt/cni/bin<br>$ <span class="hljs-built_in">cd</span> /home &amp;&amp; git <span class="hljs-built_in">clone</span> https://github.com/containernetworking/cni.git<br>$ CNI_PATH=<span class="hljs-variable">$CNI_PATH</span> /home/cni/scripts/priv-net-run.sh ifconfig<br></code></pre></td></tr></table></figure><h3 id="3-对docker创建好的容器分配网络并查看网络配置docker"><a href="#3-对docker创建好的容器分配网络并查看网络配置docker" class="headerlink" title="3.对docker创建好的容器分配网络并查看网络配置docker"></a>3.对docker创建好的容器分配网络并查看网络配置docker</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker save -o busybox.tar busybox:latest<br>$ docker load -i busybox.tar<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下面这个脚本会给容器分配网络并且打印出容器内网卡信息</span><br>$ CNI_PATH=/opt/cni/bi<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CNI_PATH</span><br>$ <span class="hljs-built_in">cd</span> /home/cni/scripts &amp;&amp; CNI_PATH=<span class="hljs-variable">$CNI_PATH</span> ./docker-run.sh --<span class="hljs-built_in">rm</span> busybox:latest ifconfig<br></code></pre></td></tr></table></figure><h3 id="4-CNI在容器网络分配时候相关配置以及操作描述"><a href="#4-CNI在容器网络分配时候相关配置以及操作描述" class="headerlink" title="4.CNI在容器网络分配时候相关配置以及操作描述"></a>4.CNI在容器网络分配时候相关配置以及操作描述</h3><h5 id="1-相关博客"><a href="#1-相关博客" class="headerlink" title="1.相关博客"></a>1.相关博客</h5><p><a href="http://www.dasblinkenlichten.com/understanding-cni-container-networking-interface/">dasblinkenlichten.com&#x2F;深入理解CNI</a></p><h5 id="2-cni配置展示"><a href="#2-cni配置展示" class="headerlink" title="2.cni配置展示"></a>2.cni配置展示</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /opt/cni/bin<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> &gt; mybridge.conf &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;cniVersion&quot;: &quot;0.2.0&quot;,</span><br><span class="hljs-string">    &quot;name&quot;: &quot;mybridge&quot;,</span><br><span class="hljs-string">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="hljs-string">    &quot;bridge&quot;: &quot;cni_bridge0&quot;,</span><br><span class="hljs-string">    &quot;isGateway&quot;: true,</span><br><span class="hljs-string">    &quot;ipMasq&quot;: true,</span><br><span class="hljs-string">    &quot;ipam&quot;: &#123;</span><br><span class="hljs-string">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="hljs-string">        &quot;subnet&quot;: &quot;10.15.20.0/24&quot;,</span><br><span class="hljs-string">        &quot;routes&quot;: [</span><br><span class="hljs-string">            &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;,</span><br><span class="hljs-string">            &#123; &quot;dst&quot;: &quot;1.1.1.1/32&quot;, &quot;gw&quot;:&quot;10.15.20.1&quot;&#125;</span><br><span class="hljs-string">        ]</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><h5 id="2-手动创建网络命名空间然后使用CNI手动给该命名空间分配网卡"><a href="#2-手动创建网络命名空间然后使用CNI手动给该命名空间分配网卡" class="headerlink" title="2.手动创建网络命名空间然后使用CNI手动给该命名空间分配网卡"></a>2.手动创建网络命名空间然后使用CNI手动给该命名空间分配网卡</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo ip netns add 1234567890<br>$ sudo CNI_COMMAND=ADD CNI_CONTAINERID=1234567890 CNI_NETNS=/var/run/netns/1234567890 CNI_IFNAME=eth12 CNI_PATH=`<span class="hljs-built_in">pwd</span>` ./bridge &lt;mybridge.conf<br><span class="hljs-comment"># 查看我们的主机 iptables 规则，我们将看到伪装和接受规则.</span><br>$ sudo iptables-save | grep mybridge<br><span class="hljs-comment"># 通常情况下，容器运行时会创建netns，这里我们手动创建</span><br>$ sudo ip netns <span class="hljs-built_in">exec</span> 1234567890 ifconfig<br><span class="hljs-comment">#　设备eth12的IP地址配置为10.15.20.2，子网掩码为255.255.255.0（/24表示子网掩码），并将该设备的网络范围设置为本地链接（scope link）</span><br>$ sudo ip netns <span class="hljs-built_in">exec</span> 1234567890 ip route<br><br><span class="hljs-comment"># 命名空间有一个名为“eth12”的接口，IP 地址为 10.15.20.2/24</span><br><span class="hljs-comment"># IP 地址对应的ipam的子网段地址</span><br>eth12: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.15.20.2  netmask 255.255.255.0  broadcast 10.15.20.255<br>        inet6 fe80::44f2:48ff:feb6:b364  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 46:f2:48:b6:b3:64  txqueuelen 0  (Ethernet)<br>        RX packets 67  bytes 13007 (12.7 KiB)<br>        RX errors 0  dropped 3  overruns 0  frame 0<br>        TX packets 9  bytes 682 (682.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br><br><span class="hljs-comment"># netns内部的网络路由可以看到规则有</span><br><span class="hljs-comment"># - 所有未知目标IP地址的网络流量都将通过eth12设备，并通过网关10.15.20.1转发到其他网络</span><br><span class="hljs-comment"># - 将目标IP地址1.1.1.1的网络流量通过eth12设备，并通过网关10.15.20.1转发到其他网络</span><br><span class="hljs-comment"># - 本地网络10.15.20.0/24的所有流量都通过eth12设备发送，并且源IP地址为10.15.20.2</span><br><span class="hljs-comment"># &quot;proto kernel&quot;表示该路由是由内核自动生成的。 &quot;scope link&quot; 表示该路由只适用于本地链路</span><br>$ sudo ip netns <span class="hljs-built_in">exec</span> 1234567890 ip route<br><br>default via 10.15.20.1 dev eth12                                 <span class="hljs-comment">#  &quot;dev&quot; 是指指定该路由器的出口网络接口，即数据包是从哪个网络接口发送出去的, 默认路由通过 eth12 网络接口，经过 10.15.20.1 这个下一跳地址进行转发</span><br>1.1.1.1 via 10.15.20.1 dev eth12                                 <span class="hljs-comment">#  &quot;via&quot; 是指默认路由的下一跳地址，即数据包需要经过哪个路由器进行转发</span><br>10.15.20.0/24 dev eth12 proto kernel scope <span class="hljs-built_in">link</span> src 10.15.20.2   <span class="hljs-comment">#  &quot;src&quot; 是指源IP地址，即指定该路由器发送数据包的源IP地址</span><br><br><span class="hljs-comment"># 查看网桥配置可以看到netns内部网卡eth12的veth pair对端网卡是vethb4336cfa</span><br>$ brctl show<br><br>bridge name     bridge <span class="hljs-built_in">id</span>               STP enabled     interfaces<br>cni_bridge0     8000.127bceaee96d       no              vethb4336cfa<br></code></pre></td></tr></table></figure><h5 id="3-配置解析"><a href="#3-配置解析" class="headerlink" title="3.配置解析"></a>3.配置解析</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;cniVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;定义适用的 CNI 规范的版本&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;网络名称&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;您希望使用的插件的名称。在这种情况下，插件可执行文件的实际名称&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;bridge&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;创建名为cni_bridge0的网桥接口&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isGateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如果为真，则为网桥分配一个IP地址，以便连接到它的容器可以将其用作网关&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ipMasq&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为此网络配置出站伪装（源 NAT）&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ipam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IPAM 插件可执行文件的名称&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;要分配的子网（这实际上是 IPAM 插件的一部分），这个其实决定了容器内的网址&quot;</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;routes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;dst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;您希望访问的子网&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;dst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;您希望访问的子网&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;gw&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;到达dst的下一跳IP地址。如果未指定，则假定为子网的默认网关&quot;</span><span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h5 id="4-命名描述"><a href="#4-命名描述" class="headerlink" title="4.命名描述"></a>4.命名描述</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">CNI_COMMAND=ADD – 我们告诉 CNI 我们想要添加一个连接<br>CNI_CONTAINER=1234567890 – 我们告诉 CNI 我们想要使用的网络命名空间称为“1234567890”（更多内容见下文）<br>CNI_NETNS=/var/run/netns/1234567890 – 相关命名空间的路径<br>CNI_IFNAME=eth12 – 我们希望在连接的容器端使用的接口名称<br>CNI_PATH=`<span class="hljs-built_in">pwd</span>`  – 我们总是需要告诉 CNI 插件可执行文件所在的位置。在这种情况下，<br>因为我们已经在“cni”目录中，所以我们只有变量引用 <span class="hljs-built_in">pwd</span>（当前工作目录）。<br>您需要命令 <span class="hljs-built_in">pwd</span> 周围的刻度线才能正确评估。此处的格式似乎正在删除它们，但它们在上面的命令中正确<br>我们使用 STDIN 将网络配置文件提供给插件<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>创建双网卡实现网络隔离</title>
    <link href="/2023/06/29/cni/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%8C%E7%BD%91%E5%8D%A1%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/"/>
    <url>/2023/06/29/cni/%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%8F%8C%E7%BD%91%E5%8D%A1%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><ul><li><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">docker</a></li></ul><h3 id="二、创建1个容器分配2张网卡"><a href="#二、创建1个容器分配2张网卡" class="headerlink" title="二、创建1个容器分配2张网卡"></a>二、创建1个容器分配2张网卡</h3><ol><li>容器创建</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --net=none -itd --name busybox-test busybox<br>$ docker <span class="hljs-built_in">exec</span> busybox-test ip a<br></code></pre></td></tr></table></figure><ol start="2"><li>创建网桥br1并且分配网卡eth1</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install bridge-utils<br>$ brctl show<br>$ brctl addbr br1<br>$ ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name veth2<br>$ brctl addif br1 veth1<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br><br><span class="hljs-comment"># 获取docker容器内部的网络命名空间net namespace</span><br><span class="hljs-comment"># docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; &lt;container_name&gt;</span><br>$ proc_id=$(docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> busybox-test)<br><br><span class="hljs-comment"># 将容器进程内部namespace链接到宿主机的namespace</span><br>$ local_namespace_name=123456789<br>$ <span class="hljs-built_in">ln</span> -s /proc/<span class="hljs-variable">$proc_id</span>/ns/net /var/run/netns/<span class="hljs-variable">$local_namespace_name</span><br><br><span class="hljs-comment"># 将对端网卡插入docker容器命名空间之中</span><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 netns <span class="hljs-variable">$local_namespace_name</span><br><br><span class="hljs-comment"># 重命名容器内部的网卡</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth2 name eth1<br><br><span class="hljs-comment"># 启用</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth1 up<br><br><span class="hljs-comment"># 分配ip</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip addr add 10.1.1.5/24 dev eth1<br><br><span class="hljs-comment"># 添加网关</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip route add default via 10.1.1.1<br><br><span class="hljs-comment"># 启动网桥br1并且分配ip以及子网掩码</span><br>$ ip addr add 10.1.1.1/24 dev br1<br><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br1 up<br></code></pre></td></tr></table></figure><ol start="3"><li>创建网桥br2并且分配网卡eth2</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brctl show<br>$ brctl addbr br2<br>$ ip <span class="hljs-built_in">link</span> add veth3 <span class="hljs-built_in">type</span> veth peer name veth4<br>$ brctl addif br2 veth3<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth3 up<br><br><span class="hljs-comment"># get docker container net namespace</span><br>$ proc_id=$(docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> busybox-test)<br><br><span class="hljs-comment"># net namespace link to local host</span><br>$ local_namespace_name=123456789<br><br><span class="hljs-comment"># 将对端网卡插入docker容器命名空间之中</span><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth4 netns <span class="hljs-variable">$local_namespace_name</span><br><br><span class="hljs-comment"># 重命名容器内部的网卡</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth4 name eth2<br><br><span class="hljs-comment"># 启用</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth2 up<br><br><span class="hljs-comment"># 分配ip</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip addr add 173.8.8.9/24 dev eth2<br><br><span class="hljs-comment"># 启动网桥br1并且分配ip以及子网掩码</span><br>$ ip addr add 173.8.8.1/24 dev br2<br><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br2 up<br></code></pre></td></tr></table></figure><h3 id="三、容器内监听不同的网卡"><a href="#三、容器内监听不同的网卡" class="headerlink" title="三、容器内监听不同的网卡"></a>三、容器内监听不同的网卡</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  nc -l -p &lt;监听端口&gt; -s &lt;指定网卡名称&gt;</span><br><span class="hljs-comment">#  nc 监听TCP端口</span><br>$ docker <span class="hljs-built_in">exec</span> busybox-test nc -l -p 9090 -s 10.1.1.5<br><br><span class="hljs-comment"># tcp端口发送数据包</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> | nc 10.1.1.5 9090<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  nc -l -p &lt;监听端口&gt; -s &lt;指定网卡名称&gt;</span><br>$ docker <span class="hljs-built_in">exec</span> busybox-test nc -l -p 8080 -s 173.8.8.9<br><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;world&quot;</span> | nc 173.8.8.9 8080<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>nc监听UDP端口和发送数据</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将字符串&quot;Hello, world!&quot;通过UDP协议传输到本地IP地址为127.0.0.1，端口号为12345的主机上</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, world!&quot;</span> | sudo nc -u 127.0.0.1 12345<br><br><span class="hljs-comment"># 以UDP协议侦听端口号为12345的数据流量</span><br>$ nc -u -l 12345<br></code></pre></td></tr></table></figure><ol start="2"><li>docker的网络命名空间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将网卡插入到net namespace就是docker容器内部网络网卡</span><br>$ proc_id=$(docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> busybox-test)<br>$ <span class="hljs-built_in">ls</span> /proc/<span class="hljs-variable">$proc_id</span>/ns/net<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何手动给docker容器分配网络</title>
    <link href="/2023/06/29/cni/%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/06/29/cni/%E5%A6%82%E4%BD%95%E6%89%8B%E5%8A%A8%E7%BB%99docker%E5%AE%B9%E5%99%A8%E5%88%86%E9%85%8D%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><ul><li><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">docker</a></li></ul><h3 id="二、运行"><a href="#二、运行" class="headerlink" title="二、运行"></a>二、运行</h3><ol><li>容器创建</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run --net=none -itd --name busybox-test busybox<br>$ docker <span class="hljs-built_in">exec</span> busybox-test ip a<br></code></pre></td></tr></table></figure><ol start="2"><li>创建宿主机的网桥br-test和pair对</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brctl show<br>$ brctl addbr br-test<br>$ ip <span class="hljs-built_in">link</span> add veth-test1 <span class="hljs-built_in">type</span> veth peer name veth-test2<br>$ brctl addif br-test veth-test1<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-test1 up<br></code></pre></td></tr></table></figure><ol start="3"><li>将pair对端网卡一端放在容器内部网络命名空间，给该网卡分配ip</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 获取docker容器内部的网络命名空间net namespace</span><br><span class="hljs-comment"># docker inspect -f &#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27; &lt;container_name&gt;</span><br>$ proc_id=$(docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.State.Pid&#125;&#125;&#x27;</span> busybox-test)<br><br><span class="hljs-comment"># 将容器进程内部namespace链接到宿主机的namespace</span><br>$ local_namespace_name=123456789<br>$ <span class="hljs-built_in">ln</span> -s /proc/<span class="hljs-variable">$proc_id</span>/ns/net /var/run/netns/<span class="hljs-variable">$local_namespace_name</span><br><br><span class="hljs-comment"># 查看宿主机的namespace list</span><br>$ ip netns list<br><br><span class="hljs-comment"># 将对端网卡插入docker容器命名空间之中</span><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth-test2 netns <span class="hljs-variable">$local_namespace_name</span><br><br><span class="hljs-comment"># docker容器已经有一个未分配ip和未启用的网卡</span><br>$ docker <span class="hljs-built_in">exec</span> busybox-test ip a<br><br><span class="hljs-comment"># 重命名容器内部的网卡</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev veth-test2 name eth0<br><br><span class="hljs-comment"># 启用</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up<br><br><span class="hljs-comment"># 分配ip</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip addr add 10.1.1.2/24 dev eth0<br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip a<br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip route<br><br><span class="hljs-comment"># 添加网关</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip route add default via 10.1.1.1<br><br><span class="hljs-comment"># 此时可以看容器的ip自动分配为10.1.1.2</span><br>$ docker <span class="hljs-built_in">exec</span> busybox-test ip a<br><br><span class="hljs-comment"># 使用下面的操作更改IP地址</span><br><span class="hljs-comment"># sudo ip link set &lt;interface_name&gt; down</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 down<br><br><span class="hljs-comment"># 从名为eth0的网络接口上删除IP地址为10.1.1.2/24的配置</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip addr del 10.1.1.2/24 dev eth0<br><br><span class="hljs-comment"># 重新分配ip及子网掩码</span><br><span class="hljs-comment"># sudo ip addr add &lt;ip_address&gt;/&lt;subnet_mask&gt; dev &lt;interface_name&gt;</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip addr add 10.1.1.8/24 dev eth0<br><br><span class="hljs-comment"># 启用网卡</span><br><span class="hljs-comment"># sudo ip link set &lt;interface_name&gt; up</span><br>$ ip netns <span class="hljs-built_in">exec</span> <span class="hljs-variable">$local_namespace_name</span> ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> eth0 up<br><br><span class="hljs-comment"># 查看容器内网络</span><br>$ docker <span class="hljs-built_in">exec</span> busybox-test ip a<br><br><span class="hljs-comment"># 进入容器内部</span><br>$ docker <span class="hljs-built_in">exec</span> -it busybox-test /bin/sh<br></code></pre></td></tr></table></figure><ol start="4"><li>验证容器网络</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动网桥br-test并且分配ip以及子网掩码</span><br>ip addr add 10.1.1.1/24 dev br-test<br><br><span class="hljs-comment"># 网桥分配后会自动添加路由</span><br>$ ip route <br><br><span class="hljs-comment"># 这句话表示在网络设备上配置了一个名为br-test的网桥，其IP地址为10.1.1.1</span><br><span class="hljs-comment"># 子网掩码为24位（即255.255.255.0）</span><br><span class="hljs-comment"># 该网桥与内核通信，被用于该设备上的本地通信，在该网桥上的设备可以通过该IP地址进行通信</span><br><span class="hljs-comment"># 10.1.1.0/24 dev br-test proto kernel scope link src 10.1.1.1</span><br><br><span class="hljs-comment"># ping 容器内部网卡ip</span><br>$ ping 10.1.1.8<br><br>PING 10.1.1.8 (10.1.1.8) 56(84) bytes of data.<br>64 bytes from 10.1.1.8: icmp_seq=1 ttl=64 time=0.084 ms<br>64 bytes from 10.1.1.8: icmp_seq=2 ttl=64 time=0.044 ms<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>linux的网卡配置路径一般是什么</li></ol><p>在Linux系统上，网卡配置文件的路径一般是<code>cd </code>。这是一个常用的网卡配置文件路径，适用于大多数基于Debian或Ubuntu的发行版。<br>但是，需要注意的是，不同的Linux发行版可能会有不同的网络管理工具和配置文件路径。以下是一些其他流行的Linux发行版的网卡配置文件路径：</p><ul><li>CentOS、RHEL、Fedora：<code>/etc/sysconfig/network-scripts/ifcfg-&lt;interface_name&gt;</code></li><li>SUSE：<code>/etc/sysconfig/network/ifcfg-&lt;interface_name&gt;</code></li><li>Arch Linux： <code>/etc/netctl/&lt;interface_name&gt;</code></li><li>Ubuntu 18.04及更高版本：配置文件路径已经从<code>/etc/network/interfaces</code>变更为<code>/etc/netplan/</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch与环状拓扑</title>
    <link href="/2023/06/15/cni/openvswitch%E4%B8%8E%E7%8E%AF%E7%8A%B6%E6%8B%93%E6%89%91/"/>
    <url>/2023/06/15/cni/openvswitch%E4%B8%8E%E7%8E%AF%E7%8A%B6%E6%8B%93%E6%89%91/</url>
    
    <content type="html"><![CDATA[<h3 id="1-准备linux环境"><a href="#1-准备linux环境" class="headerlink" title="1.准备linux环境"></a>1.准备linux环境</h3><ul><li><a href="https://weiqiangxu.github.io/2023/06/02/cni/openvswitch%E5%AE%89%E8%A3%85/">openvswitch如何安装</a></li><li><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">docker离线安装</a>也可以直接使用yum等包管理工具在线安装</li></ul><h3 id="2-host1"><a href="#2-host1" class="headerlink" title="2.host1"></a>2.host1</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl stop firewalld<br>$ ovs-vsctl add-br br1<br>$ ifconfig br1 192.168.222.11/24 up<br>$ ip route<br></code></pre></td></tr></table></figure><h3 id="3-host2"><a href="#3-host2" class="headerlink" title="3.host2"></a>3.host2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl stop firewalld<br>$ ovs-vsctl add-br br1<br>$ ifconfig br1 192.168.222.12/24 up<br>$ ip route<br></code></pre></td></tr></table></figure><h3 id="3-host3"><a href="#3-host3" class="headerlink" title="3.host3"></a>3.host3</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl stop firewalld<br>$ ovs-vsctl add-br br1<br>$ ifconfig br1 192.168.222.13/24 up<br>$ ip route<br></code></pre></td></tr></table></figure><h3 id="4-host1-ping-host2"><a href="#4-host1-ping-host2" class="headerlink" title="4.host1 ping host2"></a>4.host1 ping host2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br>$ ping 192.168.222.12<br></code></pre></td></tr></table></figure><h3 id="5-在host1和host2之间建设GRE隧道"><a href="#5-在host1和host2之间建设GRE隧道" class="headerlink" title="5.在host1和host2之间建设GRE隧道"></a>5.在host1和host2之间建设GRE隧道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br>$ ovs-vsctl add-port br1 gre1 -- <span class="hljs-built_in">set</span> interface gre1 <span class="hljs-built_in">type</span>=gre option:remote_ip=<span class="hljs-variable">$&#123;host2_ip&#125;</span><br>$ ovs-vsctl show<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host2</span><br>$ ovs-vsctl add-port br1 gre1 -- <span class="hljs-built_in">set</span> interface gre1 <span class="hljs-built_in">type</span>=gre option:remote_ip=<span class="hljs-variable">$&#123;host1_ip&#125;</span><br>$ ovs-vsctl show<br></code></pre></td></tr></table></figure><h3 id="6-host1-ping-host2"><a href="#6-host1-ping-host2" class="headerlink" title="6.host1 ping host2"></a>6.host1 ping host2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br><span class="hljs-comment"># 此时可以通讯</span><br>$ ping 192.168.222.12<br></code></pre></td></tr></table></figure><h3 id="7-在host1和host3之间建设VXLAN隧道"><a href="#7-在host1和host3之间建设VXLAN隧道" class="headerlink" title="7.在host1和host3之间建设VXLAN隧道"></a>7.在host1和host3之间建设VXLAN隧道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br>ovs-vsctl add-port br1 vxlan1 -- <span class="hljs-built_in">set</span> Interface vxlan1 <span class="hljs-built_in">type</span>=vxlan options:remote_ip=<span class="hljs-variable">$&#123;host3_ip&#125;</span><br><br><span class="hljs-comment"># host3</span><br>ovs-vsctl add-port br1 vxlan1 -- <span class="hljs-built_in">set</span> Interface vxlan1 <span class="hljs-built_in">type</span>=vxlan options:remote_ip=<span class="hljs-variable">$&#123;host1_ip&#125;</span><br><br><span class="hljs-comment"># host1 ping host3 会自动使用 vxlan隧道通讯</span><br>$ ping 192.168.222.13<br></code></pre></td></tr></table></figure><h3 id="6-在host2和host3之间建立GRE-OVER-IPSec隧道"><a href="#6-在host2和host3之间建立GRE-OVER-IPSec隧道" class="headerlink" title="6.在host2和host3之间建立GRE OVER IPSec隧道"></a>6.在host2和host3之间建立GRE OVER IPSec隧道</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host2</span><br>ovs-vsctl add-port br1 ipsec2 -- <span class="hljs-built_in">set</span> Interface ipsec2 <span class="hljs-built_in">type</span>=gre options:remote_ip=<span class="hljs-variable">$&#123;host3_ip&#125;</span> options:psk=password<br><br><span class="hljs-comment"># host3</span><br>ovs-vsctl add-port br1 ipsec3 -- <span class="hljs-built_in">set</span> Interface ipsec3 <span class="hljs-built_in">type</span>=gre options:remote_ip=<span class="hljs-variable">$&#123;host2_ip&#125;</span> options:psk=password<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1 ping host2 提示 From 192.168.222.11 icmp_seq=261 Destination Host Unreachable</span><br><span class="hljs-comment"># 网络出现了环，打开STP即可解决</span><br><span class="hljs-comment"># 4789 udp对于vxlan来说极为重要,安全组之中必须打开 4789 udp</span><br>ovs-vsctl <span class="hljs-built_in">set</span> bridge <span class="hljs-variable">$&#123;br_name&#125;</span> stp_enable=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="/images/experiment11_2.png" alt="vxlan和gre构建一个环状拓扑"></p><h3 id="7-网桥的-Spanning-Tree-Protocol-STP-功能"><a href="#7-网桥的-Spanning-Tree-Protocol-STP-功能" class="headerlink" title="7.网桥的 Spanning Tree Protocol(STP)功能"></a>7.网桥的 Spanning Tree Protocol(STP)功能</h3><blockquote><p>STP 是一种用于在拓扑结构中防止环路出现的协议</p></blockquote><p>三台机器查看<code>ovs-vsctl list bridge</code>可以发现，host2是root bridge，host1 ping host2是不经过host3的，实验host1 ping host2经过host3。</p><ul><li>实现ns1 ping ns2时，经过ns3</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ns1</span><br>$ ovs-vsctl <span class="hljs-built_in">set</span> Port gre1 other_config:stp-path-cost=190<br>$ ovs-appctl stp/show<br></code></pre></td></tr></table></figure><ul><li>重新设置stp-path-cost，使ns1 ping ns2不经过ns3</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#ns1</span><br>$ ovs-vsctl <span class="hljs-built_in">set</span> Port gre1 other_config:stp-path-cost=10<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>如何删除隧道</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 因为Tunnel(GRE、VXLAN)也是openvswitch Port的一种类型</span><br>ovs-vsctl del-port br1 vxlan1<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://mp.weixin.qq.com/s/Mpng0TAAK2st9v2N1RxNdA">图解 STP ：你可能不用，但是不能不懂</a></p>]]></content>
    
    
    <categories>
      
      <category>openvswitch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch限速QoS</title>
    <link href="/2023/06/15/cni/openvswitch%E9%99%90%E9%80%9FQoS/"/>
    <url>/2023/06/15/cni/openvswitch%E9%99%90%E9%80%9FQoS/</url>
    
    <content type="html"><![CDATA[<h3 id="1-准备linux环境"><a href="#1-准备linux环境" class="headerlink" title="1.准备linux环境"></a>1.准备linux环境</h3><ul><li><a href="https://weiqiangxu.github.io/2023/06/02/cni/openvswitch%E5%AE%89%E8%A3%85/">openvswitch如何安装</a></li><li><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">docker离线安装</a>也可以直接使用yum等包管理工具在线安装</li></ul><h3 id="2-准备镜像"><a href="#2-准备镜像" class="headerlink" title="2.准备镜像"></a>2.准备镜像</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># alpine-ovs</span><br><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.16</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span><br><span class="language-bash">apk add vim tcpdump iperf iproute2</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t alpine-ovs .<br></code></pre></td></tr></table></figure><h3 id="3-创建容器"><a href="#3-创建容器" class="headerlink" title="3.创建容器"></a>3.创建容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建网络</span><br>docker network  create --subnet=192.168.101.0/24 ovs-net<br><br><span class="hljs-comment"># 创建容器</span><br>docker run -it -d --net ovs-net --ip 192.168.101.2 --name ns2 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns2在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns2_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns2_default_if&#125;</span> name veth1-ns2 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns2 up<br><br>docker run -it -d --net ovs-net --ip 192.168.101.3 --name ns3 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns3在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns3_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns3_default_if&#125;</span> name veth1-ns3 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns3 up<br><br>docker run -it -d --net ovs-net --ip 192.168.101.4 --name ns4 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns4在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns4_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns4_default_if&#125;</span> name veth1-ns4 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns4 up<br><br>docker run -it -d --net ovs-net --ip 192.168.101.5 --name ns5 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns5在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns5_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns5_default_if&#125;</span> name veth1-ns5 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns5 up<br></code></pre></td></tr></table></figure><h3 id="4-ovs建桥承接docker容器流量"><a href="#4-ovs建桥承接docker容器流量" class="headerlink" title="4.ovs建桥承接docker容器流量"></a>4.ovs建桥承接docker容器流量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看网桥</span><br><span class="hljs-comment"># 会发现网桥后面有3个网络插口</span><br>brctl show<br><br><span class="hljs-comment"># 现在我们把这3个网卡从docker创建的网桥拔出来</span><br><span class="hljs-comment"># brctl delif $&#123;bridge_name&#125; veth1-ns2 veth1-ns3 veth1-ns4 veth1-ns5</span><br>brctl delif br-ec86ebf52532 veth1-ns2 veth1-ns3 veth1-ns4 veth1-ns5<br><br><span class="hljs-comment"># 使用 ovs 创建的网桥</span><br>ovs-vsctl add-br ovs-br1<br>ovs-vsctl add-br ovs-br2<br><br><span class="hljs-comment"># 将3个容器的对端网卡插入到 ovs网桥</span><br>ovs-vsctl add-port ovs-br1 veth1-ns2<br>ovs-vsctl add-port ovs-br1 veth1-ns3<br>ovs-vsctl add-port ovs-br2 veth1-ns4<br>ovs-vsctl add-port ovs-br2 veth1-ns5<br></code></pre></td></tr></table></figure><h3 id="5-查看当前ovs桥网络"><a href="#5-查看当前ovs桥网络" class="headerlink" title="5.查看当前ovs桥网络"></a>5.查看当前ovs桥网络</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看ovs的桥配置</span><br>$ ovs-vsctl show<br></code></pre></td></tr></table></figure><h3 id="6-添加bond逻辑网卡"><a href="#6-添加bond逻辑网卡" class="headerlink" title="6.添加bond逻辑网卡"></a>6.添加bond逻辑网卡</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># OVS 的 bond 绑定多个物理网卡成一个逻辑网卡，可以提高网络的可靠性和带宽的实现</span><br><span class="hljs-comment"># 开启网卡</span><br>ip <span class="hljs-built_in">link</span> add tab1 <span class="hljs-built_in">type</span> veth peer name peer-tab1<br>ip <span class="hljs-built_in">link</span> add tab2 <span class="hljs-built_in">type</span> veth peer name peer-tab2<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tab1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-tab1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tab2 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-tab2 up<br><br><span class="hljs-comment"># 创建一个名为&quot;bond1&quot;的链路聚合组(bond)</span><br><span class="hljs-comment"># 并将两个网络命名空间中的虚拟网卡&quot;veth1-ns2&quot;和&quot;veth1-ns3&quot;与该链路聚合组绑定，从而实现高可用性和负载均衡</span><br>ovs-vsctl add-bond ovs-br1 bond1 tab1 tab2<br><br><span class="hljs-comment"># 创建一个名为&quot;bond2&quot;的链路聚合组(bond)</span><br><span class="hljs-comment"># 并将两个网络命名空间中的虚拟网卡&quot;veth1-ns4&quot;和&quot;veth1-ns5&quot;与该链路聚合组绑定，从而实现高可用性和负载均衡</span><br>ovs-vsctl add-bond ovs-br2 bond2 peer-tab1 peer-tab2<br><br><span class="hljs-comment"># 在ovs-br1交换机中，将名称为&quot;bond1&quot;的链路聚合组(bond)的LACP协议设置为主动模式(active)</span><br><span class="hljs-comment"># LACP为链路聚合控制协议(Link Aggregation Control Protocol)的缩写</span><br><span class="hljs-comment"># 它用于在链路聚合组成员之间进行协商和控制，以确保链路聚合组的高可用性和负载均衡。</span><br><span class="hljs-comment"># 在主动模式下，链路聚合组成员会发送LACP协议数据单元，与其他成员进行协商和控制，以建立和维护链路聚合组。这样可以更好地保证链路聚合组的可靠性和性能。</span><br>ovs-vsctl <span class="hljs-built_in">set</span> port bond1 lacp=active<br>ovs-vsctl <span class="hljs-built_in">set</span> port bond2 lacp=active<br><br><span class="hljs-comment"># Open vSwitch（OVS）命令行工具（ovs-appctl）的一个命令</span><br><span class="hljs-comment"># 用于显示指定绑定（bond）的状态信息。绑定是指将多个物理网络接口（NIC）组合成一个逻辑接口，以提高带宽和可用性</span><br><span class="hljs-comment"># bond/show 命令将显示绑定的名称、状态、绑定的物理接口等详细信息。</span><br>ovs-appctl bond/show<br><br><span class="hljs-comment"># 显示Open vSwitch上可用的链路聚合控制协议(Link Aggregation Control Protocol，LACP)的状态和统计信息</span><br><span class="hljs-comment"># 其中，&quot;ovs-appctl&quot;是Open vSwitch的一个管理工具，用于管理Open vSwitch的各个组件。&quot;lacp/show&quot;是该工具的一个子命令，用于显示LACP相关的信息</span><br><span class="hljs-comment"># 列出Open vSwitch上所有的链路聚合组及其成员端口、LACP协议状态、LACP协议计数器等信息，从而帮助管理员监控和诊断链路聚合组的状态和性能。</span><br><span class="hljs-comment"># 例如，可以使用该命令检查链路聚合组是否正常工作、成员端口是否正确配置和活动、链路聚合协议的运行状况等。</span><br>ovs-appctl lacp/show<br><br><br><span class="hljs-comment"># 默认bond_mode是active-backup就会出现上面的情况</span><br><span class="hljs-comment"># bond_mode设为balance-tcp\balance-slb</span><br><span class="hljs-comment"># ovs-vsctl工具设置一个名为bond1的端口的bond模式为balance-slb</span><br><span class="hljs-comment"># 意思是将bond1端口与其它物理端口进行绑定，以实现网络负载均衡的目的</span><br><span class="hljs-comment"># 当使用这种模式时，网络流量会被平均地分配到不同的物理端口上，从而提高网络传输效率和可靠性</span><br>ovs-vsctl <span class="hljs-built_in">set</span> Port bond1 bond_mode=balance-slb<br><br><br><span class="hljs-comment"># 这句话是指使用ovs-vsctl工具设置一个名为bond2的端口的bond模式为balance-tcp</span><br><span class="hljs-comment"># 意思是将bond2端口与其它物理端口进行绑定，以实现网络负载均衡的目的</span><br><span class="hljs-comment"># 当使用这种模式时，网络流量会被基于TCP会话的负载均衡算法分配到不同的物理端口上，从而提高网络传输效率和可靠性</span><br><span class="hljs-comment"># 与balance-slb相比，balance-tcp更加适用于长时间运行的TCP连接，可以保证连接的稳定性和可靠性。</span><br>ovs-vsctl <span class="hljs-built_in">set</span> Port bond2 bond_mode=balance-tcp<br></code></pre></td></tr></table></figure><p><img src="/images/bond.png" alt="bonding拓扑图示例"></p><h3 id="6-压测容器之间带宽"><a href="#6-压测容器之间带宽" class="headerlink" title="6.压测容器之间带宽"></a>6.压测容器之间带宽</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ns4 start iperf client</span><br>docker <span class="hljs-built_in">exec</span> -it ns4 iperf -s<br><br><span class="hljs-comment"># ns3 ping ns4</span><br>docker <span class="hljs-built_in">exec</span> -it ns3 sh -c <span class="hljs-string">&#x27;iperf -c 192.168.101.4 -p 5001 1 -t 20&#x27;</span><br><br><span class="hljs-comment"># 输出的带宽测试结果</span><br>iperf: ignoring extra argument -- 1<br>------------------------------------------------------------<br>Client connecting to 192.168.101.4, TCP port 5001<br>TCP window size: 16.0 KByte (default)<br>------------------------------------------------------------<br>[  1] <span class="hljs-built_in">local</span> 192.168.101.3 port 35702 connected with 192.168.101.4 port 5001<br>[ ID] Interval       Transfer     Bandwidth<br>[  1] 0.00-20.01 sec  75.8 GBytes  32.6 Gbits/sec<br></code></pre></td></tr></table></figure><h3 id="7-验证qos对流量限流"><a href="#7-验证qos对流量限流" class="headerlink" title="7.验证qos对流量限流"></a>7.验证qos对流量限流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># tap1-b2的网络接口上添加Traffic Control（TC）队列规则</span><br><span class="hljs-comment"># 使用HTB（Hierarchical Token Bucket）算法，将1号句柄作为根规则，并将12号句柄设置为默认规则</span><br>tc qdisc add dev peer-tab1 root handle 1: htb default 12<br><br><br><span class="hljs-comment"># 这句命令表示在peer-tab1设备上创建一个父类1,子类1:1，并且定义它们的带宽控制规则</span><br><span class="hljs-comment"># 其中htb表示采用层次令牌桶算法进行带宽控制</span><br><span class="hljs-comment"># rate表示限制该类最大可用的数据传输速率为100kbps，ceil表示该类最大可用带宽上限也为100kbps。</span><br>tc class add dev peer-tab1 parent 1: classid 1:1 htb rate 100kbps ceil 100kbps<br><br><span class="hljs-comment"># 在peer-tab1网卡上添加一个分类器，指定该分类器的父类别为1:1，类别ID为1:10，</span><br><span class="hljs-comment"># 采用htb算法进行流量控制，设定该类别的最大带宽为100kbps，</span><br><span class="hljs-comment"># 但是该类别的最小保障带宽为30kbps，即使存在其他高优先级流量，该类别的带宽也不低于30kbps。</span><br>tc class add dev peer-tab1 parent 1:1 classid 1:10 htb rate 30kbps ceil 100kbps<br>tc class add dev peer-tab1 parent 1:1 classid 1:11 htb rate 10kbps ceil 100kbps<br>tc class add dev peer-tab1 parent 1:1 classid 1:12 htb rate 60kbps ceil 100kbps<br>tc class show dev peer-tab1<br><br><br><span class="hljs-comment"># 这条命令是为名为 peer-tab1 的网络接口添加队列规则</span><br><span class="hljs-comment"># 在父队列1:10下创建一个子队列20:</span><br><span class="hljs-comment"># 该子队列的队列调度算法为pfifo（先进先出），队列长度的最大限制为5</span><br><span class="hljs-comment"># 这意味着如果队列中的分组数达到5，新的分组将被丢弃。</span><br>tc qdisc add dev peer-tab1 parent 1:10 handle 20: pfifo <span class="hljs-built_in">limit</span> 5<br>tc qdisc add dev peer-tab1 parent 1:11 handle 30: pfifo <span class="hljs-built_in">limit</span> 5<br>tc qdisc add dev peer-tab1 parent 1:12 handle 40: sfq perturb 10<br><br><br><span class="hljs-comment"># 为名为peer-tab1的网络接口添加过滤器规则</span><br><span class="hljs-comment"># 它将过滤器规则附加到1:0的父队列上，并设置过滤器规则的优先级为1</span><br><span class="hljs-comment"># 它使用u32匹配模式，匹配源IP地址为192.168.101.3和目标端口号为5001且屏蔽掉后4位（即对65520取模的余数）</span><br><span class="hljs-comment"># 并将匹配结果定向到子队列1:10上，这意味着所有匹配到该规则的流量都将进入子队列1:10中进行处理。</span><br>tc filter add dev peer-tab1 protocol ip parent 1:0 prio 1 u32 match ip src 192.168.101.3 match ip dport 5001 0xfff0 flowid 1:10<br><br><br><span class="hljs-comment"># 在peer-tab1网卡上添加一个过滤器，指定该过滤器的协议为ip，父类别为1:0，</span><br><span class="hljs-comment"># 优先级为1，u32代表使用32位的过滤条件，匹配源IP地址为192.168.101.4的流量，并将它们流向1:11类别。</span><br>tc filter add dev peer-tab1 protocol ip parent 1:0 prio 1 u32 match ip src 192.168.101.4 flowid 1:11<br><br><span class="hljs-comment"># 观察1:11流量</span><br>watch tc -s class <span class="hljs-built_in">ls</span> dev peer-tab1<br><br><span class="hljs-comment"># 压测速度</span><br><span class="hljs-comment"># 在名为ns3的容器中运行命令</span><br><span class="hljs-comment"># 命令是iperf客户端向IP地址为192.168.101.4，端口号为5001的服务器发送1个连接，并在20秒内进行带宽测试。</span><br>docker <span class="hljs-built_in">exec</span> -it ns3 sh -c <span class="hljs-string">&#x27;iperf -c 192.168.101.4 -p 5001 1 -t 20&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">ovs-vsctl list interface peer-tab1<br>ovs-vsctl list interface peer-tab2<br><br><span class="hljs-comment"># &quot;peer-tab1&quot;的网络接口的最大流入数据流量速率为1000字节/秒</span><br>ovs-vsctl <span class="hljs-built_in">set</span> interface peer-tab1 ingress_policing_rate=1000<br><br><span class="hljs-comment"># &quot;peer-tab1&quot;的网络接口的最大流入数据流量峰值为1000字节</span><br>ovs-vsctl <span class="hljs-built_in">set</span> interface peer-tab1 ingress_policing_burst=1000<br>ovs-vsctl <span class="hljs-built_in">set</span> interface peer-tab2 ingress_policing_rate=1000<br>ovs-vsctl <span class="hljs-built_in">set</span> interface peer-tab2 ingress_policing_burst=1000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 限速之后</span><br>$ docker <span class="hljs-built_in">exec</span> -it ns3 sh -c <span class="hljs-string">&#x27;iperf -c 192.168.101.4 -p 5001 1 -t 20&#x27;</span><br><br><br>iperf: ignoring extra argument -- 1<br>------------------------------------------------------------<br>Client connecting to 192.168.101.4, TCP port 5001<br>TCP window size: 16.0 KByte (default)<br>------------------------------------------------------------<br>[  1] <span class="hljs-built_in">local</span> 192.168.101.3 port 36444 connected with 192.168.101.4 port 5001<br>[ ID] Interval       Transfer     Bandwidth<br>[  1] 0.00-26.17 sec  3.13 MBytes  1.00 Mbits/sec<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 取消限速</span><br>ovs-vsctl <span class="hljs-built_in">set</span> interface tap1-qos ingress_policing_burst=0<br>ovs-vsctl <span class="hljs-built_in">set</span> interface tap1-qos ingress_policing_rate=0<br>ovs-vsctl list interface tap1-qos<br></code></pre></td></tr></table></figure><h3 id="8-Egress-shaping分流"><a href="#8-Egress-shaping分流" class="headerlink" title="8.Egress shaping分流"></a>8.Egress shaping分流</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">ovs-vsctl list qos<br>ovs-vsctl list queue<br>ovs-ofctl show ovs-br1<br>ovs-ofctl show ovs-br2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置端口tap2-qos的QoS策略</span><br><span class="hljs-comment"># 使用linux-htb类型的QoS策略，设置最大速率为10Gbps，并设置三个队列，分别为@q0、@q1、@q2</span><br><span class="hljs-comment"># @q0的最小速率和最大速率均为30Mbps，@q1的最小速率和最大速率均为10Mbps，@q2的最小速率和最大速率均为60Mbps</span><br>ovs-vsctl <span class="hljs-built_in">set</span> port tap2-qos qos=@newqos -- \<br>--<span class="hljs-built_in">id</span>=@newqos create qos <span class="hljs-built_in">type</span>=linux-htb other-config:max-rate=10000000000 queues=0=@q0,1=@q1,2=@q2 -- \<br>--<span class="hljs-built_in">id</span>=@q0 create queue other-config:min-rate=30000000 other-config:max-rate=30000000 -- \<br>--<span class="hljs-built_in">id</span>=@q1 create queue other-config:min-rate=10000000 other-config:max-rate=10000000 -- \<br>--<span class="hljs-built_in">id</span>=@q2 create queue other-config:min-rate=60000000 other-config:max-rate=60000000<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置流表规则</span><br><span class="hljs-comment"># OVS（Open vSwitch）的 ovs-br1 交换机上添加一条流表项</span><br><span class="hljs-comment"># 具体的含义是，当收到输入端口为1（in_port=1）且源 IP 地址为192.168.101.3的数据包时</span><br><span class="hljs-comment"># 将该数据包发往端口4（enqueue:4:0）</span><br><span class="hljs-comment"># 并且将该数据包的 VLAN ID 设置为0</span><br><span class="hljs-comment"># 也就是说，这条流表项告诉交换机</span><br><span class="hljs-comment"># 将源 IP 地址为 192.168.101.3 的数据包发送到端口 4。</span><br><span class="hljs-comment"># 这个命令的实际效果是实现了对特定源地址的流量控制，将该流量限制在特定的输出端口上。</span><br>ovs-ofctl add-flow ovs-br1 <span class="hljs-string">&quot;in_port=1,nw_src=192.168.101.3 actions=enqueue:4:0&quot;</span><br>ovs-ofctl add-flow ovs-br1 <span class="hljs-string">&quot;in_port=1,nw_src=192.168.101.4 actions=enqueue:4:1&quot;</span><br>ovs-ofctl add-flow ovs-br1 <span class="hljs-string">&quot;in_port=3,nw_src=192.168.101.5 actions=enqueue:4:2&quot;</span><br><br><br><span class="hljs-comment"># 分别压测带宽下面的</span><br>ns2 &amp;&amp; ns3<br>ns2 &amp;&amp; ns4<br>ns2 &amp;&amp; ns5<br><br><span class="hljs-comment"># 得出带宽大小比符合上面设置的QoS策略: 30Mbps:10Mbps:60Mbps</span><br>3:1:6<br><br><span class="hljs-comment"># 自动清理(推荐)</span><br>ovs-vsctl -- --all destroy QoS -- --all destroy Queue<br><br><span class="hljs-comment"># 手动清理</span><br>ovs-vsctl clear port tap2-qos qos<br>ovs-vsctl list qos<br>ovs-vsctl destroy qos xxxx<br>ovs-vsctl list queue<br>ovs-vsctl destroy queue xxx<br>ovs-vsctl destroy queue xxx<br>ovs-vsctl destroy queue xxx<br>ovs-vsctl list queue<br>ovs-ofctl del-flows br2 &amp;&amp; ovs-ofctl add-flow br2 <span class="hljs-string">&quot;priority=0 actions=NORMAL&quot;</span><br></code></pre></td></tr></table></figure><h3 id="9-上述的拓扑图"><a href="#9-上述的拓扑图" class="headerlink" title="9. 上述的拓扑图"></a>9. 上述的拓扑图</h3><p><img src="/images/experiment9_1.png" alt="Qos - bond逻辑网卡和tc过滤器"><br><img src="/images/experiment10_2.png" alt="Qos - Hierarchical Token Bucket令牌桶算法的qdisc"><br><img src="/images/experiment10_4.png" alt="ovs-qos - qos规则压测带宽"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>tc qdisc add dev peer-tab1 parent 1:10 handle 20: pfifo limit 5 这句话什么意思</li></ol><p>这句话是 Linux 中的网络命令，用于添加一个队列规则。具体解释如下：</p><ul><li>tc：网络命令的关键字，表示 Traffic Control。</li><li>qdisc：Queueing Discipline 的缩写，表示队列规则。</li><li>add：表示添加一个新的队列规则。</li><li>dev peer-tab1：指定规则所适用的网络接口名称，这里是 peer-tab1。</li><li>parent 1:10：指定父队列的 ID，这里是 1:10，表示这个规则是属于 ID 为 1:10 的父队列下的子队列。</li><li>handle 20:：指定队列的标识符，这里是 20。</li><li>pfifo：选择了一种队列算法，即先进先出队列（Priority-based First-In, First-Out）。</li><li>limit 5：指定队列最大容量为 5 个数据包。如果队列已满，新来的数据包将被丢弃。</li></ul><ol start="2"><li>tc定义队列规则有什么用</li></ol><p>  TC（Traffic Control）定义队列规则的作用是为了控制网络流量，防止网络拥塞，保证网络服务的质量和稳定性。通过设置队列规则，可以限制网络中各种流量（如数据包大小、传输速率等）的数量和优先级，以确保不同类型的流量能够有序地传输，并且不会对其他流量产生影响。这对于网络管理员来说是非常重要的管理工具，可以帮助管理员更好地控制网络流量，保证网络的正常运行。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://zhuanlan.zhihu.com/p/449755341">linux tc流量控制（一）：classless qdisc</a></p>]]></content>
    
    
    <categories>
      
      <category>openvswitch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch之flowTable&amp;tag&amp;bonding</title>
    <link href="/2023/06/14/cni/openvswitch%E4%B9%8BflowTable&amp;tag&amp;bonding/"/>
    <url>/2023/06/14/cni/openvswitch%E4%B9%8BflowTable&amp;tag&amp;bonding/</url>
    
    <content type="html"><![CDATA[<h3 id="一、实验环境准备"><a href="#一、实验环境准备" class="headerlink" title="一、实验环境准备"></a>一、实验环境准备</h3><p><a href="https://weiqiangxu.github.io/2023/06/14/cni/ovs%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/">ovs实验基础环境</a></p><h3 id="二、ovs的flow-table丢弃icmp数据包"><a href="#二、ovs的flow-table丢弃icmp数据包" class="headerlink" title="二、ovs的flow table丢弃icmp数据包"></a>二、ovs的flow table丢弃icmp数据包</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 来体验一下流表规则的作用</span><br><br><span class="hljs-comment"># OVS网桥ovs-br1上添加流规则</span><br><span class="hljs-comment"># 当接收到的数据包是ICMP协议类型，并且其输入端口为3(ns4的pair端口)时，将该数据包丢弃（即不处理，不向其他端口转发）</span><br><span class="hljs-comment"># 该流规则的优先级为3</span><br><span class="hljs-comment"># 通过 ovs-ofctl show ovs-br1 可以查看ovs桥上面的1\2\3端口是什么</span><br>ovs-ofctl add-flow ovs-br1 icmp,priority=3,in_port=3,actions=drop<br><br><br><span class="hljs-comment"># 查看ovs桥</span><br>ovs-ofctl dump-flows ovs-br1<br> cookie=0x0, duration=68.798s, table=0, n_packets=2, n_bytes=196, priority=3,icmp,in_port=<span class="hljs-string">&quot;veth1-ns4&quot;</span> actions=drop <span class="hljs-comment"># 新增的网络流表</span><br> cookie=0x0, duration=1628.095s, table=0, n_packets=10, n_bytes=756, priority=0 actions=NORMAL<br><br><span class="hljs-comment"># 添加以后ping不通ns1了</span><br><span class="hljs-comment"># docker exec -it ns2  ping $&#123;ns4_ip&#125;</span><br>docker <span class="hljs-built_in">exec</span> -it ns2  ping 192.168.101.4<br><br><span class="hljs-comment"># ns2 ping ns3 的时候输入端口是3那么不会丢弃报文</span><br>docker <span class="hljs-built_in">exec</span> -it ns2  ping 192.168.101.3<br><br>PING 192.168.101.3 (192.168.101.3): 56 data bytes<br>64 bytes from 192.168.101.3: <span class="hljs-built_in">seq</span>=0 ttl=64 time=0.075 ms<br>64 bytes from 192.168.101.3: <span class="hljs-built_in">seq</span>=1 ttl=64 time=0.062 ms<br><br><br><span class="hljs-comment"># 删除刚刚添加的流表规则 &lt;keyword匹配规则即可&gt;</span><br><span class="hljs-comment"># ovs-ofctl del-flows ovs-br1 &lt;keyword&gt;</span><br>ovs-ofctl del-flows ovs-br1 <span class="hljs-string">&quot;in_port=veth1-ns4&quot;</span><br><br><span class="hljs-comment"># 删除所有流表 - 会导致所有无法通讯</span><br>ovs-ofctl del-flows ovs-br1<br></code></pre></td></tr></table></figure><h3 id="三、ovs的Port-mirroring端口镜像复制端口输入和输出流量至其他端口"><a href="#三、ovs的Port-mirroring端口镜像复制端口输入和输出流量至其他端口" class="headerlink" title="三、ovs的Port mirroring端口镜像复制端口输入和输出流量至其他端口"></a>三、ovs的Port mirroring端口镜像复制端口输入和输出流量至其他端口</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在上面的环境之中将ovs网桥ovs-br1上面的3个插口全部拔出</span><br><span class="hljs-comment"># ovs-vsctl del-port &lt;bridge&gt; &lt;port&gt;</span><br>ovs-vsctl del-port ovs-br1 veth1-ns1<br>ovs-vsctl del-port ovs-br1 veth1-ns2<br>ovs-vsctl del-port ovs-br1 veth1-ns3<br><br><span class="hljs-comment"># 重新将网卡插上并且打上tag</span><br>ovs-vsctl add-port ovs-br1 veth1-ns1 -- <span class="hljs-built_in">set</span> Port veth1-ns1 tag=110<br>ovs-vsctl add-port ovs-br1 veth1-ns2 -- <span class="hljs-built_in">set</span> Port veth1-ns2 tag=110<br>ovs-vsctl add-port ovs-br1 veth1-ns3 -- <span class="hljs-built_in">set</span> Port veth1-ns3 tag=110<br><br>ovs-vsctl list mirror<br>ovs-vsctl show<br><br><br><span class="hljs-comment"># 语法将 vlan 下的所有流量镜像输出到 output-port</span><br>ovs-vsctl <span class="hljs-built_in">set</span> Bridge &lt;bridge&gt; mirrors=@m -- --<span class="hljs-built_in">id</span>=@&lt;mirror&gt; create Mirror name=&lt;mirror_name&gt; select-all=<span class="hljs-literal">true</span> select-vlan=&lt;vlan_id&gt; output-port=&lt;mirror_port&gt;<br><br><span class="hljs-comment"># 创建一个名为“m1”的镜像，并将其名称分配给变量“@m”。 </span><br><span class="hljs-comment"># 然后，它创建两个&quot;id&quot;，分别为“@veth1-ns1”和“@veth1-ns4”，这两个&quot;id&quot;指定了要镜像的端口</span><br><span class="hljs-comment"># 接下来，命令使用这些&quot;id&quot;来设置镜像规则。</span><br><span class="hljs-comment"># 它选择数据包的目标端口，并将其复制到输出端口“@veth1-ns3”</span><br><span class="hljs-comment"># 同时选择“veth1-ns1”端口作为源地址。这意味着所有发送到“veth1-ns1”的数据包都将被复制到“veth1-ns3”。</span><br>ovs-vsctl -- <span class="hljs-built_in">set</span> bridge br1 mirrors=@m \<br>          -- --<span class="hljs-built_in">id</span>=@veth1-ns1 get Port veth1-ns1 \<br>          -- --<span class="hljs-built_in">id</span>=@veth1-ns2 get Port veth1-ns2 \<br>          -- --<span class="hljs-built_in">id</span>=@m create Mirror name=m1 select-dst-port=@veth1-ns1 select-src-port=@veth1-ns1 output-port=@veth1-ns3<br><br><br><span class="hljs-comment"># select-dst-port用于匹配数据包的目的地端口，选择应该将数据包发送到哪个端口。</span><br><span class="hljs-comment"># select-src-port用于匹配数据包的源端口，选择哪个端口接收数据包</span><br><br><span class="hljs-comment"># 监听网卡 output-port 也就是 veth1-ns3</span><br>tcpdump -nei veth1-ns3<br><br><span class="hljs-comment"># ns1 ping ns2 , 查看流量是否 mirro 到 veth1-ns3</span><br>docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$&#123;ns1_id&#125;</span> ping <span class="hljs-variable">$&#123;ns2_ip&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置 Open vSwitch 网桥（bridge） ovs-br1 的镜像规则</span><br><span class="hljs-comment"># 创建了一个名为 m1 的镜像规则，将 veth1-ns2 端口的流量作为镜像目标（select-dst-port），并将同样的流量作为镜像源（select-src-port）；</span><br><span class="hljs-comment"># 为了将镜像流量和普通流量区分开来，还将镜像流量打上 VLAN 110 的标签（output-vlan）。</span><br>ovs-vsctl -- <span class="hljs-built_in">set</span> bridge ovs-br1 mirrors=@m2 \<br>          -- --<span class="hljs-built_in">id</span>=@veth1-ns1 get Port veth1-ns1 \<br>          -- --<span class="hljs-built_in">id</span>=@m2 create Mirror name=m1 select-dst-port=@veth1-ns2 select-src-port=@veth1-ns2 output-vlan=111<br><br><br><span class="hljs-comment"># 设置 Open vSwitch 网桥（bridge） br2 的镜像规则</span><br><span class="hljs-comment"># 创建了一个名为 m3 的镜像规则，将选取 VLAN ID 为 110 的流量作为镜像源（select-vlan）</span><br><span class="hljs-comment"># 并将同样的流量打上 VLAN 110 的标签作为镜像流量（output-vlan）</span><br><span class="hljs-comment"># 将这个镜像规则赋值给 mirrors 属性，即将该规则应用于 ovs-br1 上。</span><br>ovs-vsctl -- <span class="hljs-built_in">set</span> bridge ovs-br1 mirrors=@m \<br>          -- --<span class="hljs-built_in">id</span>=@m create Mirror name=m3 select-vlan=110 output-vlan=110<br><br><br><span class="hljs-comment"># 1. 指定洪泛的VLAN ID，使bridge只会向这些VLAN上的所有端口广播，而不会向其他VLAN广播。</span><br><span class="hljs-comment"># 2. 在多个VLAN之间提供隔离，从而限制数据包传播的范围。</span><br><span class="hljs-comment"># 3. 支持多租户场景下的VLAN隔离，不同租户可以独立使用自己的VLAN。</span><br><span class="hljs-comment"># 4. 防止恶意攻击者利用洪泛攻击来干扰网络的正常运行。</span><br><span class="hljs-comment">#VLAN隔离和洪泛控制</span><br>ovs-vsctl <span class="hljs-built_in">set</span> bridge br1 flood-vlans=110<br><br><span class="hljs-comment"># 监听网卡 veth1-ns4</span><br>tcpdump -nei veth1-ns4<br><br><span class="hljs-comment"># ns2 ping ns3</span><br>docker <span class="hljs-built_in">exec</span> -it <span class="hljs-variable">$&#123;ns2_id&#125;</span> ping &lt;ns3_ip&gt;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 环境清理</span><br>ovs-vsctl clear bridge ovs-br1 mirrors<br>ovs-vsctl clear bridge ovs-br1 mirrors<br></code></pre></td></tr></table></figure><h3 id="四、tag设置相同bridge下的不同vlan无法通信"><a href="#四、tag设置相同bridge下的不同vlan无法通信" class="headerlink" title="四、tag设置相同bridge下的不同vlan无法通信"></a>四、tag设置相同bridge下的不同vlan无法通信</h3><p><a href="https://weiqiangxu.github.io/2023/06/14/cni/ovs%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/">ovs实验基础环境</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在上面的环境之中将ovs网桥ovs-br1上面的3个插口全部拔出</span><br><span class="hljs-comment"># ovs-vsctl del-port &lt;bridge&gt; &lt;port&gt;</span><br>ovs-vsctl del-port ovs-br1 veth1-ns2<br>ovs-vsctl del-port ovs-br1 veth1-ns3<br>ovs-vsctl del-port ovs-br1 veth1-ns4<br>ovs-vsctl del-port ovs-br1 veth1-ns4<br><br><span class="hljs-comment"># 重新将网卡插上并且打上tag</span><br>ovs-vsctl add-port ovs-br1 veth1-ns2<br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns2 tag=100<br><br>ovs-vsctl add-port ovs-br1 veth1-ns3<br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns3 tag=100<br><br>ovs-vsctl add-port ovs-br1 veth1-ns4<br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns4 tag=111<br><br>ovs-vsctl add-port ovs-br1 veth1-ns5<br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns5 tag=111<br><br><span class="hljs-comment"># 从 ns2 ping ns3</span><br><span class="hljs-comment"># docker exec -it $&#123;ns2_id&#125; ping &lt;ns3_ip&gt;</span><br><span class="hljs-comment"># 可以ping通</span><br>docker <span class="hljs-built_in">exec</span> -it ns2 ping 192.168.101.3<br><br><span class="hljs-comment"># ns2 ping ns4</span><br><span class="hljs-comment"># 无法ping通过因为他们分别属于不同的tag也是不同的vlan</span><br>docker <span class="hljs-built_in">exec</span> -it ns2 ping 192.168.101.4<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 下发流表(直接指定源端口和目标端口)使可以ping通</span><br>ovs-ofctl add-flow ovs-br1 in_port=veth1-ns3,action=output:veth1-ns4<br>ovs-ofctl add-flow ovs-br1 in_port=veth1-ns4,action=output:veth1-ns3<br>docker <span class="hljs-built_in">exec</span> -it ns3 ping 192.168.101.4        <span class="hljs-comment"># ns3 ping ns4</span><br>ovs-ofctl del-flows ovs-br1 in_port=veth1-ns3 <span class="hljs-comment"># 删除流表</span><br>ovs-ofctl del-flows ovs-br1 in_port=veth1-ns4 <span class="hljs-comment"># 删除流表</span><br>ovs-ofctl dump-flows ovs-br1<br><br><br><span class="hljs-comment"># 2.下发流表(去掉VLAN标签再匹配)也可以实现不同vlan的port通讯</span><br>ovs-ofctl add-flow ovs-br1 priority=20,in_port=veth1-ns3,nw_dst=192.168.101.4,actions=strip_vlan,output:veth1-ns4<br>ovs-ofctl add-flow ovs-br1 priority=20,in_port=veth1-ns4,nw_dst=192.168.101.3,actions=strip_vlan,output:veth1-ns3<br>ovs-ofctl dump-flows ovs-br1<br>docker <span class="hljs-built_in">exec</span> -it ns3 ping 192.168.101.4 <br>PING 192.168.101.4 (192.168.101.4): 56 data bytes<br>64 bytes from 192.168.101.4: <span class="hljs-built_in">seq</span>=0 ttl=64 time=0.415 ms<br>64 bytes from 192.168.101.4: <span class="hljs-built_in">seq</span>=1 ttl=64 t<br>...<br>ovs-ofctl del-flows ovs-br1 in_port=veth1-ns3<br>ovs-ofctl del-flows ovs-br1 in_port=veth1-ns4<br></code></pre></td></tr></table></figure><h3 id="五、flood-vlans"><a href="#五、flood-vlans" class="headerlink" title="五、flood-vlans"></a>五、flood-vlans</h3><p><a href="https://weiqiangxu.github.io/2023/06/14/cni/ovs%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/">ovs实验基础环境</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs bash">ovs-vsctl add-br ovs-br2<br><br><span class="hljs-comment"># 将3和4拔出</span><br>ovs-vsctl del-port ovs-br1 veth1-ns4<br>ovs-vsctl del-port ovs-br1 veth1-ns5<br><br><span class="hljs-comment"># 将3和4插入br2</span><br>ovs-vsctl add-port ovs-br2 veth1-ns4<br>ovs-vsctl add-port ovs-br2 veth1-ns5<br><br><span class="hljs-comment"># ns2 ping ns3</span><br><span class="hljs-comment"># 可以通讯,两个端口插在同一个网桥br1</span><br>docker <span class="hljs-built_in">exec</span> -it ns3 tcpdump -nei eth0<br>docker <span class="hljs-built_in">exec</span> -it ns2 ping 192.168.101.3<br><br><span class="hljs-comment"># ns3 ping ns4</span><br><span class="hljs-comment"># 无法通讯 - 因为端口插在不同的bridge上</span><br>docker <span class="hljs-built_in">exec</span> -it ns4 tcpdump -nei eth0<br>docker <span class="hljs-built_in">exec</span> -it ns3 ping 192.168.101.4<br><br><span class="hljs-comment"># 将ns4的veth从网桥br2拔除插入br1</span><br>ovs-vsctl del-port ovs-br2 veth1-ns4<br>ovs-vsctl add-port ovs-br1 veth1-ns4<br><br><span class="hljs-comment"># 监听网卡ns4</span><br>docker <span class="hljs-built_in">exec</span> -it ns4 tcpdump -nei eth0<br><span class="hljs-comment"># ns2 ping ns3</span><br>docker <span class="hljs-built_in">exec</span> -it ns2 ping 192.168.101.3<br><span class="hljs-comment"># 此时 ns4 没有任何 ARP 包</span><br><span class="hljs-comment"># 也就是说此时 ns2 广播出去 ns3 的ARP报文不会传播到ns4</span><br><br><br><span class="hljs-comment"># 网桥允许洪泛（即广播）的 VLAN ID 列表为 100</span><br><span class="hljs-comment"># 也就是VLAN 100的数据包才会被洪泛到ovs-br1的所有端口，其他VLAN的数据包则不会被洪泛</span><br><span class="hljs-comment"># 在Open vSwitch中设置名称为&quot;ovs-br1&quot;的网桥支持洪泛（flood）VLAN 110和111</span><br><span class="hljs-comment"># 作用是在VLAN架构中使用洪泛技术向所有主机广播数据包</span><br><span class="hljs-comment"># 由于洪泛可能会导致网络中的广播风暴，因此只有在局域网或者小规模网络中才应该使用</span><br><span class="hljs-comment"># 洪泛技术可以使网络中所有的设备都能够接收到广播数据包，从而实现网络通信</span><br><span class="hljs-comment"># 设置了 ovs-br1 网桥允许洪泛（即广播）的 VLAN ID 列表为 110 和 111</span><br><span class="hljs-comment"># ovs-vsctl set bridge ovs-br1 flood-vlans=110,111</span><br>ovs-vsctl <span class="hljs-built_in">set</span> bridge ovs-br1 flood-vlans=100<br><span class="hljs-comment"># 教你如何清空</span><br>ovs-vsctl <span class="hljs-built_in">set</span> bridge ovs-br1 flood-vlans=[]<br><br><span class="hljs-comment"># 给ns2\ns3\ns4全部打上tag为100也就是vlan是100</span><br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns2 tag=100<br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns3 tag=100<br>ovs-vsctl <span class="hljs-built_in">set</span> port veth1-ns4 tag=100<br><br><span class="hljs-comment"># 重新监听ns4</span><br>docker <span class="hljs-built_in">exec</span> -it ns4 tcpdump -nei eth0<br><span class="hljs-comment"># ns2 ping ns3</span><br>docker <span class="hljs-built_in">exec</span> -it ns2 ping 192.168.101.3<br><br><span class="hljs-comment"># 此时ns4可以监听ns2 &amp;&amp; ns3 的ARP广播</span><br>ethertype ARP, Request who-has 192.168.101.2 tell 192.168.101.3, length 28<br>ethertype ARP, Reply 192.168.101.2 is-at 02:42:c0:a8:65:02, length 28<br>ethertype ARP, Request who-has 192.168.101.3 tell 192.168.101.2, length 28<br>ethertype ARP, Reply 192.168.101.3 is-at 02:42:c0:a8:65:03, length 28<br><br><br><span class="hljs-comment"># 此时清空允许洪泛（即广播）VLAN ID</span><br>ovs-vsctl get bridge ovs-br1 flood-vlans<br>ovs-vsctl <span class="hljs-built_in">set</span> bridge ovs-br1 flood-vlans=[]<br>ovs-vsctl get bridge ovs-br1 flood-vlans<br><br><br><span class="hljs-comment"># 重新监听</span><br>docker <span class="hljs-built_in">exec</span> -it ns4 tcpdump -nei eth0<br>docker <span class="hljs-built_in">exec</span> -it ns2 ping 192.168.101.3<br><br><span class="hljs-comment"># 此时，ns4的eth0并没有监听到 ns2 &amp;&amp; ns3 的ARP报文</span><br><br><span class="hljs-comment"># 如何清除端口tag</span><br>ovs-vsctl clear port veth1-ns1 tag<br></code></pre></td></tr></table></figure><h3 id="六、trunks"><a href="#六、trunks" class="headerlink" title="六、trunks"></a>六、trunks</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置 ns3 的对端网卡 veth1-ns3 </span><br><span class="hljs-comment"># 可以接收和发送 VLAN ID 为 110 的网络流量 （VLAN ID为100的也可以但是不会将将流量标记为 110）</span><br>ovs-vsctl <span class="hljs-built_in">set</span> Port veth1-ns3 trunks=110<br>ovs-vsctl <span class="hljs-built_in">set</span> Port veth1-ns3 trunks=[]<br></code></pre></td></tr></table></figure><h3 id="七、Bonding"><a href="#七、Bonding" class="headerlink" title="七、Bonding"></a>七、Bonding</h3><p><a href="https://weiqiangxu.github.io/2023/06/14/cni/ovs%E5%AE%9E%E9%AA%8C%E5%9F%BA%E7%A1%80%E7%8E%AF%E5%A2%83/">ovs实验基础环境</a></p><blockquote><p>OVS 的 bond 绑定多个物理网卡成一个逻辑网卡，可以提高网络的可靠性和带宽的实现</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启网卡</span><br>ip <span class="hljs-built_in">link</span> add tab1 <span class="hljs-built_in">type</span> veth peer name peer-tab1<br>ip <span class="hljs-built_in">link</span> add tab2 <span class="hljs-built_in">type</span> veth peer name peer-tab2<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tab1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-tab1 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> tab2 up<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-tab2 up<br><br><span class="hljs-comment"># 创建一个名为&quot;bond1&quot;的链路聚合组(bond)</span><br><span class="hljs-comment"># 并将两个网络命名空间中的虚拟网卡&quot;veth1-ns2&quot;和&quot;veth1-ns3&quot;与该链路聚合组绑定，从而实现高可用性和负载均衡</span><br>ovs-vsctl add-bond ovs-br1 bond1 tab1 tab2<br><br><span class="hljs-comment"># 创建一个名为&quot;bond2&quot;的链路聚合组(bond)</span><br><span class="hljs-comment"># 并将两个网络命名空间中的虚拟网卡&quot;veth1-ns4&quot;和&quot;veth1-ns5&quot;与该链路聚合组绑定，从而实现高可用性和负载均衡</span><br>ovs-vsctl add-bond ovs-br2 bond2 peer-tab1 peer-tab2<br><br><span class="hljs-comment"># 在ovs-br1交换机中，将名称为&quot;bond1&quot;的链路聚合组(bond)的LACP协议设置为主动模式(active)</span><br><span class="hljs-comment"># LACP为链路聚合控制协议(Link Aggregation Control Protocol)的缩写</span><br><span class="hljs-comment"># 它用于在链路聚合组成员之间进行协商和控制，以确保链路聚合组的高可用性和负载均衡。</span><br><span class="hljs-comment"># 在主动模式下，链路聚合组成员会发送LACP协议数据单元，与其他成员进行协商和控制，以建立和维护链路聚合组。这样可以更好地保证链路聚合组的可靠性和性能。</span><br>ovs-vsctl <span class="hljs-built_in">set</span> port bond1 lacp=active<br>ovs-vsctl <span class="hljs-built_in">set</span> port bond2 lacp=active<br><br><span class="hljs-comment"># Open vSwitch（OVS）命令行工具（ovs-appctl）的一个命令</span><br><span class="hljs-comment"># 用于显示指定绑定（bond）的状态信息。绑定是指将多个物理网络接口（NIC）组合成一个逻辑接口，以提高带宽和可用性</span><br><span class="hljs-comment"># bond/show 命令将显示绑定的名称、状态、绑定的物理接口等详细信息。</span><br>ovs-appctl bond/show<br><br><span class="hljs-comment"># 显示Open vSwitch上可用的链路聚合控制协议(Link Aggregation Control Protocol，LACP)的状态和统计信息</span><br><span class="hljs-comment"># 其中，&quot;ovs-appctl&quot;是Open vSwitch的一个管理工具，用于管理Open vSwitch的各个组件。&quot;lacp/show&quot;是该工具的一个子命令，用于显示LACP相关的信息</span><br><span class="hljs-comment"># 列出Open vSwitch上所有的链路聚合组及其成员端口、LACP协议状态、LACP协议计数器等信息，从而帮助管理员监控和诊断链路聚合组的状态和性能。</span><br><span class="hljs-comment"># 例如，可以使用该命令检查链路聚合组是否正常工作、成员端口是否正确配置和活动、链路聚合协议的运行状况等。</span><br>ovs-appctl lacp/show<br><br><br><span class="hljs-comment"># 此时 ns4 到 ns2的流量走向是 </span><br><span class="hljs-comment"># ns4 -&gt; ns4.eth0 -&gt; ns4.veth1-ns4 -&gt; ovs-br2 -&gt; (peer-tab1 peer-tab2)</span><br><span class="hljs-comment"># 当peer-tab1位active的时候流量默认会从peer-tab1经过</span><br><span class="hljs-comment"># 当peer-tab1 down的时候流量会从peer-tab2走过</span><br><br><span class="hljs-comment"># ns4 ping ns2</span><br>docker <span class="hljs-built_in">exec</span> -it ns4 ping 192.168.101.2<br><br><span class="hljs-comment"># 监听peer-tab2</span><br><span class="hljs-comment"># 此时流量经过peer-tab1所以peer-tab2没有抓包到ICMP</span><br>tcpdump -nei peer-tab2<br><br><span class="hljs-comment"># down tab1-b2</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-tab1 down<br><br><span class="hljs-comment"># 此时再次抓包</span><br><span class="hljs-comment"># 可以抓到ICMP</span><br>tcpdump -nei peer-tab2<br><br><br><span class="hljs-comment"># 默认bond_mode是active-backup就会出现上面的情况</span><br><span class="hljs-comment"># bond_mode设为balance-tcp\balance-slb</span><br><br><span class="hljs-comment"># ovs-vsctl工具设置一个名为bond1的端口的bond模式为balance-slb</span><br><span class="hljs-comment"># 意思是将bond1端口与其它物理端口进行绑定，以实现网络负载均衡的目的</span><br><span class="hljs-comment"># 当使用这种模式时，网络流量会被平均地分配到不同的物理端口上，从而提高网络传输效率和可靠性</span><br>ovs-vsctl <span class="hljs-built_in">set</span> Port bond1 bond_mode=balance-slb<br><br><br><span class="hljs-comment"># 这句话是指使用ovs-vsctl工具设置一个名为bond2的端口的bond模式为balance-tcp</span><br><span class="hljs-comment"># 意思是将bond2端口与其它物理端口进行绑定，以实现网络负载均衡的目的</span><br><span class="hljs-comment"># 当使用这种模式时，网络流量会被基于TCP会话的负载均衡算法分配到不同的物理端口上，从而提高网络传输效率和可靠性</span><br><span class="hljs-comment"># 与balance-slb相比，balance-tcp更加适用于长时间运行的TCP连接，可以保证连接的稳定性和可靠性。</span><br>ovs-vsctl <span class="hljs-built_in">set</span> Port bond2 bond_mode=balance-tcp<br></code></pre></td></tr></table></figure><p><img src="/images/bond.png" alt="bonding拓扑图示例"></p><h3 id="八、术语"><a href="#八、术语" class="headerlink" title="八、术语"></a>八、术语</h3><ol><li><p>Bridge<br>中文名称网桥，一个Bridge代表一个以太网交换机（Switch），一台主机中可以创建一个或多个Bridge，Bridge可以根据一定的规则，把某一个端口接收到的数据报文转发到另一个或多个端口上，也可以修改或者丢弃数据报文。</p></li><li><p>Port<br> 中文名称端口，需要注意的是它和TCP里面的端口不是同样的概念，它更像是物理交换机上面的插口，可以接水晶头的那种。Port隶属于Bridge，必须先添加了Bridge才能在Bridge上添加Port。Port有以下几种类型：</p><ul><li><p>Normal<br>  用户可以把操作系统中已有的网卡添加到Open vSwitch上，Open vSwitch会自动生成一个同名的Port开处理这张网卡进和出的数据报文。<br>  不过需要注意的是这种方式添加的Port不支持分配IP地址，如果之前网卡上配置的有IP，挂载到OVS上面之后将不可访问。此类型的Port常用于VLAN模式的多台物理主机相连的那个口，交换机一端属于Trunk模式。</p></li><li><p>Internal<br>  当Port的类型是Internal时，OVS会自动创建一个虚拟网卡（Interface），此端口收到的数据报文都会转发给这块网卡，从这块网卡发出的数据报文也会通过Port交给OVS处理。当OVS创建一个新的网桥时，会自动创建一个与网桥同名的Internal Port，同时也会创建一个与网桥同名的Interface，因此可以通过ip命令在操作系统中查看到这张虚拟网卡，但是状态是down的。</p></li><li><p>Patch<br>  Patch Port和veth pair功能相同，总是成双成对的出现，在其中一端收到的数据报文会被转发到另一个Patch Port上，就像是一根网线一样。Patch Port常用于连接两个Bridge，这样两个网桥就和一个网桥一样了。</p></li><li><p>Tunnel<br>OVS 支持 GRE、VXLAN、STT、Geneve和IPsec隧道协议，这些隧道协议就是overlay网络的基础协议，通过对物理网络做的一层封装和扩展，解决了二层网络数量不足的问题，最大限度的减少对底层物理网络拓扑的依赖性，同时也最大限度的增加了对网络的控制。</p></li></ul></li><li><p>Interface<br>iface&#x2F;接口，接口是OVS与操作系统交换数据报文的组件，一个接口即是操作系统上的一块网卡，这个网卡可能是OVS生成的虚拟网卡，也有可能是挂载在OVS上的物理网卡，操作系统上的虚拟网卡（TUN&#x2F;TAP）也可以被挂载在OVS上。</p></li><li><p>Controller<br> OpenFlow控制器，OVS可以接收一个或者多个OpenFlow控制器的管理，功能主要是下发流表，控制转发规则。</p></li><li><p>Flow<br>流表是OVS进行数据转发的核心功能，定义了端口之间转发数据报文的规则，一条流表规则主要分为匹配和动作两部分，匹配部分决定哪些数据报文需要被处理，动作决定了匹配到的数据报文该如何处理。</p></li></ol><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li><p>开启洪泛和 MAC 学习什么关系</p><p> 开启洪泛（Flood）是一种网络攻击手段，可以让网络中的所有数据包都被广播，从而导致网络拥塞甚至瘫痪。<br> 禁止MAC学习是一种网络安全配置策略，可以限制网络中的MAC地址学习，防止网络中的恶意设备伪装成其他合法设备进行攻击。</p></li></ul><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://zhuanlan.zhihu.com/p/37852626">基于openvswitch实现的openshit-sdn</a><br><a href="https://blog.csdn.net/kjh2007abc/article/details/86751730">kubernetes 网络组件简介（Flannel &amp; Open vSwitch &amp; Calico）</a><br><a href="https://zhuanlan.zhihu.com/p/336487371">Open vSwitch 入门实践（1）简介 - 关于术语写的很好</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker搭建loki &amp;&amp; promtail服务</title>
    <link href="/2023/06/12/loki/docker%E5%AE%89%E8%A3%85loki%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97/"/>
    <url>/2023/06/12/loki/docker%E5%AE%89%E8%A3%85loki%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、使用compose搭建loki服务"><a href="#一、使用compose搭建loki服务" class="headerlink" title="一、使用compose搭建loki服务"></a>一、使用compose搭建loki服务</h3><ol><li>创建文件夹</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> loki-compose<br>$ <span class="hljs-built_in">cd</span> loki-compose<br>$ <span class="hljs-built_in">mkdir</span> data &amp;&amp; <span class="hljs-built_in">mkdir</span> <span class="hljs-built_in">log</span> &amp;&amp; <span class="hljs-built_in">mkdir</span> config<br>$ <span class="hljs-built_in">cd</span> config &amp;&amp; <span class="hljs-built_in">touch</span> local-config.yaml &amp;&amp; <span class="hljs-built_in">touch</span> promtail-config.yaml<br>$ <span class="hljs-built_in">touch</span> docker-compose.yml<br></code></pre></td></tr></table></figure><ol start="2"><li>容器内配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim config/local-config.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># local-config.yaml</span><br><span class="hljs-comment"># 是否开启认证</span><br><span class="hljs-attr">auth_enabled:</span> <span class="hljs-literal">false</span><br><span class="hljs-comment"># HTTP和gRPC服务监听地址</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">http_listen_port:</span> <span class="hljs-number">3100</span><br>  <span class="hljs-attr">grpc_listen_port:</span> <span class="hljs-number">9095</span><br><span class="hljs-comment"># 配置日志索引和存储</span><br><span class="hljs-attr">schema_config:</span><br>  <span class="hljs-attr">configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">from:</span> <span class="hljs-number">2018-04-15</span><br>      <span class="hljs-attr">store:</span> <span class="hljs-string">boltdb</span><br>      <span class="hljs-attr">object_store:</span> <span class="hljs-string">filesystem</span><br>      <span class="hljs-attr">schema:</span> <span class="hljs-string">v11</span><br>      <span class="hljs-attr">index:</span><br>        <span class="hljs-attr">prefix:</span> <span class="hljs-string">index_</span><br>        <span class="hljs-attr">period:</span> <span class="hljs-string">24h</span><br><br><span class="hljs-comment"># 配置日志存储后端</span><br><span class="hljs-attr">storage_config:</span><br>  <span class="hljs-attr">boltdb:</span><br>    <span class="hljs-attr">directory:</span> <span class="hljs-string">/data/loki/index</span><br>  <span class="hljs-attr">filesystem:</span><br>    <span class="hljs-attr">directory:</span> <span class="hljs-string">/data/loki/chunks</span><br><br><span class="hljs-comment"># 配置日志收集</span><br><span class="hljs-attr">ingester:</span><br>  <span class="hljs-attr">wal:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">dir:</span> <span class="hljs-string">&quot;/tmp/wal&quot;</span><br>  <span class="hljs-attr">lifecycler:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">ring:</span><br>      <span class="hljs-attr">kvstore:</span><br>        <span class="hljs-attr">store:</span> <span class="hljs-string">inmemory</span><br>      <span class="hljs-attr">replication_factor:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">heartbeat_timeout:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">final_sleep:</span> <span class="hljs-string">0s</span><br>  <span class="hljs-attr">chunk_idle_period:</span> <span class="hljs-string">5m</span><br>  <span class="hljs-attr">chunk_retain_period:</span> <span class="hljs-string">30s</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim config/promtail-config.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># promtail config yml</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">http_listen_port:</span> <span class="hljs-number">9080</span><br>  <span class="hljs-attr">grpc_listen_port:</span> <span class="hljs-number">0</span><br><br><span class="hljs-attr">positions:</span><br>  <span class="hljs-attr">filename:</span> <span class="hljs-string">/tmp/positions.yaml</span><br><br><span class="hljs-attr">clients:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">http://loki-svc:3100/loki/api/v1/push</span><br><br><span class="hljs-attr">scrape_configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">log</span><br>  <span class="hljs-attr">static_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">job:</span> <span class="hljs-string">audit</span><br>      <span class="hljs-attr">__path__:</span> <span class="hljs-string">/log/*log</span><br></code></pre></td></tr></table></figure><ol start="2"><li>启动文件 docker-compose.yml</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim docker-compose.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># docker-compose.yml</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.7&#x27;</span><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">loki-net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">loki:</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">loki-net:</span><br>        <span class="hljs-attr">aliases:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-string">loki-svc</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/loki:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3100:3100&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config:/etc/loki</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data:/data/loki</span><br><br>  <span class="hljs-attr">promtail:</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-attr">loki-net:</span><br>        <span class="hljs-attr">aliases:</span><br>         <span class="hljs-bullet">-</span> <span class="hljs-string">promtail-svc</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/promtail:latest</span><br>    <span class="hljs-attr">privileged:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./config:/config</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./log:/log</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">-config.file=/config/promtail-config.yaml</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 目录结构</span><br>$ tree .<br>.<br>├── config<br>│   ├── local-config.yaml<br>│   └── promtail-config.yaml<br>├── data<br>├── docker-compose.yml<br>└── <span class="hljs-built_in">log</span><br></code></pre></td></tr></table></figure><h3 id="二、启动服务"><a href="#二、启动服务" class="headerlink" title="二、启动服务"></a>二、启动服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> loki-compose &amp;&amp; docker-compose up -d<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 制造测试数据</span><br>$ <span class="hljs-built_in">cd</span> loki-compose &amp;&amp; <span class="hljs-built_in">touch</span> <span class="hljs-built_in">log</span>/audit.log<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;jack&quot;&#125;&#x27;</span> | sudo <span class="hljs-built_in">tee</span> -a <span class="hljs-built_in">log</span>/audit.log<br></code></pre></td></tr></table></figure><h3 id="三、服务访问"><a href="#三、服务访问" class="headerlink" title="三、服务访问"></a>三、服务访问</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://localhost:3100/loki/api/v1/series<br>&#123;<br>  <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>: [<br>    &#123;<br>      <span class="hljs-string">&quot;job&quot;</span>: <span class="hljs-string">&quot;audit&quot;</span>,<br>      <span class="hljs-string">&quot;filename&quot;</span>: <span class="hljs-string">&quot;/log/audit.log&quot;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-string">&quot;filename&quot;</span>: <span class="hljs-string">&quot;/var/log/dpkg.log&quot;</span>,<br>      <span class="hljs-string">&quot;job&quot;</span>: <span class="hljs-string">&quot;varlogs&quot;</span><br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://localhost:3100/loki/api/v1/query_range?query=&#123;job=<span class="hljs-string">&quot;audit&quot;</span>&#125;|json<br><br>&#123;<br>  <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;resultType&quot;</span>: <span class="hljs-string">&quot;streams&quot;</span>,<br>    <span class="hljs-string">&quot;result&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;stream&quot;</span>: &#123;<br>          <span class="hljs-string">&quot;filename&quot;</span>: <span class="hljs-string">&quot;/log/audit.log&quot;</span>,<br>          <span class="hljs-string">&quot;job&quot;</span>: <span class="hljs-string">&quot;audit&quot;</span>,<br>          <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;jack&quot;</span><br>        &#125;,<br>        <span class="hljs-string">&quot;values&quot;</span>: [<br>          [<br>            <span class="hljs-string">&quot;1686537086403538378&quot;</span>,<br>            <span class="hljs-string">&quot;&#123;\&quot;name\&quot;:\&quot;jack\&quot;&#125;&quot;</span><br>          ]<br>        ]<br>      &#125;<br>...<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://hub.docker.com/r/grafana/loki">https://hub.docker.com/r/grafana/loki</a><br><a href="https://grafana.com/docs/loki/latest/clients/promtail/installation/">https://grafana.com/docs/loki/latest/clients/promtail/installation/</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>loki</tag>
      
      <tag>promtail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s之中使用loki存档审计日志</title>
    <link href="/2023/06/12/loki/%E5%9F%BA%E4%BA%8Eloki%E6%90%AD%E5%BB%BAk8s%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/"/>
    <url>/2023/06/12/loki/%E5%9F%BA%E4%BA%8Eloki%E6%90%AD%E5%BB%BAk8s%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、loki存档审计日志架构图"><a href="#一、loki存档审计日志架构图" class="headerlink" title="一、loki存档审计日志架构图"></a>一、loki存档审计日志架构图</h3><p><img src="/images/audit-log.png" alt="审计日志接入"></p><h3 id="二、配置k8s仅仅记录资源的delete-edit-add，不记录查看动作"><a href="#二、配置k8s仅仅记录资源的delete-edit-add，不记录查看动作" class="headerlink" title="二、配置k8s仅仅记录资源的delete edit add，不记录查看动作"></a>二、配置k8s仅仅记录资源的delete edit add，不记录查看动作</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 原始日志结构</span><br><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;kind&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Event&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;audit.k8s.io/v1&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;level&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 日志详细级别</span><br>    <span class="hljs-attr">&quot;auditID&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;stage&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 请求阶段</span><br>    <span class="hljs-attr">&quot;requestURI&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;verb&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 动作 update\get\list\delete\patch</span><br>    <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 用户名称 kube-system\node:k8s-master</span><br>        <span class="hljs-attr">&quot;groups&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> <span class="hljs-comment">// 所属用户组</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;sourceIPs&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>        <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment">// 请求IP</span><br>    <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;userAgent&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;objectRef&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;resource&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-comment">// 资源类型 pods\lease</span><br>        <span class="hljs-attr">&quot;namespace&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;apiGroup&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;apiVersion&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;requestReceivedTimestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;stageTimestamp&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># /etc/kubernetes/audit/audit-policy.yml</span><br><span class="hljs-comment"># 通过排除法，特定的角色、资源、动作类型不做记录，其余记录为审计日志</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">audit.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Policy</span><br><span class="hljs-comment"># 仅仅记录</span><br><span class="hljs-attr">omitStages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ResponseStarted&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ResponseComplete&quot;</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-comment"># 排除watch\get\list\</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">None</span><br>    <span class="hljs-attr">verbs:</span> [<span class="hljs-string">&quot;watch&quot;</span>,<span class="hljs-string">&quot;get&quot;</span>,<span class="hljs-string">&quot;list&quot;</span>,<span class="hljs-string">&quot;patch&quot;</span>]<br>  <span class="hljs-comment"># 排除特定角色</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">None</span><br>    <span class="hljs-attr">users:</span> [<span class="hljs-string">&quot;system:kube-scheduler&quot;</span>,<span class="hljs-string">&quot;system:apiserver&quot;</span>,<span class="hljs-string">&quot;system:kube-controller-manager&quot;</span>]<br>  <span class="hljs-comment"># 租约更新不需要</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">None</span><br>    <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;coordination.k8s.io&quot;</span><br>      <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;leases&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">RequestResponse</span><br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 源代码：</span><br><span class="hljs-comment">// k8s.io/apiserver</span><br><span class="hljs-comment">// pkg/audit/policy.EvaluatePolicyRule</span><br><span class="hljs-comment">// 规则验证，自上而下，遇到匹配的规则返回当前的路由日志的处理策略</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *policyRuleEvaluator)</span></span> EvaluatePolicyRule(attrs authorizer.Attributes)<br><span class="hljs-comment">// 规则对象</span><br><span class="hljs-keyword">type</span> audit.PolicyRule<br></code></pre></td></tr></table></figure><p><a href="https://github.com/kubernetes/apiserver/blob/v0.27.2/pkg/audit/policy/checker.go">apiserver handler request过滤器校验审计日志规则源码</a><br><a href="https://weiqiangxu.github.io/2023/05/23/k8s/kubernetes%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/">xuweiqiang’s blog 如何配置静态pod apiserver开启审计日志</a></p><h3 id="三、日志写入策略"><a href="#三、日志写入策略" class="headerlink" title="三、日志写入策略"></a>三、日志写入策略</h3><p>日志写入标准输出，标准输出默认挂载至宿主机目录 <code>/var/log/containers/</code> 的文件 <code>&lt;POD-NAME&gt;_&lt;CONTAINER-NAME&gt;_&lt;CONTAINER-ID&gt;.log</code> 之中，比如 <code>kube-apiserver-k8s-master_kube-system_kube-apiserver-xxx.log</code> 日志文件。</p><h3 id="四、创建loki-promtail采集日志"><a href="#四、创建loki-promtail采集日志" class="headerlink" title="四、创建loki\promtail采集日志"></a>四、创建loki\promtail采集日志</h3><p><a href="https://weiqiangxu.github.io/2023/06/03/loki/%E5%9C%A8k8s%E5%88%9B%E5%BB%BAloki%E6%9C%8D%E5%8A%A1%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97/">xuweiqiang’s blog 在k8s之中部署loki服务存储日志</a></p><p><a href="https://weiqiangxu.github.io/2023/06/12/loki/docker%E5%AE%89%E8%A3%85loki%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97/">xuweiqiang’s blog docker安装loki采集日志</a></p><h3 id="五、已经搭建好审计日志的服务器"><a href="#五、已经搭建好审计日志的服务器" class="headerlink" title="五、已经搭建好审计日志的服务器"></a>五、已经搭建好审计日志的服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># bingokube</span><br>$ 127.0.0.1<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建service暴露http服务</span><br><span class="hljs-comment"># loki.svc.yml</span><br>apiVersion: v1<br>kind: Service<br>metadata:<br>  name: loki-service<br>  namespace: loki<br>spec:<br>  <span class="hljs-built_in">type</span>: NodePort<br>  selector:<br>    app: loki<br>  ports:<br>  - name: loki-port<br>    protocol: TCP<br>    port: 80<br>    targetPort: 3100<br>    nodePort: 30019<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在机器上直接用pod的IP访问</span><br>$ curl 192.100.0.11:3100/loki/api/v1/query<br>$ curl http://127.0.0.1:30019/loki/api/v1/query<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 示例日志查询</span><br>http://127.0.0.1:30019/loki/api/v1/query_range?query=&#123;container=<span class="hljs-string">&quot;kube-apiserver&quot;</span>&#125;|json|auditID!=<span class="hljs-string">&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="六、通过http接口查看loki日志"><a href="#六、通过http接口查看loki日志" class="headerlink" title="六、通过http接口查看loki日志"></a>六、通过http接口查看loki日志</h3><ol><li>查询一段时间范围内的所有指标原始日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://localhost:3101/loki/api/v1/query_range<br>query=&#123;container=<span class="hljs-string">&quot;evaluate-loki-flog-1&quot;</span>&#125;| json| method=<span class="hljs-string">&quot;GET&quot;</span><br>start=1685531767028752000<br>end=1685531767029752000<br><br><br><span class="hljs-comment"># 原始查询样式</span><br>http://localhost:3101/loki/api/v1/query_range?query=&#123;container=%22evaluate-loki-flog-1%22&#125;|%20json|%20method=%22GET%22&amp;start=1685531767028752000&amp;end=<br><br><span class="hljs-comment">### 查询结果</span><br>&#123;<br>    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;resultType&quot;</span>: <span class="hljs-string">&quot;streams&quot;</span>,<br>        <span class="hljs-string">&quot;result&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;stream&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;bytes&quot;</span>: <span class="hljs-string">&quot;9822&quot;</span>,<br>                    <span class="hljs-string">&quot;container&quot;</span>: <span class="hljs-string">&quot;evaluate-loki-flog-1&quot;</span>,<br>                    <span class="hljs-string">&quot;datetime&quot;</span>: <span class="hljs-string">&quot;31/May/2023:11:29:51 +0000&quot;</span>,<br>                    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;34.255.123.249&quot;</span>,<br>                    <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>                    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;HTTP/1.1&quot;</span>,<br>                    <span class="hljs-string">&quot;referer&quot;</span>: <span class="hljs-string">&quot;https://www.productvisionary.io/extensible/intuitive&quot;</span>,<br>                    <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;/utilize/redefine/robust/recontextualize&quot;</span>,<br>                    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;504&quot;</span>,<br>                    <span class="hljs-string">&quot;user_identifier&quot;</span>: <span class="hljs-string">&quot;-&quot;</span><br>                &#125;,<br>                <span class="hljs-string">&quot;values&quot;</span>: [<br>                    [<br>                        <span class="hljs-string">&quot;1685534541758917343&quot;</span>,<br>                        <span class="hljs-string">&quot;&#123;&quot;</span>name<span class="hljs-string">&quot;:&quot;</span>xxx<span class="hljs-string">&quot;&#125;&quot;</span><br>                    ]<br>                ]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;stream&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;bytes&quot;</span>: <span class="hljs-string">&quot;9809&quot;</span>,<br>                    <span class="hljs-string">&quot;container&quot;</span>: <span class="hljs-string">&quot;evaluate-loki-flog-1&quot;</span>,<br>                    <span class="hljs-string">&quot;datetime&quot;</span>: <span class="hljs-string">&quot;31/May/2023:11:34:35 +0000&quot;</span>,<br>                    <span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;142.152.85.195&quot;</span>,<br>                    <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;GET&quot;</span>,<br>                    <span class="hljs-string">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;HTTP/1.1&quot;</span>,<br>                    <span class="hljs-string">&quot;referer&quot;</span>: <span class="hljs-string">&quot;http://www.humanoptimize.org/syndicate/generate&quot;</span>,<br>                    <span class="hljs-string">&quot;request&quot;</span>: <span class="hljs-string">&quot;/distributed/syndicate&quot;</span>,<br>                    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;501&quot;</span>,<br>                    <span class="hljs-string">&quot;user_identifier&quot;</span>: <span class="hljs-string">&quot;aufderhar3522&quot;</span><br>                &#125;,<br></code></pre></td></tr></table></figure><ol start="2"><li>查看所有的时间序列(一般一个容器有一个序列)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://localhost:3101/loki/api/v1/series<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>范围查询的start时间格式</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_formatTS</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>ts time.Time<br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>args args<br>want <span class="hljs-type">string</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;&quot;</span>,<br>args: args&#123;<br>ts: time.Now().Add(<span class="hljs-number">-1</span> * time.Minute),<br>&#125;,<br>want: <span class="hljs-string">&quot;&quot;</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>      <span class="hljs-comment">// 1685531472028872000</span><br>      <span class="hljs-comment">// 时间戳纳秒格式字符串</span><br><span class="hljs-keyword">if</span> got := strconv.FormatInt(tt.args.ts.UnixNano(), <span class="hljs-number">10</span>); got != tt.want &#123;<br>t.Errorf(<span class="hljs-string">&quot;formatTS() = %v, want %v&quot;</span>, got, tt.want)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>http接口查看loki数据时候如何取消身份校验</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 取消验证  disable the auth feature</span><br><span class="hljs-comment"># https://github.com/grafana/loki/issues/7081</span><br><span class="hljs-attr">auth_enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><ol start="3"><li>promtail 如何配置采集日志(&#x2F;var&#x2F;log) 并且更新helm包</li></ol><blockquote><p>待定，使用已经搭建好的服务先</p></blockquote><ol start="4"><li>如何获取当前审计日志之中所有user.username有哪些</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://localhost:3101/loki/api/v1/query?query=count(count_over_time(&#123;container=<span class="hljs-string">&quot;evaluate-loki-flog-1&quot;</span>&#125;[5m] |json)) by (method)<br><br>&#123;<br>    <span class="hljs-string">&quot;status&quot;</span>: <span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-string">&quot;resultType&quot;</span>: <span class="hljs-string">&quot;vector&quot;</span>,<br>        <span class="hljs-string">&quot;result&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;metric&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;DELETE&quot;</span><br>                &#125;,<br>                <span class="hljs-string">&quot;value&quot;</span>: [<br>                    1685534804.433,<br>                    <span class="hljs-string">&quot;49&quot;</span><br>                ]<br>            &#125;,<br>            &#123;<br>                <span class="hljs-string">&quot;metric&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;method&quot;</span>: <span class="hljs-string">&quot;GET&quot;</span><br>                &#125;,<br>                <span class="hljs-string">&quot;value&quot;</span>: [<br>                    1685534804.433,<br>                    <span class="hljs-string">&quot;50&quot;</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>loki是如何拉取并存储日志的</li></ol><p><img src="/images/simple-scalable-test-environment.png" alt="loki"></p><ol start="6"><li>如何配置apiserver将审计日志写入固定的目录被loki采集</li></ol><p>因为默认Loki会采集宿主机目录的 <code>/var/log/containers/</code> 所有日志文件，所以将审计日志写入该文件夹即可。如何配置呢请<a href="https://weiqiangxu.github.io/2023/05/23/k8s/kubernetes%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/">访问</a>.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li><a href="https://zhuanlan.zhihu.com/p/535482931">Grafana Loki 查询语言 LogQL 使用</a></li><li><a href="https://grafana.com/docs/loki/latest/getting-started/">https://grafana.com/docs/loki/latest/getting-started/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>loki</tag>
      
      <tag>promtail</tag>
      
      <tag>audit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>veth-pair和host网桥通信</title>
    <link href="/2023/06/07/cni/veth-pair%E5%92%8Chost%E7%BD%91%E6%A1%A5%E9%80%9A%E4%BF%A1/"/>
    <url>/2023/06/07/cni/veth-pair%E5%92%8Chost%E7%BD%91%E6%A1%A5%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-网络命名空间创建"><a href="#1-网络命名空间创建" class="headerlink" title="1.网络命名空间创建"></a>1.网络命名空间创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip netns list<br>$ ip netns add ns1<br>$ ip netns add ns2<br></code></pre></td></tr></table></figure><h3 id="2-创建网桥"><a href="#2-创建网桥" class="headerlink" title="2.创建网桥"></a>2.创建网桥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brctl addbr br0<br>$ brctl show<br></code></pre></td></tr></table></figure><h3 id="3-创建veth-pair对"><a href="#3-创建veth-pair对" class="headerlink" title="3.创建veth pair对"></a>3.创建veth pair对</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip <span class="hljs-built_in">link</span> add veth1 <span class="hljs-built_in">type</span> veth peer name peer-veth1<br>$ ip <span class="hljs-built_in">link</span> add veth2 <span class="hljs-built_in">type</span> veth peer name peer-veth2<br></code></pre></td></tr></table></figure><h3 id="4-将veth-pair对的一端插入网桥br0"><a href="#4-将veth-pair对的一端插入网桥br0" class="headerlink" title="4.将veth pair对的一端插入网桥br0"></a>4.将veth pair对的一端插入网桥br0</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ brctl addif br0 veth1<br>$ brctl addif br0 veth2i<br></code></pre></td></tr></table></figure><h3 id="5-将veth-pair对的另一端插入网络命名空间-ns1-ns2"><a href="#5-将veth-pair对的另一端插入网络命名空间-ns1-ns2" class="headerlink" title="5.将veth pair对的另一端插入网络命名空间 ns1 ns2"></a>5.将veth pair对的另一端插入网络命名空间 ns1 ns2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-veth1 netns ns1<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-veth2 netns ns2<br></code></pre></td></tr></table></figure><h3 id="6-分配ip给-ns1-和-ns2-的网卡"><a href="#6-分配ip给-ns1-和-ns2-的网卡" class="headerlink" title="6.分配ip给 ns1 和 ns2 的网卡"></a>6.分配ip给 ns1 和 ns2 的网卡</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 10.1.1.2/24 dev peer-veth1<br>$ ip netns <span class="hljs-built_in">exec</span> ns2 ip addr add 10.1.1.3/24 dev peer-veth2<br></code></pre></td></tr></table></figure><h3 id="7-启动所有网桥和网卡"><a href="#7-启动所有网桥和网卡" class="headerlink" title="7.启动所有网桥和网卡"></a>7.启动所有网桥和网卡</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-veth1 up<br>$ ip netns <span class="hljs-built_in">exec</span> ns2 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> peer-veth2 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth2 up<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> br0 up<br></code></pre></td></tr></table></figure><h3 id="8-测试网络是否连通"><a href="#8-测试网络是否连通" class="headerlink" title="8.测试网络是否连通"></a>8.测试网络是否连通</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip netns <span class="hljs-built_in">exec</span> ns1 ping 10.1.1.3<br></code></pre></td></tr></table></figure><blockquote><p>结论：可以使用 host 上的网桥和 veth pair 实现两个 network namespace 的连接</p></blockquote><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-如何删除网卡和网络命名空间"><a href="#1-如何删除网卡和网络命名空间" class="headerlink" title="1.如何删除网卡和网络命名空间"></a>1.如何删除网卡和网络命名空间</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 网络命名内部网卡必须全部已经删除否则无法删除该网络命名空间</span><br>$ ip netns delete ns1<br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> delete veth1-peer<br>$ ip <span class="hljs-built_in">link</span> delete veth1-peer<br></code></pre></td></tr></table></figure><h5 id="2-网络中-10-16-198-8-x2F-23-是什么意思"><a href="#2-网络中-10-16-198-8-x2F-23-是什么意思" class="headerlink" title="2.网络中 10.16.198.8&#x2F;23 是什么意思"></a>2.网络中 10.16.198.8&#x2F;23 是什么意思</h5><ol><li>这是一个IP地址和子网掩码的组合，也叫做 CIDR地址 （IP地址和一个斜线后跟一个数字）</li><li>ip地址是 10.16.198.8，前23位是网络位，剩下的9位是主机位</li><li>子网掩码： 255.255.254.0 (前面23位全位1后面23位全为0的值)</li><li>主机位：10.16.198.1 ～ 10.16.199.254 （通常主机地址范围是从网络地址加1开始到广播地址减1结束）</li></ol>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>veth-pair和ovs-bridge通讯</title>
    <link href="/2023/06/07/cni/veth-pair%E5%92%8Covs-bridge%E9%80%9A%E8%AE%AF/"/>
    <url>/2023/06/07/cni/veth-pair%E5%92%8Covs-bridge%E9%80%9A%E8%AE%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="创建-veth-pair-和-ovs-br"><a href="#创建-veth-pair-和-ovs-br" class="headerlink" title="创建 veth-pair 和 ovs-br"></a>创建 veth-pair 和 ovs-br</h3><blockquote><p>OVS 是第三方开源的 Bridge，功能比 Linux Bridge 要更强大，对于同样的实验，我们用 OVS 来看看是什么效果</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用 ovs 提供的命令创建一个 ovs bridge</span><br>$ ovs-vsctl add-br ovs-br<br><span class="hljs-comment"># 查看 ovs bridge</span><br>$ ovs-vsctl show<br><br><span class="hljs-comment"># 创建两对 veth-pair</span><br><span class="hljs-comment"># 用于创建一个虚拟以太网接口ovs-veth-a，并生成一个与之相连的对等接口ovs-veth-b</span><br><span class="hljs-comment"># 用于连接Open vSwitch网络交换机</span><br>$ ip <span class="hljs-built_in">link</span> add ovs-veth-a <span class="hljs-built_in">type</span> veth peer name ovs-veth-b<br>$ ip <span class="hljs-built_in">link</span> add ovs-veth-c <span class="hljs-built_in">type</span> veth peer name ovs-veth-d<br><br><span class="hljs-comment"># 将 veth-pair 两端分别加入到 ns 和 ovs bridge 中</span><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ovs-veth-a netns ns1<br>$ ovs-vsctl add-port ovs-br ovs-veth-b<br>$ ifconfig ovs-veth-b<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ovs-veth-b up<br><br><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ovs-veth-c netns ns2<br>$ ovs-vsctl add-port ovs-br ovs-veth-d<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ovs-veth-d up<br><br><span class="hljs-comment"># 给 ns 中的 veth 配置 IP 并启用</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 10.1.1.2/24 dev ovs-veth-a<br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> ovs-veth-a up<br><br>$ ip netns <span class="hljs-built_in">exec</span> ns2 ip addr add 10.1.1.3/24 dev ovs-veth-c<br>$ ip netns <span class="hljs-built_in">exec</span> ns2 ip a<br>$ ip netns <span class="hljs-built_in">exec</span> ns2 ip l s ovs-veth-c up<br><br><span class="hljs-comment"># veth0 ping veth1</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ping 10.1.1.3<br>PING 10.1.1.3 (10.1.1.3) 56(84) bytes of data.<br>64 bytes from 10.1.1.3: icmp_seq=1 ttl=64 time=0.586 ms<br>64 bytes from 10.1.1.3: icmp_seq=2 ttl=64 time=0.066 ms<br></code></pre></td></tr></table></figure><p><img src="/images/veth-ovs.png" alt="veth &amp;&amp; ovs"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li>如何设置路由表</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在ns1和ns2上分别执行以下命令设置路由表</span><br>$ ip route add 10.0.0.0/24 dev &lt;veth-pair-name&gt; <span class="hljs-comment"># 添加本地子网路由</span><br>$ ip route add default via 10.0.0.1 <span class="hljs-comment"># 添加默认路由</span><br><br><span class="hljs-comment"># 显示网络接口的状态和属性，例如接口名称、MAC地址、MTU和状态</span><br>$ ip <span class="hljs-built_in">link</span> show<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/bakari/p/10613710.html">Linux 虚拟网络设备 veth-pair 详解，看这一篇就够了</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是CNI</title>
    <link href="/2023/06/05/cni/%E4%BB%80%E4%B9%88%E6%98%AFCNI/"/>
    <url>/2023/06/05/cni/%E4%BB%80%E4%B9%88%E6%98%AFCNI/</url>
    
    <content type="html"><![CDATA[<h3 id="一、简短描述"><a href="#一、简短描述" class="headerlink" title="一、简短描述"></a>一、简短描述</h3><ol><li>CNCF项目;</li><li>标准化的网络接口规范;</li><li>CNI规范定义了”容器运行时”如何与”网络插件”进行通信，并且规定了插件必须实现的功能和接口;</li><li>第三方插件:<br>  <a href="https://github.com/projectcalico/calico">calico</a><br>  <a href="https://github.com/cilium/cilium">cilium</a></li></ol><h3 id="二、k8s和CNI是什么关系"><a href="#二、k8s和CNI是什么关系" class="headerlink" title="二、k8s和CNI是什么关系"></a>二、k8s和CNI是什么关系</h3><ul><li>Kubernetes遵循CNI（Container Networking Interface）规范；</li><li>使用CNI插件来实现容器间通信和与外部网络通信，定义和管理容器的网络配置；</li><li>Kubernetes提供了一些默认的CNI网络插件，例如Flannel和Calico等；</li><li>CNI网络抽象层</li></ul><h3 id="三、k8s如何集成flannel"><a href="#三、k8s如何集成flannel" class="headerlink" title="三、k8s如何集成flannel"></a>三、k8s如何集成flannel</h3><ul><li>Kubernetes文档<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">使用kubeadm引导集群</a>;</li><li>Kubernetes文档<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/#pod-network">安装Pod网络附加组件</a></li><li>Kubernetes文档<a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">概念&#x2F;扩展&#x2F;计算存储和网络扩展&#x2F;网络插件</a>选择使用containerd\CRI-O</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在控制平面节点或具有 kubeconfig 凭据的节点上安装 Pod 网络附加组件</span><br><span class="hljs-comment"># 每个集群只能安装一个 Pod 网络</span><br>$ kubectl apply -f &lt;add-on.yaml&gt;<br></code></pre></td></tr></table></figure><h3 id="四、CNI标准和CNI提供的二进制程序-什么关系"><a href="#四、CNI标准和CNI提供的二进制程序-什么关系" class="headerlink" title="四、CNI标准和CNI提供的二进制程序(什么关系)"></a>四、CNI标准和CNI提供的二进制程序(什么关系)</h3><blockquote><p>CNI插件是符合CNI规范的二进制程序</p></blockquote><h3 id="五、只有-CNI-x2F-plugins-可以安装好k8s的网络吗"><a href="#五、只有-CNI-x2F-plugins-可以安装好k8s的网络吗" class="headerlink" title="五、只有 CNI&#x2F;plugins 可以安装好k8s的网络吗"></a>五、只有 <a href="https://github.com/containernetworking/plugins">CNI&#x2F;plugins</a> 可以安装好k8s的网络吗</h3><p>   不是的，除了 <a href="https://github.com/containernetworking/plugins">https://github.com/containernetworking/plugins</a> 还有很多其他的网络插件可以用于Kubernetes，比如：Calico、Flannel、Weave Net、Cilium等等。可以根据自己的需求选择适合的网络插件来部署Kubernetes集群。</p><h3 id="六、CNI如何工作的"><a href="#六、CNI如何工作的" class="headerlink" title="六、CNI如何工作的"></a>六、CNI如何工作的</h3><p>参考<a href="https://mp.weixin.qq.com/s/gWPZKz9Z4gCoZRFX8dvr6w">万字总结体系化带你全面认识容器网络接口(CNI)</a></p><p>CNI的接口并不是指HTTP，gRPC接口，CNI接口是指对可执行程序的调用（exec）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">ls</span> /opt/cni/bin/  <br><br>bandwidth  bridge  dhcp  firewall  flannel  host-device  host-local  ipvlan  <br>loopback  macvlan  portmap  ptp  sbr  static  tuning  vlan<br></code></pre></td></tr></table></figure><p><img src="/images/cni-pod.png" alt="容器运行时执行CNI插件 - 调用二进制脚本方式"></p><blockquote><p>libcni（胶水层）是CNI提供的一个go package，封装了一些符合CNI规范的标准操作，便于容器运行时和网络插件对接。</p></blockquote><ol><li>JSON格式的配置文件来描述网络配置;</li><li>容器运行时负责执行CNI插件，并通过CNI插件的标准输入（stdin）来传递配置文件信息，通过标准输出（stdout）接收插件的执行结果;</li><li>环境变量:<br> CNI_COMMAND：定义期望的操作，可以是ADD，DEL，CHECK或VERSION。<br> CNI_CONTAINERID：容器ID，由容器运行时管理的容器唯一标识符。<br> CNI_NETNS：容器网络命名空间的路径。（形如 &#x2F;run&#x2F;netns&#x2F;[nsname]）。<br> CNI_IFNAME：需要被创建的网络接口名称，例如eth0。<br> CNI_ARGS：运行时调用时传入的额外参数，格式为分号分隔的key-value对，例如FOO&#x3D;BAR;ABC&#x3D;123<br> CNI_PATH：CNI插件可执行文件的路径，例如&#x2F;opt&#x2F;cni&#x2F;bin。</li><li>通过链式调用的方式来支持多插件的组合使用;</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 调用bridge插件将容器接入到主机网桥</span><br><br><span class="hljs-comment"># CNI_COMMAND=ADD 顾名思义表示创建。</span><br><span class="hljs-comment"># XXX=XXX 其他参数定义见下文。</span><br><span class="hljs-comment"># &lt; config.json 表示从标准输入传递配置文件</span><br>CNI_COMMAND=ADD XXX=XXX ./bridge &lt; config.json<br></code></pre></td></tr></table></figure><h3 id="七、使用CNI用于Docker容器网络建设"><a href="#七、使用CNI用于Docker容器网络建设" class="headerlink" title="七、使用CNI用于Docker容器网络建设"></a>七、使用CNI用于Docker容器网络建设</h3><h5 id="1-安装runc和cni-plugins"><a href="#1-安装runc和cni-plugins" class="headerlink" title="1.安装runc和cni plugins"></a>1.安装runc和cni plugins</h5><ul><li>runc </li><li>docker</li><li>cni plugins</li><li>golang</li><li>git</li></ul><h5 id="2-quickStart"><a href="#2-quickStart" class="headerlink" title="2.quickStart"></a>2.quickStart</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 宿主机上</span><br>$ CNI_PATH=/opt/cni/bin<br>$ <span class="hljs-built_in">cd</span> /home &amp;&amp; git <span class="hljs-built_in">clone</span> https://github.com/containernetworking/cni.git<br>$ CNI_PATH=<span class="hljs-variable">$CNI_PATH</span> /home/cni/scripts/priv-net-run.sh ifconfig<br></code></pre></td></tr></table></figure><h5 id="3-docker"><a href="#3-docker" class="headerlink" title="3.docker"></a>3.docker</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker save -o busybox.tar busybox:latest<br>$ docker load -i busybox.tar<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ CNI_PATH=/opt/cni/bi<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$CNI_PATH</span><br>$ <span class="hljs-built_in">cd</span> /home/cni/scripts &amp;&amp; CNI_PATH=<span class="hljs-variable">$CNI_PATH</span> ./docker-run.sh --<span class="hljs-built_in">rm</span> busybox:latest ifconfig<br></code></pre></td></tr></table></figure><p><a href="http://www.dasblinkenlichten.com/understanding-cni-container-networking-interface/">dasblinkenlichten.com&#x2F;深入理解CNI</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /opt/cni/bin<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> &gt; mybridge.conf &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">    &quot;cniVersion&quot;: &quot;0.2.0&quot;,</span><br><span class="hljs-string">    &quot;name&quot;: &quot;mybridge&quot;,</span><br><span class="hljs-string">    &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="hljs-string">    &quot;bridge&quot;: &quot;cni_bridge0&quot;,</span><br><span class="hljs-string">    &quot;isGateway&quot;: true,</span><br><span class="hljs-string">    &quot;ipMasq&quot;: true,</span><br><span class="hljs-string">    &quot;ipam&quot;: &#123;</span><br><span class="hljs-string">        &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="hljs-string">        &quot;subnet&quot;: &quot;10.15.20.0/24&quot;,</span><br><span class="hljs-string">        &quot;routes&quot;: [</span><br><span class="hljs-string">            &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;,</span><br><span class="hljs-string">            &#123; &quot;dst&quot;: &quot;1.1.1.1/32&quot;, &quot;gw&quot;:&quot;10.15.20.1&quot;&#125;</span><br><span class="hljs-string">        ]</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo ip netns add 1234567890<br>$ sudo CNI_COMMAND=ADD CNI_CONTAINERID=1234567890 CNI_NETNS=/var/run/netns/1234567890 CNI_IFNAME=eth12 CNI_PATH=`<span class="hljs-built_in">pwd</span>` ./bridge &lt;mybridge.conf<br><span class="hljs-comment"># 查看我们的主机 iptables 规则，我们将看到伪装和接受规则.</span><br>$ sudo iptables-save | grep mybridge<br><span class="hljs-comment"># 通常情况下，容器运行时会创建netns，这里我们手动创建</span><br>$ sudo ip netns <span class="hljs-built_in">exec</span> 1234567890 ifconfig<br><span class="hljs-comment">#　设备eth12的IP地址配置为10.15.20.2，子网掩码为255.255.255.0（/24表示子网掩码），并将该设备的网络范围设置为本地链接（scope link）</span><br>$ sudo ip netns <span class="hljs-built_in">exec</span> 1234567890 ip route<br><br><span class="hljs-comment"># 命名空间有一个名为“eth12”的接口，IP 地址为 10.15.20.2/24</span><br><span class="hljs-comment"># IP 地址对应的ipam的子网段地址</span><br>eth12: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 10.15.20.2  netmask 255.255.255.0  broadcast 10.15.20.255<br>        inet6 fe80::44f2:48ff:feb6:b364  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 46:f2:48:b6:b3:64  txqueuelen 0  (Ethernet)<br>        RX packets 67  bytes 13007 (12.7 KiB)<br>        RX errors 0  dropped 3  overruns 0  frame 0<br>        TX packets 9  bytes 682 (682.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br><br><span class="hljs-comment"># netns内部的网络路由可以看到规则有</span><br><span class="hljs-comment"># - 所有未知目标IP地址的网络流量都将通过eth12设备，并通过网关10.15.20.1转发到其他网络</span><br><span class="hljs-comment"># - 将目标IP地址1.1.1.1的网络流量通过eth12设备，并通过网关10.15.20.1转发到其他网络</span><br><span class="hljs-comment"># - 本地网络10.15.20.0/24的所有流量都通过eth12设备发送，并且源IP地址为10.15.20.2</span><br><span class="hljs-comment"># &quot;proto kernel&quot;表示该路由是由内核自动生成的。 &quot;scope link&quot; 表示该路由只适用于本地链路</span><br>$ sudo ip netns <span class="hljs-built_in">exec</span> 1234567890 ip route<br>default via 10.15.20.1 dev eth12                                 <span class="hljs-comment">#  &quot;dev&quot; 是指指定该路由器的出口网络接口，即数据包是从哪个网络接口发送出去的, 默认路由通过 eth12 网络接口，经过 10.15.20.1 这个下一跳地址进行转发</span><br>1.1.1.1 via 10.15.20.1 dev eth12                                 <span class="hljs-comment">#  &quot;via&quot; 是指默认路由的下一跳地址，即数据包需要经过哪个路由器进行转发</span><br>10.15.20.0/24 dev eth12 proto kernel scope <span class="hljs-built_in">link</span> src 10.15.20.2   <span class="hljs-comment">#  &quot;src&quot; 是指源IP地址，即指定该路由器发送数据包的源IP地址</span><br><br><span class="hljs-comment"># 查看网桥配置可以看到netns内部网卡eth12的veth pair对端网卡是vethb4336cfa</span><br>$ brctl show<br>bridge name     bridge <span class="hljs-built_in">id</span>               STP enabled     interfaces<br>cni_bridge0     8000.127bceaee96d       no              vethb4336cfa<br></code></pre></td></tr></table></figure><h5 id="4-配置解析"><a href="#4-配置解析" class="headerlink" title="4.配置解析"></a>4.配置解析</h5><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;cniVersion&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;定义适用的 CNI 规范的版本&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;网络名称&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;您希望使用的插件的名称。在这种情况下，插件可执行文件的实际名称&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;bridge&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;创建名为cni_bridge0的网桥接口&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;isGateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;如果为真，则为网桥分配一个IP地址，以便连接到它的容器可以将其用作网关&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ipMasq&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;为此网络配置出站伪装（源 NAT）&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;ipam&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;IPAM 插件可执行文件的名称&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;subnet&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;要分配的子网（这实际上是 IPAM 插件的一部分），这个其实决定了容器内的网址&quot;</span><span class="hljs-punctuation">,</span> <br>        <span class="hljs-attr">&quot;routes&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;dst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;您希望访问的子网&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;dst&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;您希望访问的子网&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;gw&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;到达dst的下一跳IP地址。如果未指定，则假定为子网的默认网关&quot;</span><span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">CNI_COMMAND=ADD – 我们告诉 CNI 我们想要添加一个连接<br>CNI_CONTAINER=1234567890 – 我们告诉 CNI 我们想要使用的网络命名空间称为“1234567890”（更多内容见下文）<br>CNI_NETNS=/var/run/netns/1234567890 – 相关命名空间的路径<br>CNI_IFNAME=eth12 – 我们希望在连接的容器端使用的接口名称<br>CNI_PATH=`<span class="hljs-built_in">pwd</span>`  – 我们总是需要告诉 CNI 插件可执行文件所在的位置。在这种情况下，<br>因为我们已经在“cni”目录中，所以我们只有变量引用 <span class="hljs-built_in">pwd</span>（当前工作目录）。<br>您需要命令 <span class="hljs-built_in">pwd</span> 周围的刻度线才能正确评估。此处的格式似乎正在删除它们，但它们在上面的命令中正确<br>我们使用 STDIN 将网络配置文件提供给插件<br></code></pre></td></tr></table></figure><h5 id="5-CNI扩展插件"><a href="#5-CNI扩展插件" class="headerlink" title="5.CNI扩展插件"></a>5.CNI扩展插件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tree /opt/cni/bin/<br>/opt/cni/bin/<br>├── bandwidth       <span class="hljs-comment"># 提供带宽限制功能，用于限制容器的网络带宽使用</span><br>├── bridge          <span class="hljs-comment"># 用于创建和管理 Linux 桥接网络，使容器可以与宿主机以及其他容器进行通信</span><br>├── dhcp            <span class="hljs-comment"># 用于在容器启动时为其分配 IP 地址和其他网络配置信息，使容器能够与网络相连并进行通信</span><br>├── dummy           <span class="hljs-comment"># 创建虚拟网络接口，用于将本地流量重定向到远程主机或者其它容器，以便进行容器之间的通信</span><br>├── firewall        <span class="hljs-comment"># 用于在容器之间设置网络防火墙规则，保护容器免受网络攻击或恶意流量的侵害</span><br>├── host-device     <span class="hljs-comment"># 用于将宿主机的物理网络设备（例如网卡）直接绑定到容器中，以提高网络性能和可靠性</span><br>├── host-local      <span class="hljs-comment"># 用于容器内部的通信，提供方便的主机名解析和网络配置</span><br>├── ipvlan          <span class="hljs-comment"># 使用现有接口创建虚拟接口，以增加容器的网络隔离性</span><br>├── loopback        <span class="hljs-comment"># 提供一个本地环回接口，用于本地进程与网络的通信</span><br>├── macvlan         <span class="hljs-comment"># 将容器连接到物理网络，使其可以使用独立的MAC地址和IP地址</span><br>├── portmap         <span class="hljs-comment"># 提供端口映射功能，将容器内部的端口映射到宿主机的端口上</span><br>├── ptp             <span class="hljs-comment"># 提供时间同步功能，确保容器中的网络设备具有相同的时间戳</span><br>├── sbr             <span class="hljs-comment"># 提供基于软件的路由功能，用于将容器连接到不同的网络</span><br>├── static          <span class="hljs-comment"># 提供静态IP地址配置功能，用于固定给容器分配IP地址</span><br>├── tuning          <span class="hljs-comment"># 提供网络优化功能，用于调整容器网络性能的参数</span><br>├── vlan            <span class="hljs-comment"># 提供虚拟局域网功能，用于将容器分组成不同的虚拟网络</span><br>└── vrf             <span class="hljs-comment"># 提供虚拟路由功能，用于将容器连接到不同的路由域</span><br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-k8s使用ovs通信的时候，当pod与pod之间通信，数据流向怎么样的"><a href="#1-k8s使用ovs通信的时候，当pod与pod之间通信，数据流向怎么样的" class="headerlink" title="1.k8s使用ovs通信的时候，当pod与pod之间通信，数据流向怎么样的"></a>1.k8s使用ovs通信的时候，当pod与pod之间通信，数据流向怎么样的</h5><blockquote><p>OVS充当着虚拟交换机的角色，Kubernetes网络模型插件协调多个节点上不同的OVS实现容器之间通信。</p></blockquote><ul><li>1.应用程序在一个pod中生成数据包，数据包被发送到pod的网络接口;</li><li>2.Kubernetes网络模型插件（例如：Flannel等）将数据包封装在一个Overlay协议中;</li><li>3.CNI插件比如flannel将数据包发送到虚拟交换机（OVS）;</li><li>4.OVS使用VXLAN或者Geneve等封装技术，将数据包发送到另一个pod的OVS;</li><li>5.另一个pod的OVS解开数据包，将数据包发送到目标pod的网络接口;</li><li>6.应用程序在目标pod中接收到数据包。</li></ul><h5 id="2-单价的kubernetes如何运行非控制平面的pod"><a href="#2-单价的kubernetes如何运行非控制平面的pod" class="headerlink" title="2.单价的kubernetes如何运行非控制平面的pod"></a>2.单价的kubernetes如何运行非控制平面的pod</h5><p>默认情况下，出于安全原因，你的集群不会在控制平面节点上调度 Pod。 参考官方手册<a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">控制平面节点隔离</a>，如果你希望能够在控制平面节点上调度 Pod，例如单机 Kubernetes 集群：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl taint nodes --all node-role.kubernetes.io/control-plane-<br></code></pre></td></tr></table></figure><h5 id="3-kubelet管理CNI插件吗"><a href="#3-kubelet管理CNI插件吗" class="headerlink" title="3.kubelet管理CNI插件吗"></a>3.kubelet管理CNI插件吗</h5><ul><li>Kubernetes 1.24 之前，CNI 插件也可以由 kubelet 使用命令行参数 cni-bin-dir 和 network-plugin 管理;</li><li>Kubernetes 1.24 移除了这些命令行参数， CNI 的管理不再是 kubelet 的工作;</li></ul><h5 id="4-如何安装和管理CNI插件"><a href="#4-如何安装和管理CNI插件" class="headerlink" title="4.如何安装和管理CNI插件"></a>4.如何安装和管理CNI插件</h5><p>理解<a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model">网络模型</a> - 如何实现网络模型 - <a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy">安装扩展</a> - <a href="https://github.com/flannel-io/flannel#deploying-flannel-manually">使用helm or kubectl 安装 flannel</a></p><h5 id="5-CNI插件和flannel什么关系"><a href="#5-CNI插件和flannel什么关系" class="headerlink" title="5.CNI插件和flannel什么关系"></a>5.CNI插件和flannel什么关系</h5><ul><li>cni插件和flannel都是用于容器网络的技术。</li><li>cni插件用于管理容器网络，flannel则是一种网络解决方案，可以提供容器间的通信。</li><li>cni插件可以与flannel结合使用，以管理flannel提供的网络。在使用kubernetes等容器编排工具时，通常都会使用cni插件和flannel进行容器网络的管理。</li></ul><h5 id="6-kube-proxy和flannel是什么关系"><a href="#6-kube-proxy和flannel是什么关系" class="headerlink" title="6.kube-proxy和flannel是什么关系"></a>6.kube-proxy和flannel是什么关系</h5><p>   kube-proxy和flannel可以说是两个不同的组件，但它们是紧密相关的。<br>   kube-proxy作为Kubernetes中的一种网络代理，负责管理集群内部的网络连接。<br>   flannel则是一种网络解决方案，用于管理容器之间的通信。<br>   在一个Kubernetes集群中，flannel会被作为网络解决方案被部署，并使用kube-proxy来实现网络代理的功能。<br>   flannel和cni也有关系。cni是Container Network Interface的缩写，是用于实现容器网络的通用API规范。<br>   而flannel则是cni规范的一个实现。也就是说，在一个Kubernetes集群中，flannel可以被作为cni规范的一个实现来使用，以实现容器网络的功能。</p><h5 id="7-kube-proxy是每个节点都有吗，控制节点还是工作节点，独立进程还是pod内还是二进制程序而已"><a href="#7-kube-proxy是每个节点都有吗，控制节点还是工作节点，独立进程还是pod内还是二进制程序而已" class="headerlink" title="7.kube-proxy是每个节点都有吗，控制节点还是工作节点，独立进程还是pod内还是二进制程序而已"></a>7.kube-proxy是每个节点都有吗，控制节点还是工作节点，独立进程还是pod内还是二进制程序而已</h5><p>   kube-proxy是每个工作节点都有的，它作为一个独立的进程运行在每个节点上。<br>   它的主要作用是实现Kubernetes服务发现和负载均衡机制，为Service对象提供集群内服务的访问入口。<br>   kube-proxy会在节点上创建iptables规则或操作网络设备，以实现Service IP的转发和负载均衡。</p><h5 id="8-flannel是CNI的实现吗"><a href="#8-flannel是CNI的实现吗" class="headerlink" title="8.flannel是CNI的实现吗"></a>8.flannel是CNI的实现吗</h5><p>   flannel是一种CNI（Container Networking Interface）的实现，用于容器之间的网络通信。<br>   它使用覆盖网络的技术来实现容器之间的通信，支持多种网络模型，如host-gw、vxlan、ipip等，可以在不同节点之间建立虚拟网络。<br>   flannel的主要作用是为容器提供独立的IP地址，并实现跨节点的通信，让容器能够像在一个本地网络中一样相互通信。</p><h5 id="9-CNI仓库之中有CNI规范库-CNI插件是什么关系，CNI插件-bridge-firewall-ptb等-和flannel是什么关系"><a href="#9-CNI仓库之中有CNI规范库-CNI插件是什么关系，CNI插件-bridge-firewall-ptb等-和flannel是什么关系" class="headerlink" title="9.CNI仓库之中有CNI规范库\CNI插件是什么关系，CNI插件(bridge\firewall\ptb等)和flannel是什么关系"></a>9.CNI仓库之中有CNI规范库\CNI插件是什么关系，CNI插件(bridge\firewall\ptb等)和flannel是什么关系</h5><ul><li>CNI规范是一种容器网络接口规范，定义了容器运行时与网络插件之间的接口规范;</li><li>CNI插件(轻量级网络插件)是遵循CNI规范定义的一种网络插件，用于在容器中创建和管理网络接口;</li><li>Flannel是一个常用的CNI插件之一，用于创建虚拟网络，并为容器提供IP地址，管理集群网络和跨节点通信;</li><li>在使用Flannel时，可以选择使用CNI插件作为网络接口与容器运行时交互，以实现跨主机容器的网络通信；</li></ul><blockquote><p>CNI插件和Flannel是互补的关系</p></blockquote><h5 id="10-kube-proxy原理是什么"><a href="#10-kube-proxy原理是什么" class="headerlink" title="10.kube-proxy原理是什么"></a>10.kube-proxy原理是什么</h5><p><a href="https://kubernetes.io/zh-cn/docs/reference/command-line-tools-reference/kube-proxy/">k8s&#x2F;参考&#x2F;组件工具&#x2F;kube-proxy</a></p><ul><li>网络代理在每个节点上运行；</li><li>执行 TCP、UDP 和 SCTP 流转发；</li><li>转发是基于iptables的（用iptables规则来实现Kubernetes Service的负载均衡和端口转发功能），每个Service创建一条iptables规则；</li></ul><h4 id="11-演示如何使用CNI插件来为Docker容器设置网络"><a href="#11-演示如何使用CNI插件来为Docker容器设置网络" class="headerlink" title="11.演示如何使用CNI插件来为Docker容器设置网络"></a>11.演示如何使用CNI插件来为Docker容器设置网络</h4><ul><li>docker指定网络<code>--net=none</code>的容器，容器内只有网卡lo无法通信；</li><li>调用CNI插件，为容器设置eth0接口，为其分配IP地址，并接入主机网桥mynet0；</li></ul><ol><li>容器中新增eth0网络接口：使用Bridge插件为容器创建网络接口，并连接到主机网桥(bridge.json)；</li><li>为容器所在的网段添加路由: <code>ip route add 10.10.0.0/16 dev mynet0 src 10.10.0.1 </code>;</li><li>访问容器内</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl -I 10.10.0.2 <span class="hljs-comment"># IP换成实际分配给容器的IP地址</span><br>HTTP/1.1 200 OK<br></code></pre></td></tr></table></figure><h4 id="12-如何方便快捷查看网卡"><a href="#12-如何方便快捷查看网卡" class="headerlink" title="12.如何方便快捷查看网卡"></a>12.如何方便快捷查看网卡</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ nsenter -t <span class="hljs-variable">$pid</span> -n ip a<br></code></pre></td></tr></table></figure><h4 id="13-删除网桥"><a href="#13-删除网桥" class="headerlink" title="13.删除网桥"></a>13.删除网桥</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip <span class="hljs-built_in">link</span> delete mynet0 <span class="hljs-built_in">type</span> bridge<br></code></pre></td></tr></table></figure><h4 id="14-路由规则default-via-10-15-20-1-dev-eth12是什么意思"><a href="#14-路由规则default-via-10-15-20-1-dev-eth12是什么意思" class="headerlink" title="14.路由规则default via 10.15.20.1 dev eth12是什么意思"></a>14.路由规则default via 10.15.20.1 dev eth12是什么意思</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">default              <span class="hljs-comment"># 默认路由，如果未知的ip（ip route无匹配规则）则流量从这个规则走</span><br>via 10.15.20.1       <span class="hljs-comment"># 下一跳地址，即数据包需要经过哪个路由器进行转发</span><br>dev eth12            <span class="hljs-comment"># 出口网络接口，即数据包是从哪个网络接口发送出去的</span><br></code></pre></td></tr></table></figure><h4 id="15-10-16-200-0-x2F-21-的-IP-范围是如何计算的呢"><a href="#15-10-16-200-0-x2F-21-的-IP-范围是如何计算的呢" class="headerlink" title="15.10.16.200.0&#x2F;21 的 IP 范围是如何计算的呢"></a>15.10.16.200.0&#x2F;21 的 IP 范围是如何计算的呢</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">转32位二进制: 00001010 00010000 11001000 00000000<br>因为是21位，所以前面21位不能更改，剩下的后面的二进制<br>转十进制最小的是<br>00001010 00010000 11001000 00000000  也就是 10.16.200.0<br>转十进制最大的是<br>00001010 00010000 11001111 11111111  也就是 10.16.207.255<br>所以 IP 范围是 10.16.200.0 ～ 10.16.207.255<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://github.com/containernetworking/cni">官方手册 https://github.com/containernetworking/cni</a><br><a href="https://github.com/containernetworking/plugins">官方手册 CNI&#x2F;plugins &amp;&amp; https://github.com/containernetworking/plugins</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/compute-storage-net/network-plugins/">k8s&#x2F;概念&#x2F;扩展&#x2F;网络插件</a><br><a href="https://github.com/containerd/containerd/blob/main/script/setup/install-cni">k8s&#x2F;概念&#x2F;扩展&#x2F;网络插件&#x2F;containerd安装网络插件</a><br><a href="https://github.com/cri-o/cri-o/blob/main/contrib/cni/README.md">k8s&#x2F;概念&#x2F;扩展&#x2F;网络插件&#x2F;CRI-O安装网络插件</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/networking/#how-to-implement-the-kubernetes-networking-model">k8s&#x2F;概念&#x2F;集群管理&#x2F;集群网络系统&#x2F;网络模型 &amp;&amp; 如何实现网络模型</a><br><a href="https://kubernetes.io/zh-cn/docs/concepts/cluster-administration/addons/#networking-and-network-policy">k8s&#x2F;概念&#x2F;集群管理&#x2F;安装扩展</a><br><a href="https://mp.weixin.qq.com/s/gWPZKz9Z4gCoZRFX8dvr6w">万字总结，体系化带你全面认识容器网络接口(CNI)</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是网桥</title>
    <link href="/2023/06/05/cni/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E6%A1%A5/"/>
    <url>/2023/06/05/cni/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E6%A1%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="1-网桥的创建"><a href="#1-网桥的创建" class="headerlink" title="1.网桥的创建"></a>1.网桥的创建</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 bridge-utils 包，它包含了配置网桥所需的工具</span><br>$ yum install bridge-utils<br><br><span class="hljs-comment"># 创建网桥</span><br><span class="hljs-comment"># sudo brctl addbr &lt;bridge-name&gt;</span><br>$ sudo brctl addbr my-net<br><br><span class="hljs-comment"># 将物理接口添加到网桥中</span><br><span class="hljs-comment"># sudo brctl addif &lt;bridge-name&gt; &lt;physical-interface&gt;</span><br>$ sudo brctl addif my-net lo<br><br><span class="hljs-comment"># 将名为 &quot;my-net&quot; 的网络接口（network interface）启用（up）</span><br><span class="hljs-comment"># sudo ip link set dev &lt;bridge-name&gt; up</span><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> dev my-net up<br><br><span class="hljs-comment"># ifconfig 可以查看到 my-net 网桥</span><br><span class="hljs-comment"># 查看网桥的状态以及连接到网桥上的接口</span><br>$ brctl show<br></code></pre></td></tr></table></figure><h3 id="2-删除网桥"><a href="#2-删除网桥" class="headerlink" title="2.删除网桥"></a>2.删除网桥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看网桥</span><br>$ brctl show<br><br><span class="hljs-comment"># 停止网桥</span><br><span class="hljs-comment"># ifconfig &lt;bridge-name&gt; down</span><br>$ ifconfig my-net down<br><br><span class="hljs-comment"># 删除网桥</span><br><span class="hljs-comment"># brctl delbr &lt;bridge-name&gt;</span><br>$ brctl delbr my-netm<br></code></pre></td></tr></table></figure><h3 id="3-典型的网桥应用"><a href="#3-典型的网桥应用" class="headerlink" title="3.典型的网桥应用"></a>3.典型的网桥应用</h3><ol><li>bridge模式下的docker，会创建虚拟网桥docker0；</li><li>给每个容器分配私有IP；</li><li>私有IP地址（通常是172.17.x.x）映射到宿主机的公共IP地址 – 实现容器与宿主机之间通信；</li><li>容器会连接到该虚拟网桥docker0 – 实现容器之间的通信；</li></ol><blockquote><p>Docker会创建一对veth设备，其中一个连接到容器，另一个连接到Docker宿主机的Linux桥接设备中了；</p></blockquote><p>验证docker在bridge模式下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装docker</span><br>$ yum install -y docker<br><br>$ docker version<br><span class="hljs-comment"># 18.09.0</span><br><br><span class="hljs-comment"># 运行nginx服务</span><br>$ docker run --name nginx-test -d nginx<br><br><span class="hljs-comment"># 网络接口</span><br>$ ifconfig<br>docker0             <span class="hljs-comment"># 虚拟网桥</span><br>enp1s0              <span class="hljs-comment"># 物理网卡</span><br>lo                  <span class="hljs-comment"># 环回网卡</span><br>veth71942f7         <span class="hljs-comment"># veth71942f7是docker创建的虚拟网卡设备，用于容器与宿主机之间的通信</span><br>virbr0              <span class="hljs-comment"># virbr0是libvirt创建的虚拟网桥设备，用于在虚拟机之间提供网络通信</span><br><br><span class="hljs-comment"># 所谓路由就是指示了各个ip下的数据包的走向，具体走向到哪个网卡由路由决定</span><br>[root@i-7B581709 ~]<span class="hljs-comment"># ip route</span><br><span class="hljs-comment"># 默认路由，即所有未知目的地的数据包将通过enp1s0网卡发送到网关10.16.207.254上</span><br>default via 10.16.207.254 dev enp1s0 proto dhcp metric 100                  <br><span class="hljs-comment"># 子网路由，指示10.16.200.0/21的数据包将被发送到enp1s0网卡，源IP地址为10.16.203.189</span><br>10.16.200.0/21 dev enp1s0 proto kernel scope <span class="hljs-built_in">link</span> src 10.16.203.189 metric 100 <br><span class="hljs-comment"># 链接范围的本地路由，指示数据包将在enp1s0网卡上本地处理</span><br><span class="hljs-comment"># 169.254.0.0/16是私有IP地址范围，通常为本地网络自动配置保留</span><br>169.254.0.0/16 dev enp1s0 scope <span class="hljs-built_in">link</span> <br><span class="hljs-comment"># 容器网络路由</span><br><span class="hljs-comment"># 指示所有172.17.0.0/16的数据包将被发送到docker0虚拟桥接口，并使用源IP地址172.17.0.1</span><br>172.17.0.0/16 dev docker0 proto kernel scope <span class="hljs-built_in">link</span> src 172.17.0.1 <br><span class="hljs-comment"># virbr0虚拟网桥的路由，该路由无效，因为该接口已经下线（linkdown），所以无法路由任何数据包</span><br>192.168.122.0/24 dev virbr0 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.122.1 linkdown <br><br><span class="hljs-comment"># 查看容器网络地址</span><br>$ docker inspect nginx-test<br><br>`<br>[<br>    &#123;<br>        <span class="hljs-string">&quot;NetworkSettings&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Bridge&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;Ports&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;80/tcp&quot;</span>: null<br>            &#125;,<br>            <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;172.17.0.1&quot;</span>,      <span class="hljs-comment"># 容器网关</span><br>            <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;172.17.0.2&quot;</span>,    <span class="hljs-comment"># 容器IP地址</span><br>            <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: 16,<br>            <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:ac:11:00:02&quot;</span>,<br>            <span class="hljs-string">&quot;Networks&quot;</span>: &#123;<br>                <span class="hljs-string">&quot;bridge&quot;</span>: &#123;<br>                    <span class="hljs-string">&quot;Gateway&quot;</span>: <span class="hljs-string">&quot;172.17.0.1&quot;</span>,<br>                    <span class="hljs-string">&quot;IPAddress&quot;</span>: <span class="hljs-string">&quot;172.17.0.2&quot;</span>,<br>                    <span class="hljs-string">&quot;IPPrefixLen&quot;</span>: 16,<br>                    <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:ac:11:00:02&quot;</span>,<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br>`<br><br><span class="hljs-comment"># </span><br><span class="hljs-comment"># arp 找 mac 地址，然后icmp</span><br>$ ping 172.17.0.2<br><br><span class="hljs-comment"># 查看和管理网络设备的邻居表的命令</span><br><span class="hljs-comment"># 显示和管理 IPv4 和 IPv6 地址之间的转换、ARP 地址解析协议、NDP 邻居发现协议等内容</span><br><span class="hljs-comment"># 显示当前主机的网络路由表和 ARP 缓存表，包括 IP 地址到 MAC 地址的映射关系</span><br>$ ip n<br>172.17.0.2 dev docker0 lladdr 02:42:ac:11:00:02 STALE<br>10.16.207.254 dev enp1s0 lladdr 6c:e5:f7:6b:79:61 DELAY<br>169.254.169.254 dev enp1s0 lladdr fe:ff:ff:ff:ff:ff REACHABLE<br><br><br><span class="hljs-comment"># docker内部网络列表</span><br>$ docker network <span class="hljs-built_in">ls</span><br>NETWORK ID          NAME                DRIVER              SCOPE<br>71e49c08add7        bridge              bridge              <span class="hljs-built_in">local</span><br>ec4c0f0642bd        host                host                <span class="hljs-built_in">local</span><br>0750ef78e913        none                null                <span class="hljs-built_in">local</span><br><br><br><span class="hljs-comment"># 查看网桥</span><br>$ brctl show<br>bridge name     bridge <span class="hljs-built_in">id</span>               STP enabled     interfaces<br>docker0         8000.024257229552       no              veth71942f7   <span class="hljs-comment"># 容器与宿主机之间的通信</span><br>virbr0          8000.5254003c195a       <span class="hljs-built_in">yes</span>             virbr0-nic    <span class="hljs-comment"># 虚拟机之间提供网络通信</span><br><br><br><span class="hljs-comment"># bridge模式下</span><br><span class="hljs-comment"># docker daemon守护进程会创建一对对等虚拟设备接口 veth pair</span><br><span class="hljs-comment"># 将其中一个接口设置为容器的 eth0 接口（容器的网卡）</span><br><span class="hljs-comment"># 另一个接口放置在宿主机的命名空间中，以类似 vethxxx 这样的名字命名，从而将宿主机上的所有容器都连接到这个内部网络上</span><br><span class="hljs-comment"># 从网桥 docker0 的私有地址空间中分配一个 IP 地址和子网给该容器</span><br><span class="hljs-comment"># 并设置 docker0 的 IP 地址为容器的默认网关</span><br><br><span class="hljs-comment"># 查看bridge模式下的容器</span><br>$ docker network inspect bridge<br><br>`&#123;<br>   <span class="hljs-string">&quot;Containers&quot;</span>: &#123;<br>      <span class="hljs-string">&quot;f554d6ebfc496a20ed6ac0644d2b4f49bab12536ac446a86485f43516c942e93&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;Name&quot;</span>: <span class="hljs-string">&quot;nginx-test&quot;</span>,<br>            <span class="hljs-string">&quot;EndpointID&quot;</span>: <span class="hljs-string">&quot;xxx&quot;</span>,<br>            <span class="hljs-string">&quot;MacAddress&quot;</span>: <span class="hljs-string">&quot;02:42:ac:11:00:02&quot;</span>,<br>            <span class="hljs-string">&quot;IPv4Address&quot;</span>: <span class="hljs-string">&quot;172.17.0.2/16&quot;</span>,<br>            <span class="hljs-string">&quot;IPv6Address&quot;</span>: <span class="hljs-string">&quot;&quot;</span><br>      &#125;<br>   &#125;<br>&#125;`<br></code></pre></td></tr></table></figure><p>docker 之中部署了一个nginx，那么访问该nginx服务，数据走向是怎么样的，经历了多少个网卡：</p><ol><li>路由表来看，目标IP地址172.17.0.2属于172.17.0.0&#x2F;16子网，数据包会被发送到docker0接口上;</li><li>数据包被Docker虚拟网络处理，最终被路由到与容器172.17.0.2对应的网络命名空间中，从而到达容器内部;</li></ol><p><img src="/images/docker-bridge.png" alt="docker bridge下网络模式"><br><img src="/images/docker-host.webp" alt="docker host的网络模式"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-将网络接口-网卡-添加到网桥之中会怎么样"><a href="#1-将网络接口-网卡-添加到网桥之中会怎么样" class="headerlink" title="1.将网络接口(网卡)添加到网桥之中会怎么样"></a>1.将网络接口(网卡)添加到网桥之中会怎么样</h5><ol><li>将网卡加入网桥，该网卡可以接收和转发网桥中其他网络设备（包括其他网卡、虚拟机等）发送的数据包。</li><li>该网卡也可以向网桥中的其他设备发送数据包，从而实现网络通信。</li><li>通过使用网桥，可以在不同的网络设备之间进行透明的通信，就像它们直接相连一样.</li></ol><blockquote><p>同一个网桥的设备之间可以通信；</p></blockquote><h5 id="2-sudo-brctl-addif-my-net-eth0-这句话什么意思，lo的流量会怎么走"><a href="#2-sudo-brctl-addif-my-net-eth0-这句话什么意思，lo的流量会怎么走" class="headerlink" title="2.sudo brctl addif my-net eth0 这句话什么意思，lo的流量会怎么走"></a>2.sudo brctl addif my-net eth0 这句话什么意思，lo的流量会怎么走</h5><ul><li>将 “eth0” 的物理网络接口（network interface）添加到名为 “my-net” 的 Linux 桥接器（bridge）上。</li><li>“eth0” 的网络流量转发到该桥接器上，以便与其他连接到该桥接器的设备进行通信。</li></ul><h5 id="3-网络接口lo流量走向"><a href="#3-网络接口lo流量走向" class="headerlink" title="3.网络接口lo流量走向"></a>3.网络接口lo流量走向</h5><ul><li>系统上的本地回环接口（loopback interface）；</li><li>同一系统内部发送和接收数据包；</li><li>lo的流量不会通过该桥接器或任何其他物理网络接口，直接在内核中传递，计算机内部进行循环传输；</li></ul><h5 id="4-docker容器是net-x3D-none的，可以直接访问容器内部吗"><a href="#4-docker容器是net-x3D-none的，可以直接访问容器内部吗" class="headerlink" title="4.docker容器是net&#x3D;none的，可以直接访问容器内部吗"></a>4.docker容器是net&#x3D;none的，可以直接访问容器内部吗</h5><p>   如果将容器的网络类型设置为net&#x3D;none，那么容器将完全没有网络访问权限，无论是从容器内部访问外部网络，还是从外部网络访问容器内部的服务都不可能实现。</p><h5 id="5-docker的网络类型有哪些"><a href="#5-docker的网络类型有哪些" class="headerlink" title="5.docker的网络类型有哪些"></a>5.docker的网络类型有哪些</h5><p>   bridge或者host模式，默认使用的是bridge网络模，在bridge网络模式下，容器的IP地址是通过NAT(Network Address Translation，网络地址转换)进行转换的，所以从容器外部无法直接访问容器内部的IP地址。<br>   Docker daemon创建的docker0虚拟网桥，会为每个容器分配一个私有的IP地址。<br>   当容器需要与外部网络通信时，容器的私有IP地址会被NAT为宿主机的IP地址，并通过宿主机上的网络接口与外部网络通信。<br>   这样可以让多个容器共享一个宿主机的公网IP地址，从而节省公网IP地址的使用。</p><h5 id="6-Docker的NAT是什么"><a href="#6-Docker的NAT是什么" class="headerlink" title="6.Docker的NAT是什么"></a>6.Docker的NAT是什么</h5><ol><li>NAT（Network Address Translation）NAT功能通过Linux内核的iptables实现；</li><li>将Docker容器中的私有IP地址（通常是172.17.x.x）映射到宿主机的公共IP地址上，实现容器和宿主机之间的通信；</li><li>当容器访问外部网络时，Docker将数据包NAT处理，私有IP地址替换为宿主机的公共IP地址，以实现容器和外部网络之间的通信；</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ iptables -t nat -L -n<br><br><span class="hljs-comment"># 下面是docker NAT 输出规则</span><br><span class="hljs-comment"># 目的是实现docker容器访问外部网络</span><br><span class="hljs-comment"># 将来自172.17.0.0/16网段的所有数据包的源地址改为主机的IP地址</span><br><span class="hljs-comment"># 并将它们发送到目的地0.0.0.0/0</span><br>Chain POSTROUTING (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>MASQUERADE  all  --  172.17.0.0/16        0.0.0.0/0   <br>‘<br><br><span class="hljs-comment"># 至于访问外部网络可以直接走路由规则将所有172.17.0.0/16网段数据包发172.17.0.1</span><br><span class="hljs-comment"># 也就是docker0网桥</span><br>172.17.0.0/16 dev docker0 proto kernel scope <span class="hljs-built_in">link</span> src 172.17.0.1<br><br><br><span class="hljs-comment"># docker网桥</span><br>docker0: inet 172.17.0.1/16 scope global docker0<br><br><span class="hljs-comment"># docker0网桥上插着每个容器网络命名空间的网卡的pair对端网卡</span><br>$ brctl show<br>bridge name     bridge <span class="hljs-built_in">id</span>               STP enabled     interfaces<br>br1             8000.62429a077f4c       no              veth1<br>br2             8000.aa0bfb51ea56       no              veth3<br>docker0         8000.024236ffee25       no              veth0c7094b(nginx1)<br>                                                        veth40a4dc5(nginx2)<br>                                                        vethdbe644d(nginx3)<br></code></pre></td></tr></table></figure><h5 id="7-docker的网络类型bridge和host有什么区别"><a href="#7-docker的网络类型bridge和host有什么区别" class="headerlink" title="7.docker的网络类型bridge和host有什么区别"></a>7.docker的网络类型bridge和host有什么区别</h5><ol><li>Bridge网络类型是Docker默认的网络类型，而Host网络类型是指容器直接使用宿主机的网络，不会进行网络隔离。</li><li>Bridge网络类型在容器和宿主机之间建立虚拟网络，容器之间可以通过容器名或者IP地址相互通信，但是容器和宿主机之间需要映射端口才能通信。</li><li>Host网络类型直接使用宿主机的网络，容器可以直接访问宿主机的所有端口和网络设备，但是容器之间的网络隔离失效。</li><li>Bridge网络类型可以使用Docker内置的DNS服务来访问其他容器的服务，而Host网络类型需要使用宿主机的DNS服务来访问其他服务。</li><li>Bridge网络类型可以使用Docker内置的端口映射来将容器内部的端口映射到宿主机的端口，从而实现容器与外部的通信。而Host网络类型不需要进行端口映射，直接使用宿主机的端口即可。</li></ol><h5 id="8-ip-a和ifconfig有什么区别"><a href="#8-ip-a和ifconfig有什么区别" class="headerlink" title="8.ip a和ifconfig有什么区别"></a>8.<code>ip a</code>和<code>ifconfig</code>有什么区别</h5><p>都是用来显示系统网络配置信息的命令:</p><ol><li>ip a是较新的命令，能够显示更丰富的网络信息，包括IPv4和IPv6地址、MAC地址等，而ifconfig只能显示IPv4地址和MAC地址。</li><li>ip a命令在处理网络配置时更加灵活，支持更多的网络参数设置，而ifconfig则不支持。</li><li>ip a命令输出的信息更易于理解和解析，而ifconfig输出的信息比较混乱，需要进行额外的处理才可读。</li></ol><h5 id="9-veth-pair技术"><a href="#9-veth-pair技术" class="headerlink" title="9.veth pair技术"></a>9.veth pair技术</h5><ul><li>veth pair 技术是一种网络虚拟化技术，它能够创建一对虚拟的网络设备（veth pair），这对设备之间通过一个虚拟的网络连接在一起。</li><li>每个 veth pair 都包含两个端点，一个端点被称为veth0，另一个端点被称为veth1，它们可以被分别连接到不同的网络命名空间中。</li><li>veth pair 技术通常被用于实现容器网络，因为它可以使容器中的应用程序共享主机系统的网络设备，而不必在容器中运行一个独立的网络堆栈。</li></ul><h5 id="10-NAT功能通过Linux内核的iptables实现"><a href="#10-NAT功能通过Linux内核的iptables实现" class="headerlink" title="10.NAT功能通过Linux内核的iptables实现"></a>10.NAT功能通过Linux内核的iptables实现</h5><ol><li>Network Address Translation (NAT) 功能可以通过 Linux 内核的 iptables 工具来实现。</li><li>但不是NAT都是需要用iptables实现，除了iptables，iproute2工具集中的ip命令可以用于配置和管理网络地址转换。</li><li>如netfilter和conntrack等，也可以在Linux系统上实现高级的NAT功能。</li></ol><h5 id="11-网桥相关概念"><a href="#11-网桥相关概念" class="headerlink" title="11.网桥相关概念"></a>11.网桥相关概念</h5><ol><li>网桥（Bridge）可用于连接两个或多个网络段，使其成为一个逻辑局域网（LAN）。</li><li>OSI模型的第二层，即数据链路层（MAC地址）。它通过学习和转发数据包的MAC地址来实现网络段之间的通信。</li><li>基本原理：当数据包到达网桥的一个接口，网桥会依据数据包的目的MAC地址，并将其发送到与该目的地址相应的接口上。</li><li>根据MAC地址进行转发，而不是根据IP地址，网桥可以在一个局域网中连接不同的IP子网。</li></ol><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://zhuanlan.zhihu.com/p/293659939#">linux veth pair详解</a><br><a href="https://zhuanlan.zhihu.com/p/557146190">6 张图详解 Docker 容器网络配置</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>什么是网络命名空间</title>
    <link href="/2023/06/05/cni/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/"/>
    <url>/2023/06/05/cni/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是-Network-Namespace"><a href="#一、什么是-Network-Namespace" class="headerlink" title="一、什么是 Network Namespace"></a>一、什么是 Network Namespace</h3><ol><li>Network Namespace 是用于在Linux系统中创建虚拟网络的一种机制；</li><li>可将物理主机划分为多个逻辑上独立的网络空间(独立的网络设备、IP地址、路由表、防火墙等)；</li><li>常用于虚拟机、容器等技术；</li></ol><h3 id="二、如何创建和使用-Network-Namespace"><a href="#二、如何创建和使用-Network-Namespace" class="headerlink" title="二、如何创建和使用 Network Namespace"></a>二、如何创建和使用 Network Namespace</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 对于每个 Network Namespace 来说，它会有自己独立的网卡、路由表、ARP 表、iptables 等和网络相关的资源</span><br><span class="hljs-comment"># 安装iproute</span><br>$ yum install -y iproute<br><br><span class="hljs-comment"># 查看当前网络命名空间</span><br>$ ip netns list<br><br><span class="hljs-comment"># 创建一个新的网络名称空间</span><br>$ ip netns add ns0<br>$ <span class="hljs-built_in">ls</span> /var/run/netns/<br><br><br><span class="hljs-comment"># Network Namespace 中执行命令使用 `ip netns exec` 子命令</span><br><span class="hljs-comment"># 新创建的 Network Namespace 中会默认创建一个 lo 回环网卡，此时网卡处于关闭状态</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ip addr<br>1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br><br><br><span class="hljs-comment"># 由于lo环回网卡关闭状态</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ping 127.0.0.1<br>ping: connect: 网络不可达<br><br><span class="hljs-comment"># 启用lo环回网卡</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> lo up<br><br><span class="hljs-comment"># 启用后可以ping通</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ping 127.0.0.1<br>PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.<br>64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.039 ms<br>64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.038 ms<br></code></pre></td></tr></table></figure><h3 id="三、Veth-Pair-Virtual-Ethernet-Pair"><a href="#三、Veth-Pair-Virtual-Ethernet-Pair" class="headerlink" title="三、Veth Pair (Virtual Ethernet Pair)"></a>三、Veth Pair (Virtual Ethernet Pair)</h3><blockquote><p>利用 veth pair 实现两个不同的 Network Namespace 之间的通信</p></blockquote><ol><li>添加网络命名空间</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip netns add ns1<br>$ ip netns list<br>ns1<br>ns0<br></code></pre></td></tr></table></figure><ol start="2"><li>创建veth pair对<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建 veth pair</span><br>$ ip <span class="hljs-built_in">link</span> add veth7 <span class="hljs-built_in">type</span> veth peer name veth1-peer<br><br><span class="hljs-comment"># 新增了一对 veth pair，将 veth0 和 veth1 两个虚拟网卡</span><br><span class="hljs-comment"># 这对 veth pair 处于”未启用“状态</span><br>$ ip a<br>12: veth1-peer@veth7: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether 3e:2d:37:f9:93:c2 brd ff:ff:ff:ff:ff:ff<br>13: veth7@veth1-peer: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000<br>    <span class="hljs-built_in">link</span>/ether e6:8c:12:d8:53:57 brd ff:ff:ff:ff:ff:ff<br>    <br><span class="hljs-comment"># 将 veth0 加入到 ns0，将 veth1 加入到 ns1</span><br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1-peer netns ns1<br>$ ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth7 netns ns0<br><br><span class="hljs-comment"># 查看各个网络命名空间的网络接口</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ip a<br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br><br><span class="hljs-comment"># 网络命名空间ns0启用veth1-peer</span><br><span class="hljs-comment"># 配置上 ip 地址</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth7 up<br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ip a<br>$ ip netns <span class="hljs-built_in">exec</span> ns0 ip addr add 192.0.0.1/24 dev veth7<br><br><span class="hljs-comment"># 网络命名空间ns1启用veth7</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip a<br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> veth1-peer up<br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ip addr add 192.0.0.2/24 dev veth1-peer<br><br><span class="hljs-comment">#  ns1 中访问 ns0 中的 ip 地址</span><br>$ ip netns <span class="hljs-built_in">exec</span> ns1 ping 192.0.0.1<br><br>PING 192.0.0.1 (192.0.0.1) 56(84) bytes of data.<br>64 bytes from 192.0.0.1: icmp_seq=1 ttl=64 time=0.056 ms<br>64 bytes from 192.0.0.1: icmp_seq=2 ttl=64 time=0.041 ms<br></code></pre></td></tr></table></figure></li></ol><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://zhuanlan.zhihu.com/p/557146190">6张图详解Docker容器网络配置进击云原生</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在k8s之中部署loki服务存储日志</title>
    <link href="/2023/06/03/loki/%E5%9C%A8k8s%E5%88%9B%E5%BB%BAloki%E6%9C%8D%E5%8A%A1%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97/"/>
    <url>/2023/06/03/loki/%E5%9C%A8k8s%E5%88%9B%E5%BB%BAloki%E6%9C%8D%E5%8A%A1%E9%87%87%E9%9B%86%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装步骤"><a href="#一、安装步骤" class="headerlink" title="一、安装步骤"></a>一、安装步骤</h3><ol><li>安装<a href="https://github.com/helm/helm/releases">helm</a>工具</li><li>访问 <a href="https://artifacthub.io/">artifacthub</a> 添加 loki <a href="https://artifacthub.io/packages/helm/grafana/loki?modal=install">repo</a></li><li>导出helm包 grafana&#x2F;loki version 5.6.4</li><li>修改helm包增加 scrape config 增加采集目标</li><li>helm包重新打包</li><li>安装在k8s</li></ol><h3 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h3><ol><li>安装helm</li></ol><p>在k8s集群中安装helm，可以使用以下命令：</p><p><a href="https://github.com/helm/helm/releases">https://github.com/helm/helm/releases</a></p><p>只需要二进制程序下载后移动到 <code>/usr/local/bin</code> 目录。</p><ol start="2"><li>添加loki repo helm charts 仓库</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm repo add grafana https://grafana.github.io/helm-charts<br></code></pre></td></tr></table></figure><ol start="3"><li>导出helm包修改自定义采集路径</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm pull grafana/loki --version 5.6.4 --destination=./<br><br>loki-5.6.4.tgz<br></code></pre></td></tr></table></figure><ol start="4"><li>增加 scrape config 给 promtail 添加采集目标</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm pull grafana/promtail --version 6.11.3 --destination=./<br><span class="hljs-comment"># 解压 promtail-6.11.3.tgz</span><br>$ tar xvf promtail-6.11.3.tgz<br>$ <span class="hljs-built_in">cd</span> promtail &amp;&amp; vim values.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 添加 extraScrapeConfigs 和 目录挂载</span><br><span class="hljs-attr">extraScrapeConfigs:</span> <span class="hljs-string">|</span><br><span class="hljs-string">  - job_name: log</span><br><span class="hljs-string">    static_configs:</span><br><span class="hljs-string">    - targets:</span><br><span class="hljs-string">        - localhost</span><br><span class="hljs-string">      labels:</span><br><span class="hljs-string">        job: audit</span><br><span class="hljs-string">        __path__: /var/log/audit/*log</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 添加目录挂载</span><br><span class="hljs-attr">defaultVolumes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">audit</span><br>    <span class="hljs-attr">hostPath:</span><br>      <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log/audit</span><br><span class="hljs-attr">defaultVolumeMounts:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">audit</span><br>    <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/audit</span><br>    <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重新打包(可以在 Chart.yaml 更改 version)</span><br>$ helm package .<br><br><span class="hljs-comment"># 打包后生成helm包文件</span><br>promtail-6.11.3.tgz <br></code></pre></td></tr></table></figure><ol start="5"><li>将文件上传至主机后安装helm包</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm install promtail-6.11.3.tgz <br>$ helm uninstall promtail<br><span class="hljs-comment"># 安装在命名空间下</span><br>$ helm install promtail -n grafana ./promtail-6.11.3.tgz <br></code></pre></td></tr></table></figure><ol start="6"><li>创建service直接外部访问loki的api接口</li></ol><p><a href="https://kubernetes.io/zh-cn/docs/concepts/services-networking/service/">kubernetes.io之如何使用service NodePort</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看loki的详细的label</span><br>$ kubectl describe pod loki-0 -n loki<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">loki-service</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">grafana</span>              <span class="hljs-comment"># 注意和 pod 命名空间一致</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">app.kubernetes.io/name:</span> <span class="hljs-string">loki</span>  <span class="hljs-comment"># 指向pod的筛选项Labels</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">loki-port</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">3100</span>              <span class="hljs-comment"># 目标是 loki 服务端口 3100</span><br>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30009</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 应用svc服务</span><br>$ kubectl apply -f loki-service.yml<br><br><span class="hljs-comment"># 进 loki pod</span><br>$ kubectl <span class="hljs-built_in">exec</span> -it loki-0  -n loki -- /bin/sh<br><br><span class="hljs-comment"># 获取所有命名空间中的所有服务（Service）的网络终点（Endpoint）列表</span><br>$ kubectl get endpoints -A<br>$ kubectl get svc -A<br></code></pre></td></tr></table></figure><h3 id="三、服务查看"><a href="#三、服务查看" class="headerlink" title="三、服务查看"></a>三、服务查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://loki:30019/loki/api/v1/query_range?query=&#123;job=<span class="hljs-string">&quot;audit&quot;</span>&#125;|json<br>$ curl http://loki:30019/loki/api/v1/series<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-Kubernetes的meta-kubernetes-pod-node-name和meta-kubernetes-namespace和meta-kubernetes-pod-name标签-是什么意思，在哪里配置的"><a href="#1-Kubernetes的meta-kubernetes-pod-node-name和meta-kubernetes-namespace和meta-kubernetes-pod-name标签-是什么意思，在哪里配置的" class="headerlink" title="1.Kubernetes的meta_kubernetes_pod_node_name和meta_kubernetes_namespace和meta_kubernetes_pod_name标签 是什么意思，在哪里配置的"></a>1.Kubernetes的meta_kubernetes_pod_node_name和meta_kubernetes_namespace和meta_kubernetes_pod_name标签 是什么意思，在哪里配置的</h5><h5 id="2-scrape-configs解析"><a href="#2-scrape-configs解析" class="headerlink" title="2.scrape_configs解析"></a>2.scrape_configs解析</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">relabel_configs:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">source_labels:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">__meta_kubernetes_pod_node_name</span><br><span class="hljs-attr">target_label:</span> <span class="hljs-string">__host__</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">labelmap</span><br><span class="hljs-attr">regex:</span> <span class="hljs-string">__meta_kubernetes_pod_label_(.+)</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">action:</span> <span class="hljs-string">replace</span><br><span class="hljs-attr">replacement:</span> <span class="hljs-string">$1</span><br><span class="hljs-attr">separator:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">source_labels:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">__meta_kubernetes_namespace</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">__meta_kubernetes_pod_name</span><br><span class="hljs-attr">target_label:</span> <span class="hljs-string">job</span><br></code></pre></td></tr></table></figure><p>这段代码是promtail的scrape_configs的relabel_configs部分的一个示例，其具体含义如下：</p><ol><li><code>source_labels: __meta_kubernetes_pod_node_name</code> 指定了需要从哪个标签中获取数据，这里是meta_kubernetes_pod_node_name。</li><li><code>target_label: __host__</code> 指定了将要生成的新标签的名称，这里是host。</li><li><code>action: labelmap</code> 表示对标签进行映射操作。</li><li><code>regex: __meta_kubernetes_pod_label_(.+)</code> 指定了匹配到的正则表达式，其中__meta_kubernetes_pod_label_是标签的前缀，后面的(.+)则是匹配标签的值。</li><li><code>action: replace</code> 指定了对标签进行替换操作。</li><li><code>replacement: $1</code> 表示用匹配到的第一个分组（即(.+)中的内容）来替换目标标签中的内容。</li><li><code>separator: /</code> 表示使用斜线来分隔替换后的标签值。</li><li><code>source_labels: __meta_kubernetes_namespace</code> 和 <code>__meta_kubernetes_pod_name</code> 指定需要从哪些标签中获取数据，这里是meta_kubernetes_namespace和meta_kubernetes_pod_name。</li><li><code>target_label: job</code> 指定了将要生成的新标签的名称，这里是job。</li></ol><p>综上所述，这段代码的作用是从Kubernetes的meta_kubernetes_pod_node_name和meta_kubernetes_namespace和meta_kubernetes_pod_name标签中获取数据，并将其替换成新的标签__host__和job，以便更好地组织和过滤日志。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>loki</tag>
      
      <tag>promtail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch简介</title>
    <link href="/2023/06/02/cni/openvswitch%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/06/02/cni/openvswitch%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是Open-Flow协议"><a href="#一、什么是Open-Flow协议" class="headerlink" title="一、什么是Open Flow协议"></a>一、什么是Open Flow协议</h3><ul><li>网络通信协议，定义了在SDN下网络流量控制机制</li><li>目标是可编程的、可定制的、可调整的网络解决方案</li></ul><h3 id="二、启动ovs之后查看相关进程"><a href="#二、启动ovs之后查看相关进程" class="headerlink" title="二、启动ovs之后查看相关进程"></a>二、启动ovs之后查看相关进程</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps aux | grep openvswitch<br><br><span class="hljs-comment"># 查询进程ID为65191的进程打开的文件或网络套接字的命令</span><br>$ lsof -p 65191<br><br><span class="hljs-comment"># 查看进程打开了多少个文件或者网络套接字,有一个进程/usr/sbin/ovs-vswitchd</span><br>$ lsof -p 21764<br><br><span class="hljs-comment"># 有一个db进程 ovsdb-server /etc/openvswitch/conf.db</span><br>$ ps -ef | grep ovsdb-server<br><br><span class="hljs-comment"># 主要有2个进程 ovs-vswitchd 和 ovsdb-server</span><br></code></pre></td></tr></table></figure><h3 id="三、数据库结构和-ovs-vsctl-有2个进程"><a href="#三、数据库结构和-ovs-vsctl-有2个进程" class="headerlink" title="三、数据库结构和 ovs-vsctl 有2个进程"></a>三、数据库结构和 ovs-vsctl 有2个进程</h3><ul><li>ovsdb-server 维护数据库&#x2F;etc&#x2F;openvswitch&#x2F;conf.db</li><li>ovs-vswitchd 核心daemon</li><li>两者通过unix domain socket &#x2F;var&#x2F;run&#x2F;openvswitch&#x2F;db.sock 互相通信</li></ul><p>ovs-vsctl 与 ovsdb-server通信，来修改数据库。ovs-vswitchd会和ovsdb-server进行通信，来对虚拟设备做相应的修改。</p><p><img src="/images/vs-db1.png" alt="数据表结构"></p><blockquote><p>通过 <code>cat /etc/openvswitch/conf.db</code> 或者 <code>ovsdb-client dump</code> 可以查看数据库表</p></blockquote><p><img src="/images/ovs-db2.png" alt="数据表之间的关系"><br><img src="/images/ovs-1.png" alt="ovs在多台宿主机之间创建虚拟网桥网卡控制器形式转发流量"><br><img src="/images/ovs-3.png" alt="解释什么叫做流表"><br><img src="/images/ovs-2.png" alt="ovs在单宿主机之间数据走向标准"><br><img src="/images/ovs-4.png" alt="ovs与内核模块之间的关系"><br><img src="/images/ovs-arch.png" alt="ovs内部模块架构图"></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>东西向和南北向流量指的是什么</li></ol><p>东西向指的是pod与pod之间，南北向指的是宿主机和pod之间的流量。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://blog.csdn.net/wanglei1992721/article/details/105382332">set-manager主动连接ovsdb操作流解释</a></li><li><a href="https://www.cnblogs.com/popsuper1982/p/3800574.html">刘超的通俗云计算</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch安装</title>
    <link href="/2023/06/02/cni/openvswitch%E5%AE%89%E8%A3%85/"/>
    <url>/2023/06/02/cni/openvswitch%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装步骤概览"><a href="#一、安装步骤概览" class="headerlink" title="一、安装步骤概览"></a>一、安装步骤概览</h3><ul><li><a href="#1-%E4%B8%8B%E8%BD%BDovs-tar%E6%88%96%E8%80%85git-clone-%E6%BA%90%E7%A0%81">1. 下载ovs tar或者git clone 源码</a></li><li><a href="#2-configure">2. Configure</a></li><li><a href="#3-build">3. Build</a></li><li><a href="#4-starting">4. Starting</a></li><li><a href="#5-test">5. Test</a></li></ul><p>源码编译方式安装<a href="https://docs.openvswitch.org/en/latest/intro/install/general/">官方手册</a></p><ul><li>构建要求</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. GNU make<br>2. A C compiler, such as: <br>      GCC 4.6 or later<br>      Clang 3.4 or later<br>      MSVC 2013.<br>3. libssl (optional)<br>4. libcap-ng (optional)<br>5. Python 3.4 or later.<br>6. Unbound library (optional)<br></code></pre></td></tr></table></figure><ul><li>安装要求</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 与构建ovs库兼容的共享库<br>2. 兼容内核模块的内核<br>3. iproute2 中的<span class="hljs-string">&quot;tc&quot;</span> 程序 [<span class="hljs-built_in">link</span>](https://wiki.linuxfoundation.org/networking/iproute2)<br>4. /dev/urandom <span class="hljs-keyword">in</span> linux<br></code></pre></td></tr></table></figure><h3 id="二、开始安装"><a href="#二、开始安装" class="headerlink" title="二、开始安装"></a>二、开始安装</h3><ol><li>下载ovs tar或者git clone 源码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载页面</span><br>http://www.openvswitch.org//download/<br><span class="hljs-comment"># 选择版本</span><br>https://www.openvswitch.org/releases/openvswitch-3.1.1.tar.gz<br></code></pre></td></tr></table></figure><ol start="2"><li>下载ovs tar或者git clone 源码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压 </span><br>$ tar zxvf openvswitch-*.tar.gz<br><br><span class="hljs-comment"># 进入解压目录</span><br>$ <span class="hljs-built_in">cd</span> openvswitch-*<br></code></pre></td></tr></table></figure><ol start="3"><li>Configure</li></ol><p>参考<a href="https://docs.openvswitch.org/en/latest/intro/install/general/#configuring">install configuring</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># By default all files are installed under /usr/local. </span><br><span class="hljs-comment"># Open vSwitch also expects to find its database in /usr/local/etc/openvswitch by default. </span><br><span class="hljs-comment"># If you want to install all files into, e.g., </span><br><span class="hljs-comment"># /usr and /var instead of /usr/local and /usr/local/var </span><br><span class="hljs-comment"># and expect to use /etc/openvswitch as the default database directory, </span><br><span class="hljs-comment"># add options as shown here:</span><br><br><span class="hljs-comment"># 改变一下默认文件夹</span><br>$ ./configure --prefix=/usr --localstatedir=/var --sysconfdir=/etc<br></code></pre></td></tr></table></figure><ol start="3"><li>Build</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make<br>$ make install<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 内核模块开启查看</span><br><span class="hljs-comment"># 系统中加载openvswitch内核模块</span><br>$ /sbin/modprobe openvswitch<br>$ /sbin/lsmod | grep openvswitch<br></code></pre></td></tr></table></figure><ol start="4"><li>添加环境变量并启动服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方式一</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br>$ <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/share/openvswitch/scripts<br>$ ovs-ctl start<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方式二</span><br>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export PATH=<span class="hljs-variable">$PATH</span>:/usr/share/openvswitch/scripts&quot;</span> | <span class="hljs-built_in">tee</span> -a ~/.bash_profile<br>$ <span class="hljs-built_in">source</span> ~/.bash_profile<br>$ <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PATH</span><br></code></pre></td></tr></table></figure><ol start="5"><li>Test</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ovs-vsctl show<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>制作helm包和自建Chart仓库</title>
    <link href="/2023/06/01/kubernetes/%E5%88%B6%E4%BD%9Chelm%E5%8C%85%E5%92%8C%E8%87%AA%E5%BB%BAChart%E4%BB%93%E5%BA%93/"/>
    <url>/2023/06/01/kubernetes/%E5%88%B6%E4%BD%9Chelm%E5%8C%85%E5%92%8C%E8%87%AA%E5%BB%BAChart%E4%BB%93%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="一、Helm相关概念"><a href="#一、Helm相关概念" class="headerlink" title="一、Helm相关概念"></a>一、Helm相关概念</h3><p>Helm是一个kubernetes的包管理工具，软件包管理器 (类似ubuntu.apt centos.yum python.pip)，主要解决Kubernetes原生资源文件如deployment、replicationcontroller、service或pod等资源过于分散不好管理的问题。</p><ul><li>helm 命令行管理工具，kubernetes应用chart（创建、打包、发布和管理）</li><li>chart 应用描述（kubernetes资源相关文件的集合），相当于是k8s的Yum RPM</li><li>release 基于chart的部署实体，chart被Helm运行后生成一个release,比如MySQL chart可以有很多个实例（每一次安装有它自己的 release &amp;&amp; release name）</li><li>Repository 存放和共享 charts 的地方</li></ul><p><a href="https://helm.sh/zh/docs/intro/using_helm/">Helm QuickStart</a></p><h3 id="二、安装方式"><a href="#二、安装方式" class="headerlink" title="二、安装方式"></a>二、安装方式</h3><ol><li>使用脚本安装</li><li>用二进制版本安装(tar -zxvf)</li></ol><h3 id="三、常用功能"><a href="#三、常用功能" class="headerlink" title="三、常用功能"></a>三、常用功能</h3><h5 id="1-安装开源包"><a href="#1-安装开源包" class="headerlink" title="1.安装开源包"></a>1.安装开源包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># https://artifacthub.io/</span><br><span class="hljs-comment"># 如MySQL https://artifacthub.io/packages/helm/bitnami/mysql</span><br>$ helm repo add bitnami https://charts.bitnami.com/bitnami<br>$ helm install my-mysql bitnami/mysql --version 9.10.4<br>$ helm status my-mysql<br>$ helm repo update<br>$ helm --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><h5 id="2-自定义包"><a href="#2-自定义包" class="headerlink" title="2.自定义包"></a>2.自定义包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># https://helm.sh/zh/docs/intro/using_helm/#创建你自己的-charts</span><br>$ helm create my-package<br>$ <span class="hljs-built_in">cd</span> my-package &amp;&amp; tree .<br>.<br>├── Chart.yaml                    <span class="hljs-comment"># Helm chart 包的元数据文件，包含 chart 的名称、版本、描述等信息。</span><br>├── charts                        <span class="hljs-comment"># 子 chart 的目录，用于管理依赖的 chart</span><br>├── templates                     <span class="hljs-comment"># 模板文件的目录，用于生成 Kubernetes 的资源清单</span><br>│   ├── NOTES.txt                 <span class="hljs-comment"># 包含了 chart 的信息和指引用户如何使用 chart</span><br>│   ├── _helpers.tpl              <span class="hljs-comment"># 定义和存储可重用的模板函数</span><br>│   ├── deployment.yaml           <span class="hljs-comment"># 模板文件，用来生成 Kubernetes Deployment 资源的清单</span><br>│   ├── hpa.yaml                  <span class="hljs-comment"># 创建 Kubernetes 的 HorizontalPodAutoscaler（HPA）资源对象</span><br>│   ├── ingress.yaml              <span class="hljs-comment"># 模板文件，用来生成 Kubernetes Ingress 资源的清单</span><br>│   ├── service.yaml              <span class="hljs-comment"># 模板文件，用来生成 Kubernetes Service 资源的清单</span><br>│   ├── serviceaccount.yaml       <span class="hljs-comment"># 模板文件，用来生成 Kubernetes ServiceAccount 资源的清单</span><br>│   └── tests                     <span class="hljs-comment"># 测试文件夹</span><br>│       └── test-connection.yaml  <span class="hljs-comment"># 测试Kubernetes集群连接是否正常的配置文件</span><br>└── values.yaml                   <span class="hljs-comment"># 默认的值文件，存储所有的配置项及其默认值。</span><br><br><br><span class="hljs-comment"># 打包当前文件夹</span><br>$ helm package ./my-package<br>my-package-0.1.0.tgz<br><br>$ helm install my-package ./my-package-0.1.0.tgz<br></code></pre></td></tr></table></figure><h3 id="四、自建仓库"><a href="#四、自建仓库" class="headerlink" title="四、自建仓库"></a>四、自建仓库</h3><h5 id="1-创建仓库"><a href="#1-创建仓库" class="headerlink" title="1.创建仓库"></a>1.创建仓库</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># github page 可以用于建设helm repo</span><br><span class="hljs-comment"># 响应GET请求的HTTP服务器即可作为chart仓库</span><br>$ <span class="hljs-built_in">mkdir</span> my-repo<br>$ <span class="hljs-built_in">mv</span> ./my-package-0.1.0.tgz my-repo<br><span class="hljs-comment"># helm repo index [DIR] [flags]</span><br><span class="hljs-comment"># helm repo index命令会基于给定的包含chart包的本地目录生成一个index文件</span><br><span class="hljs-comment"># --url 会在生成的 index.yaml 的package注明完整的包访问路径</span><br>$ helm repo index my-repo --url http://127.0.0.1:9090<br>$ tree ./my-repo <br>./my-repo<br>├── deis-workflow-0.1.0.tgz<br>└── index.yaml<br></code></pre></td></tr></table></figure><h5 id="2-启动http文件服务"><a href="#2-启动http文件服务" class="headerlink" title="2.启动http文件服务"></a>2.启动http文件服务</h5><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readFile</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>file, err := os.Open(fmt.Sprintf(<span class="hljs-string">&quot;/home/my-repo/%s&quot;</span>, r.RequestURI))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, err.Error(), http.StatusInternalServerError)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(file *os.File)</span></span> &#123;<br>_ = file.Close()<br>&#125;(file)<br>content := <span class="hljs-built_in">make</span>([]<span class="hljs-type">byte</span>, <span class="hljs-number">1024</span>)<br><span class="hljs-keyword">for</span> &#123;<br>bytesRead, err := file.Read(content)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>_, _ = w.Write(content[:bytesRead])<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, readFile)<br>err := http.ListenAndServe(<span class="hljs-string">&quot;:9090&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatal(<span class="hljs-string">&quot;ListenAndServe: &quot;</span>, err)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下面访问可以下载文件则chart仓库可用</span><br>$ wget http://127.0.0.1:9090/deis-workflow-0.1.0.tgz<br>$ wget http://127.0.0.1:9090/index.yaml<br></code></pre></td></tr></table></figure><h5 id="3-添加仓库到本地并拉取helm包"><a href="#3-添加仓库到本地并拉取helm包" class="headerlink" title="3.添加仓库到本地并拉取helm包"></a>3.添加仓库到本地并拉取helm包</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># github page 可以用于建设helm repo</span><br>$ helm repo add my-repo http://localhost:9191/      <br><span class="hljs-string">&quot;my-repo&quot;</span> has been added to your repositories<br><br>$ helm repo list<br>xuweiqiang@xuweiqiangs-Mac-mini Documents % helm repo list<br>NAME     URL                                              <br>bitnami  https://charts.bitnami.com/bitnami<br>my-repo  http://localhost:9191/<br><br><span class="hljs-comment"># 罗列仓库my-repo包</span><br>$ helm search repo my-repo<br>NAME                 CHART  VERSION  APP VERSIONDESCRIPTION                <br>my-repo/deis-workflow0.1.0  1.16.0     A Helm chart <span class="hljs-keyword">for</span> Kubernetes<br><br><span class="hljs-comment"># 拉取helm包到本地</span><br>$ helm pull my-repo/deis-workflow --version 0.1.0 --destination=./<br></code></pre></td></tr></table></figure><h3 id="五、使用harbor建Chart仓库"><a href="#五、使用harbor建Chart仓库" class="headerlink" title="五、使用harbor建Chart仓库"></a>五、使用harbor建Chart仓库</h3><p><a href="https://goharbor.io/">https://goharbor.io/</a></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li>在没有k8s环境下执行helm install提示</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Error: INSTALLATION FAILED: Kubernetes cluster unreachable: <br>Get <span class="hljs-string">&quot;https://10.76.138.115:6443/version&quot;</span>: dial tcp 10.76.138.115:6443: connect: no route to host<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://helm.sh/zh/docs/intro/using_helm/#%E5%AE%89%E8%A3%85%E5%89%8D%E8%87%AA%E5%AE%9A%E4%B9%89-chart">自定义chart</a><br><a href="https://helm.sh/zh/docs/helm/helm/">Helm 命令集合</a><br><a href="https://helm.sh/zh/docs/chart_template_guide/getting_started/">chart 语法大全</a><br><a href="https://bbs.huaweicloud.com/blogs/280351">helm究竟是什么</a><br><a href="https://artifacthub.io/">https://artifacthub.io/</a><br><a href="https://pkg.go.dev/text/template">https://pkg.go.dev/text/template</a><br><a href="https://helm.sh/zh/docs/topics/chart_repository/">helm自建Chart仓库指南</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>helm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes审计日志</title>
    <link href="/2023/05/23/kubernetes/kubernetes%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/"/>
    <url>/2023/05/23/kubernetes/kubernetes%E5%AE%A1%E8%AE%A1%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="一、审计日志的策略"><a href="#一、审计日志的策略" class="headerlink" title="一、审计日志的策略"></a>一、审计日志的策略</h3><ol><li>日志记录阶段</li></ol><p>kube-apiserver 是负责接收及相应用户请求的一个组件，每一个请求都会有几个阶段，每个阶段都有对应的日志，当前支持的阶段有：</p><ul><li>RequestReceived - apiserver 在接收到请求后且在将该请求下发之前会生成对应的审计日志</li><li>ResponseStarted - 在响应 header 发送后并在响应 body 发送前生成日志。这个阶段仅为长时间运行的请求生成（例如 watch）</li><li>ResponseComplete - 当响应 body 发送完并且不再发送数据</li><li>Panic - 当有 panic 发生时生成</li></ul><blockquote><p> apiserver 的每一个请求理论上会有三个阶段的审计日志生成</p></blockquote><ol start="2"><li>日志记录级别</li></ol><ul><li>None - 不记录日志。</li><li>Metadata - 只记录 Request 的一些 metadata (例如 user, timestamp, resource, verb 等)，但不记录 Request 或 Response 的body。</li><li>Request - 记录 Request 的 metadata 和 body。</li><li>RequestResponse - 最全记录方式，会记录所有的 metadata、Request 和 Response 的 body。</li></ul><ol start="3"><li>日志记录策略</li></ol><ul><li>一个请求不要重复记录，每个请求有三个阶段，只记录其中需要的阶段</li><li>不要记录所有的资源，不要记录一个资源的所有子资源</li><li>系统的请求不需要记录，kubelet、kube-proxy、kube-scheduler、kube-controller-manager 等对 kube-apiserver 的请求不需要记录</li><li>对一些认证信息（secerts、configmaps、token 等）的 body 不记录</li></ul><h3 id="二、启用审计日志"><a href="#二、启用审计日志" class="headerlink" title="二、启用审计日志"></a>二、启用审计日志</h3><ol><li>在宿主机创建文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /etc/kubernetes/audit/<br>$ <span class="hljs-built_in">touch</span> /etc/kubernetes/audit/audit-policy.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># /etc/kubernetes/audit/audit-policy.</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">audit.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Policy</span><br><span class="hljs-comment"># ResponseStarted 阶段不记录</span><br><span class="hljs-attr">omitStages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;ResponseStarted&quot;</span><br><span class="hljs-attr">rules:</span><br>  <span class="hljs-comment"># 记录用户对 pod 和 statefulset 的操作</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">RequestResponse</span><br>    <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;&quot;</span><br>      <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;pods&quot;</span>,<span class="hljs-string">&quot;pods/status&quot;</span>]<br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;apps&quot;</span><br>      <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;statefulsets&quot;</span>,<span class="hljs-string">&quot;statefulsets/scale&quot;</span>]<br>  <span class="hljs-comment"># kube-controller-manager、kube-scheduler 等已经认证过身份的请求不需要记录</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">None</span><br>    <span class="hljs-attr">userGroups:</span> [<span class="hljs-string">&quot;system:authenticated&quot;</span>]<br>    <span class="hljs-attr">nonResourceURLs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/api*&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/version&quot;</span><br>  <span class="hljs-comment"># 对 config、secret、token 等认证信息不记录请求体和返回体</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">level:</span> <span class="hljs-string">Metadata</span><br>    <span class="hljs-attr">resources:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">group:</span> <span class="hljs-string">&quot;&quot;</span> <span class="hljs-comment"># core API group</span><br>      <span class="hljs-attr">resources:</span> [<span class="hljs-string">&quot;secrets&quot;</span>, <span class="hljs-string">&quot;configmaps&quot;</span>]<br></code></pre></td></tr></table></figure><ol start="2"><li>配置静态pod记录审计日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim /etc/kubernetes/manifests/kube-apiserver.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 日志文件保留7天，并保留最近的5个备份。</span><br><span class="hljs-comment"># 如果日志文件大小超过100MB，它也将被轮转。当日志文件到达最大保留时间或备份数时，较旧的日志文件将被删除。</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">command:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">kube-apiserver</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--audit-policy-file=/etc/kubernetes/audit/audit-policy.yaml</span>            <span class="hljs-comment"># 审计日志配置</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--audit-log-path=/var/log/containers/audit.log</span>                         <span class="hljs-comment"># 输出到标准输出</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--audit-log-format=json</span>                                                <span class="hljs-comment"># 输出格式json</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--audit-log-maxage=7</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--audit-log-maxbackup=5</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">--audit-log-maxsize=100</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 日志文件展示</span><br>$ <span class="hljs-built_in">ls</span> /var/log/containers/ | grep audit<br><br>audit-2023-06-05T07-12-55.439.<span class="hljs-built_in">log</span> <span class="hljs-comment"># 备份文件最大100MB</span><br>audit-2023-06-05T07-12-52.231.<span class="hljs-built_in">log</span> <span class="hljs-comment"># 备份文件</span><br>audit-2023-06-05T07-12-55.891.<span class="hljs-built_in">log</span> <span class="hljs-comment"># 备份文件</span><br>audit-2023-06-05T07-12-58.439.<span class="hljs-built_in">log</span> <span class="hljs-comment"># 备份文件</span><br>audit-2023-06-05T07-12-58.786.<span class="hljs-built_in">log</span> <span class="hljs-comment"># 备份文件</span><br>audit. <span class="hljs-comment"># 最新的日志文件，超过100MB会自动轮转</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 创建两个卷etc-audit &amp;&amp; audit-log分别挂载容器内的两个路径</span><br><span class="hljs-attr">volumeMounts:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/etc/kubernetes/audit</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">etc-audit</span><br>  <span class="hljs-attr">readOnly:</span> <span class="hljs-literal">true</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/var/log/containers/</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">audit-log</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 将两个卷 etc-audit &amp;&amp; audit-log 分别挂载至宿主机</span><br><span class="hljs-attr">volumes:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/etc/kubernetes/audit</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">etc-audit</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">hostPath:</span><br>    <span class="hljs-attr">path:</span> <span class="hljs-string">/var/log/containers</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">DirectoryOrCreate</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">audit-log</span><br></code></pre></td></tr></table></figure><blockquote><p>更改了之后会自动重启 kube-apiserver</p></blockquote><ol start="3"><li>审计日志查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pod -A<br>$ kubectl logs kube-apiserver-k8s-master -n kube-system -f<br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>开启审计日志后时不时会有2条日志是干嘛的</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json"># ResponseComplete /api/v1/namespaces/kube-system/configmaps?watch=<span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;system:node:k8s-master&quot;</span><span class="hljs-punctuation">&#125;</span><br># RequestReceived /api/v1/namespaces/kube-system/configmaps?watch=<span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;user&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;system:node:k8s-master&quot;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85kubernetes/">kubernertes安装</a><br><a href="https://www.jianshu.com/p/8117bc2fb966">简书&#x2F;kubernetes 审计日志功能</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/audit/">任务&#x2F;日志监控&#x2F;审计</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux发行版和包管理工具</title>
    <link href="/2023/05/19/linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"/>
    <url>/2023/05/19/linux/Linux%E5%8F%91%E8%A1%8C%E7%89%88%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="一、发行版本关系图"><a href="#一、发行版本关系图" class="headerlink" title="一、发行版本关系图"></a>一、发行版本关系图</h3><p><img src="/images/linux%E5%8F%91%E8%A1%8C%E7%89%88.png" alt="linux发行版"></p><h3 id="二、-包管理工具"><a href="#二、-包管理工具" class="headerlink" title="二、 包管理工具"></a>二、 包管理工具</h3><ol><li>dpkg (Ubuntu、Debian)</li><li>apt (Ubuntu、Debian) </li><li>rpm (RHEL、CentOS)</li><li>yum (CentOS6、CentOS7)</li><li>dnf (RHEL8、CentOS8)</li><li>apt-get,apt的旧版本</li></ol><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://github.com/FabioLolix/LinuxTimeline/releases/">非常详细的linux发行版大全</a><br><a href="https://zhuanlan.zhihu.com/p/562391617">五种常见 Linux 系统安装包管理工具中文使用指南</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux结构组成</title>
    <link href="/2023/05/19/linux/Linux%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90/"/>
    <url>/2023/05/19/linux/Linux%E7%BB%93%E6%9E%84%E7%BB%84%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、操作系统结构图"><a href="#一、操作系统结构图" class="headerlink" title="一、操作系统结构图"></a>一、操作系统结构图</h3><ol><li>Linux系统一般有四个主要部分：内核、shell、文件系统、应用程序。</li></ol><blockquote><p>shell是系统的用户界面，提供了用户与内核进行交互操作的接口，它接收用户输入的命令并将它送到内核去执行。</p></blockquote><p><img src="/images/linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.jpeg" alt="系统结构"></p><ol start="2"><li>Linux内核主要由以下几部分组成：内存管理、进程管理、设备驱动程序、文件系统、网络管理等</li></ol><p><img src="/images/%E5%86%85%E6%A0%B8%E7%BB%84%E6%88%90.jpeg" alt="内核组成"></p><p>系统调用接口（System Call Interface）这一层提供了 某些机制执行从用户空间到内核空间的函数调用，从上面可以看到用户空间指的是哪一层。</p><ol start="3"><li>虚拟文件系统（Virtual File System）提供了open\close\read\write的API</li></ol><p><img src="/images/vfs.jpeg" alt="虚拟文件系统VFS"></p><ol start="5"><li>Linux文件类型</li></ol><p>普通文件：分为纯文本文件和二进制文件，如C语言代码、shell脚本、二进制可执行文件等；<br>目录文件：目录是存储文件的唯一地方；<br>链接文件：指向同一个文件或目录的文件；<br>设备文件：与系统外设相关的，一般在目录&#x2F;dev下面。设备分为块设备和字符设备；<br>管道文件：提供进程间通信的一种方式；<br>套接字文件：与网络通信相关的文件；</p><h3 id="二、Linux目录结构"><a href="#二、Linux目录结构" class="headerlink" title="二、Linux目录结构"></a>二、Linux目录结构</h3><p><img src="/images/linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84.jpeg" alt="linux目录结构"></p><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>apt 和 apt-get 什么关系</li><li>rpm apt yum 什么关系</li></ul><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://www.zhihu.com/collection/307882235">一文带你全面掌握Linux系统体系结构</a></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘扩容</title>
    <link href="/2023/05/18/linux/%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
    <url>/2023/05/18/linux/%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="一、抛出异常"><a href="#一、抛出异常" class="headerlink" title="一、抛出异常"></a>一、抛出异常</h3><blockquote><p>Error processing tar file(exit status 1): write &#x2F;layer.tar: no space left on device</p></blockquote><h3 id="二、查看当前的分区和磁盘"><a href="#二、查看当前的分区和磁盘" class="headerlink" title="二、查看当前的分区和磁盘"></a>二、查看当前的分区和磁盘</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下面的异常在于disk的最大是30GB，但是分区 / 是8.8G，加前面的两个分区 /boot/efi 和 /boot 也不够30G</span><br><span class="hljs-comment"># 注意：磁盘剩余空间只能堆到 / 但是不能直接堆到 /boot 或者 /boot/efi</span><br>[root@i-7B581709 ~]<span class="hljs-comment"># lsblk</span><br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sr0     11:0    1 1024M  0 rom  <br>sr1     11:1    1 1024M  0 rom  <br>vda    253:0    0   30G  0 disk <br>├─vda1 253:1    0  200M  0 part /boot/efi<br>├─vda2 253:2    0    1G  0 part /boot<br>└─vda3 253:3    0  8.8G  0 part /<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 现在查看更详细的磁盘信息</span><br><span class="hljs-comment"># 列出磁盘分区表信息</span><br><span class="hljs-comment"># 包括每个磁盘分区的起始位置、大小、文件系统类型等详细信息</span><br><br>[root@i-7B581709 ~]<span class="hljs-comment"># fdisk -l</span><br>GPT PMBR 大小不符（20971519 != 62914559），将用写入予以更正。<br>The backup GPT table is not on the end of the device. This problem will be corrected by write.<br>Disk /dev/vda：30 GiB，32212254720 字节，62914560 个扇区<br>单元：扇区 / 1 * 512 = 512 字节<br>扇区大小(逻辑/物理)：512 字节 / 512 字节<br>I/O 大小(最小/最佳)：512 字节 / 512 字节<br>磁盘标签类型：gpt<br>磁盘标识符：94198271-E793-42DE-96AB-DCDD41CD2826<br><br>设备          起点     末尾     扇区  大小 类型<br>/dev/vda1     2048   411647   409600  200M EFI 系统<br>/dev/vda2   411648  2508799  2097152    1G Linux 文件系统<br>/dev/vda3  2508800 20969471 18460672  8.8G Linux 文件系统<br></code></pre></td></tr></table></figure><h3 id="三、开始重新分区"><a href="#三、开始重新分区" class="headerlink" title="三、开始重新分区"></a>三、开始重新分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 进入重新分区界面</span><br>$ fdisk /dev/vda<br><br>欢迎使用 fdisk (util-linux 2.35.2)。<br>更改将停留在内存中，直到您决定将更改写入磁盘。<br>使用写入命令前请三思。<br><br>GPT PMBR 大小不符（20971519 != 62914559），将用写入予以更正。<br>The backup GPT table is not on the end of the device. This problem will be corrected by write.<br><br>命令(输入 m 获取帮助)：<br><br>d   删除分区<br>p   打印分区表<br>n   添加新分区<br>w   将分区表写入磁盘并退出<br>q   退出而不保存更改<br></code></pre></td></tr></table></figure><p>总的来说，我们需要做的就是，删除最后一个分区 &#x2F;dev&#x2F;vda3  然后添加一个新的分区，当按下n添加分区的时候会自动选择起点和末尾（磁盘的起始点和末尾点），直接按默认值就可以了，分区好了以后按w保存就可以了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 按键顺序</span><br>$ p<br>$ d<br>$ n<br>$ w<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">分区 <span class="hljs-comment">#3 包含一个 xfs 签名。</span><br><br>您想移除该签名吗？是[Y]/否[N]：<br>这个选择N就好了<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重新查看分区情况</span><br><span class="hljs-comment"># 发现此时的 / 分区是28.8G了</span><br>$ lsblk<br>NAME   MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT<br>sr0     11:0    1 1024M  0 rom  <br>sr1     11:1    1 1024M  0 rom  <br>vda    253:0    0   30G  0 disk <br>├─vda1 253:1    0  200M  0 part /boot/efi<br>├─vda2 253:2    0    1G  0 part /boot<br>└─vda3 253:3    0 28.8G  0 part /<br></code></pre></td></tr></table></figure><h3 id="三、挂载的文件系统大小更新"><a href="#三、挂载的文件系统大小更新" class="headerlink" title="三、挂载的文件系统大小更新"></a>三、挂载的文件系统大小更新</h3><blockquote><p>此时仍然是会出现空间不足 no space left on device 的情况，因为挂载的文件系统的大小还是没有改变的</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看各个磁盘分区与当前操作系统的挂载点信息</span><br><span class="hljs-comment"># df -h 是一个命令，用于显示磁盘分区的使用情况</span><br><span class="hljs-comment"># 其中，&quot;-h&quot;为参数，表示以易读的方式显示磁盘使用情况，即以K、M、G等单位显示磁盘空间的大小</span><br>$ <span class="hljs-built_in">df</span> -h <br><br><span class="hljs-comment"># 下面的来说不太正常的是挂载点 /dev/vda3 的容量仍然是 8.8G </span><br>文件系统        容量  已用  可用 已用% 挂载点<br>devtmpfs        3.1G     0  3.1G    0% /dev<br>tmpfs           3.4G     0  3.4G    0% /dev/shm<br>tmpfs           3.4G   28M  3.3G    1% /run<br>tmpfs           3.4G     0  3.4G    0% /sys/fs/cgroup<br>/dev/vda3       8.8G  7.2G  1.7G   82% /<br>tmpfs           3.4G   16M  3.3G    1% /tmp<br>/dev/vda2      1014M  239M  776M   24% /boot<br>/dev/vda1       200M  6.7M  194M    4% /boot/efi<br>tmpfs           677M     0  677M    0% /run/user/0<br></code></pre></td></tr></table></figure><blockquote><p>文件系统挂载点扩展，不同的文件系统类型有不同的挂载点扩展方式，其中 TYPE&#x3D;”xfs” 的使用 xfs_growfs 扩展XFS文件系统的大小，即在一个已有的XFS文件系统上添加更多的磁盘空间</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@i-7B581709 ~]<span class="hljs-comment"># blkid</span><br><br>/dev/vda1: SEC_TYPE=<span class="hljs-string">&quot;msdos&quot;</span> UUID=<span class="hljs-string">&quot;2787-B495&quot;</span> BLOCK_SIZE=<span class="hljs-string">&quot;512&quot;</span> TYPE=<span class="hljs-string">&quot;vfat&quot;</span> PARTLABEL=<span class="hljs-string">&quot;EFI System Partition&quot;</span> PARTUUID=<span class="hljs-string">&quot;b5f117e3-e47b-4545-8d8d-0cafd317c05e&quot;</span><br>/dev/vda2: UUID=<span class="hljs-string">&quot;5db79665-5d14-4666-8257-66a6bcc9728e&quot;</span> BLOCK_SIZE=<span class="hljs-string">&quot;512&quot;</span> TYPE=<span class="hljs-string">&quot;xfs&quot;</span> PARTUUID=<span class="hljs-string">&quot;760bbcfd-3bb0-47b5-a35a-2de113314052&quot;</span><br>/dev/vda3: UUID=<span class="hljs-string">&quot;35a8c362-91b8-48b0-a470-aefe39968cfc&quot;</span> BLOCK_SIZE=<span class="hljs-string">&quot;512&quot;</span> TYPE=<span class="hljs-string">&quot;xfs&quot;</span> PARTUUID=<span class="hljs-string">&quot;b0543e02-3f29-314b-8e48-d2ec81056b8a&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当前的文件系统类型是 TYPE=&quot;xfs&quot; </span><br><span class="hljs-comment"># 注意需要加上跟分区，比如我们需要更新的挂载点是 / 那么就是跟分区</span><br>$ xfs_growfs /<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重新查看当前的磁盘分区和挂载的文件系统大小</span><br><span class="hljs-comment"># 此时的 /dev/vda3 的容量就是29G</span><br>[root@i-7B581709 ~]<span class="hljs-comment"># df -h</span><br>文件系统        容量  已用  可用 已用% 挂载点<br>devtmpfs        3.1G     0  3.1G    0% /dev<br>tmpfs           3.4G     0  3.4G    0% /dev/shm<br>tmpfs           3.4G   28M  3.3G    1% /run<br>tmpfs           3.4G     0  3.4G    0% /sys/fs/cgroup<br>/dev/vda3        29G  7.3G   22G   26% /<br>tmpfs           3.4G   16M  3.3G    1% /tmp<br>/dev/vda2      1014M  239M  776M   24% /boot<br>/dev/vda1       200M  6.7M  194M    4% /boot/efi<br>tmpfs           677M     0  677M    0% /run/user/0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果文件类型ext4</span><br>$ resize2fs /dev/vda3<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux与网络</title>
    <link href="/2023/05/18/linux/%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/05/18/linux/%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="一、网桥"><a href="#一、网桥" class="headerlink" title="一、网桥"></a>一、网桥</h3><ol><li>网络设备，连接多个网络。</li><li>转发不同网络之中的数据流。</li><li>工作在OSI模型的第二层：数据链路层，通过物理地址（MAC地址）识别网络设备来传递数据包</li></ol><blockquote><p>可以减少网络冲突</p></blockquote><h3 id="二、网段"><a href="#二、网段" class="headerlink" title="二、网段"></a>二、网段</h3><ol><li>网络地址范围 (表示方式：IP地址和子网掩码)</li><li>同一网段的设备可互相通信，不同网段需要路由器等设备才可痛心</li></ol><h3 id="三、iptable是什么"><a href="#三、iptable是什么" class="headerlink" title="三、iptable是什么"></a>三、iptable是什么</h3><ol><li>一个防火墙工具</li><li>控制网络数据包的流动</li></ol><h3 id="四、iptable基本用法"><a href="#四、iptable基本用法" class="headerlink" title="四、iptable基本用法"></a>四、iptable基本用法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加一个规则，允许 TCP:80端口 输入流量</span><br>$ iptables -A INPUT -p tcp --dport 80 -j ACCEPT<br><br><span class="hljs-comment"># 查看规则</span><br>$ iptables -L<br><br><span class="hljs-comment"># eth0 接口的地址转换为 NAT 地址</span><br>$ iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE<br></code></pre></td></tr></table></figure><h3 id="五、iptable的NAT是什么意思"><a href="#五、iptable的NAT是什么意思" class="headerlink" title="五、iptable的NAT是什么意思"></a>五、iptable的NAT是什么意思</h3><ol><li>NAT表示网络地址转换</li><li>将私有IP地址映射到公共IP地址的技术</li></ol><h3 id="六、怎么解读-iptables-nL-t-nat-列出NAT表格转发规则"><a href="#六、怎么解读-iptables-nL-t-nat-列出NAT表格转发规则" class="headerlink" title="六、怎么解读 iptables -nL -t nat (列出NAT表格转发规则)"></a>六、怎么解读 iptables -nL -t nat (列出NAT表格转发规则)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@i-C5B261D3 ~]<span class="hljs-comment"># iptables -nL -t nat</span><br><br>(规则链) Chain POSTROUTING (policy ACCEPT)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>KUBE-POSTROUTING  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes postrouting rules */<br>LIBVIRT_PRT  all  --  0.0.0.0/0            0.0.0.0/0           <br><br>(规则链) Chain KUBE-KUBELET-CANARY (0 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br><br>(规则链) Chain KUBE-MARK-DROP (0 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK or 0x8000<br><br>(规则链) Chain KUBE-MARK-MASQ (0 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK or 0x4000<br><br>(规则链) Chain KUBE-POSTROUTING (1 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>RETURN     all  --  0.0.0.0/0            0.0.0.0/0            mark match ! 0x4000/0x4000<br>MARK       all  --  0.0.0.0/0            0.0.0.0/0            MARK xor 0x4000<br>MASQUERADE  all  --  0.0.0.0/0            0.0.0.0/0            /* kubernetes service traffic requiring SNAT */ random-fully<br><br>(规则链) Chain LIBVIRT_PRT (1 references)<br>target     prot opt <span class="hljs-built_in">source</span>               destination         <br>RETURN     all  --  192.168.122.0/24     224.0.0.0/24        <br>RETURN     all  --  192.168.122.0/24     255.255.255.255     <br>MASQUERADE  tcp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535<br>MASQUERADE  udp  --  192.168.122.0/24    !192.168.122.0/24     masq ports: 1024-65535<br>MASQUERADE  all  --  192.168.122.0/24    !192.168.122.0/24    <br><br></code></pre></td></tr></table></figure><ul><li><code>target</code>：目标，表示这条规则的动作，比如 ACCEPT&#x2F;REJECT&#x2F;DROP 等。</li><li><code>prot</code>：协议，表示这条规则所匹配的协议，比如 TCP&#x2F;UDP&#x2F;ICMP 等。</li><li><code>opt</code>：选项，表示这条规则所匹配的选项，比如 –dport&#x2F;–sport 等。</li><li><code>source</code>：源地址，表示这条规则所匹配的源 IP 地址或网段。</li><li><code>destination</code>：目标地址，表示这条规则所匹配的目标 IP 地址或网段。</li></ul><p>在 iptables 输出中，target 字段表示数据包应该被送往哪里。<br>  以下是常见的 target 值的含义：</p><ul><li>ACCEPT：表示允许数据包通过防火墙；</li><li>DROP：表示丢弃（拒绝）数据包，不给任何回应；</li><li>REJECT：表示拒绝数据包，并发送 ICMP 错误消息给发送者；</li><li>LOG：表示记录数据包信息（如源 IP，目的 IP，端口等）到系统日志中；</li><li>RETURN：表示返回到调用链的上一层规则；</li><li>SNAT：表示源地址转换，更改数据包的源 IP 地址；</li><li>DNAT：表示目标地址转换，更改数据包的目标 IP 地址；</li><li>MASQUERADE：表示伪装 NAT，常用于连接到互联网的局域网内网设备；</li><li>REDIRECT：表示重定向到指定的端口或 IP 地址；</li><li>MARK：表示给数据包打标签，以便后续规则匹配使用。</li></ul><h3 id="七、brctl-show-显示Linux机器上的桥接设备"><a href="#七、brctl-show-显示Linux机器上的桥接设备" class="headerlink" title="七、brctl show 显示Linux机器上的桥接设备"></a>七、brctl show 显示Linux机器上的桥接设备</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 网桥连接虚拟机的网卡和物理机的网卡 （连接多个网络的）</span><br>[root@i-C5B261D3 ~]<span class="hljs-comment"># brctl show</span><br>bridge name （名称）    bridge <span class="hljs-built_in">id</span> （唯一标识符，由MAC地址生成） STP enabled （防止桥环路协议是否启用）   interfaces （该bridge下所连接的接口）<br>virbr0          8000.5254000ae93a       <span class="hljs-built_in">yes</span>             virbr0-nic<br></code></pre></td></tr></table></figure><h3 id="cidr"><a href="#cidr" class="headerlink" title="cidr"></a>cidr</h3><p><a href="https://tool.lu/zh_CN/cidr/">https://tool.lu/zh_CN/cidr/</a></p><p>CIDR（Classless Inter-Domain Routing）是互联网中一种新的寻址方式，表示为：IP地址&#x2F;网络ID的位数。<br>比如192.168.1.0&#x2F;24，那么ip地址前24位是网络部分，后面8位是主机部分</p><h3 id="ip-a"><a href="#ip-a" class="headerlink" title="ip a"></a>ip a</h3><h3 id="x2F-etc-x2F-network-x2F-interfaces-d-文件夹干嘛的"><a href="#x2F-etc-x2F-network-x2F-interfaces-d-文件夹干嘛的" class="headerlink" title="&#x2F;etc&#x2F;network&#x2F;interfaces.d 文件夹干嘛的"></a>&#x2F;etc&#x2F;network&#x2F;interfaces.d 文件夹干嘛的</h3><ul><li>存放网络接口配置文件的文件夹</li><li>内部每个配置文件描述了一个网络接口</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">其中网络接口的字段有<br>netmask：指定网络掩码，用于确定网络地址和主机地址的范围。<br>address：指定网络接口的IP地址。<br>gateway：指定默认网关，即发送到其他网络的数据包要通过该网关转发。<br>dns-nameservers：指定域名系统（DNS）服务器的IP地址，用于解析域名为IP地址。<br></code></pre></td></tr></table></figure><h3 id="网络掩码是什么"><a href="#网络掩码是什么" class="headerlink" title="网络掩码是什么"></a>网络掩码是什么</h3><ul><li>定义一个IP地址的网络部分和主机部分。（这句话什么意思呢，每个IP地址都是一个32位的二进制，这个掩码代表了前多少位是网路部分，后面的多少位是主机部分）</li></ul><h3 id="IP地址为192-168-1-1，网络掩码为255-255-255-0，那么设备所在的网络范围是什么，怎么计算的"><a href="#IP地址为192-168-1-1，网络掩码为255-255-255-0，那么设备所在的网络范围是什么，怎么计算的" class="headerlink" title="IP地址为192.168.1.1，网络掩码为255.255.255.0，那么设备所在的网络范围是什么，怎么计算的"></a>IP地址为192.168.1.1，网络掩码为255.255.255.0，那么设备所在的网络范围是什么，怎么计算的</h3><ul><li>网络掩码255.255.255.0代表设备的IP地址中，前24位是网络地址（192.168.1），后面的8位就是主机地址</li><li>该设备所在的网络范围是192.168.1.0&#x2F;24</li></ul><p>如果网络掩码为255.255.248.0，那么转换二进制子网掩码：11111111.11111111.11111000.00000000，刚好21位，那么IP地址的前21位是网络ID，后11位是主机ID，网络范围是192.168.0.0&#x2F;21。也就是说IP地址范围为192.168.0.1 ~ 192.168.7.254</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>磁盘分区</title>
    <link href="/2023/05/11/linux/%E8%AF%A6%E8%A7%A3%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <url>/2023/05/11/linux/%E8%AF%A6%E8%A7%A3%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<h5 id="1-lsblk-List-Block-Devices-命令解释："><a href="#1-lsblk-List-Block-Devices-命令解释：" class="headerlink" title="1. lsblk (List Block Devices) 命令解释："></a>1. lsblk (List Block Devices) 命令解释：</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> NAME：块设备名称。<br><span class="hljs-bullet">2.</span> SIZE：块设备的容量大小。<br><span class="hljs-bullet">3.</span> TYPE：块设备类型，如磁盘（disk）或分区（part）。<br><span class="hljs-bullet">4.</span> MOUNTPOINT：设备被挂载的挂载点。<br><span class="hljs-bullet">5.</span> MODEL：硬件设备的制造商及型号。<br><span class="hljs-bullet">6.</span> FSTYPE：文件系统类型，比如ext4或NTFS。<br><span class="hljs-bullet">7.</span> UUID：块设备的唯一标识符。<br><span class="hljs-bullet">8.</span> LABEL：块设备的卷标或文件系统标签。<br><span class="hljs-bullet">9.</span> RO：块设备是否为只读。<br><span class="hljs-bullet">10.</span> RM：块设备是否可以通过软件进行移除。<br><span class="hljs-bullet">11.</span> PARTTYPE：如果块设备是分区，则该字段会显示分区类型。<br><span class="hljs-bullet">12.</span> PARTLABEL：如果块设备是分区，则该字段会显示分区卷标或文件系统标签。<br><span class="hljs-bullet">13.</span> PARTUUID：如果块设备是分区，则该字段会显示分区的唯一标识符。<br><br>这些指标可以帮助用户了解系统上的块设备，包括设备名称、容量、挂载点、文件系统类型等，从而更好地管理和使用系统。<br><br>[root@k8s-master network-scripts]# lsblk<br>NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT<br>sr0     11:0    1 203.6M  0 rom  <br>vda    253:0    0    60G  0 disk <br>└─vda1 253:1    0    60G  0 part /<br></code></pre></td></tr></table></figure><h5 id="2-lsblk的MAJ-MIN和-TYPE为rom-是什么意思"><a href="#2-lsblk的MAJ-MIN和-TYPE为rom-是什么意思" class="headerlink" title="2. lsblk的MAJ:MIN和 TYPE为rom 是什么意思"></a>2. lsblk的MAJ:MIN和 TYPE为rom 是什么意思</h5><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">lsblk命令显示的输出中<br>MAJ:MIN表示设备的主设备号和次设备号<br>主设备号用于识别驱动程序，而次设备号用于识别设备本身<br><br>TYPE为rom表示设备是只读设备<br>ROM是只读存储器（Read-Only Memory）的简称<br>它存储的数据无法被写入<br></code></pre></td></tr></table></figure><h5 id="3-如何使用fdisk查看分区"><a href="#3-如何使用fdisk查看分区" class="headerlink" title="3. 如何使用fdisk查看分区"></a>3. 如何使用fdisk查看分区</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看磁盘分区</span><br>$ fdisk -l<br><br><span class="hljs-comment"># 查看某一个磁盘下面的分区</span><br>$ fdisk -l /dev/sda<br></code></pre></td></tr></table></figure><h5 id="4-如何使用fdisk创建分区"><a href="#4-如何使用fdisk创建分区" class="headerlink" title="4. 如何使用fdisk创建分区"></a>4. 如何使用fdisk创建分区</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下面演示: Linux 系统中创建一个 ext4 文件系统格式的、挂载在 /mnt/mydisk 目录下的分区了</span><br><br><span class="hljs-comment"># 查看当前的磁盘以及磁盘下的分区</span><br>$ lsblk<br><br><span class="hljs-comment"># 输入 m 命令，查看 fdisk 的命令帮助信息，了解可以使用的命令。</span><br><span class="hljs-comment"># 输入 n 命令，创建一个新的分区，按照提示输入分区号、起始扇区和结束扇区等信息。</span><br><span class="hljs-comment"># 输入 t 命令，修改分区类型，例如将分区类型修改为 Linux 文件系统（83）。</span><br><span class="hljs-comment"># 输入 w 命令，保存并退出 fdisk 工具</span><br><span class="hljs-comment"># 开始对/sda做分区 ,注意/dev/sda是必须存在的磁盘设备</span><br>$ fdisk /dev/sda<br><br><span class="hljs-comment"># 使用 mkfs 命令格式化创建的分区</span><br>$ mkfs.ext4 /dev/sda1<br><br><span class="hljs-comment"># 在系统中挂载分区</span><br><span class="hljs-comment"># 将新分区 /dev/sda1 挂载到 /mnt/mydisk</span><br><span class="hljs-comment"># 这样可以通过 /mnt/mydisk 访问到分区</span><br>$ <span class="hljs-built_in">mkdir</span> /mnt/mydisk<br>$ mount /dev/sda1 /mnt/mydisk<br></code></pre></td></tr></table></figure><h5 id="5-x2F-mnt是干嘛用的"><a href="#5-x2F-mnt是干嘛用的" class="headerlink" title="5. &#x2F;mnt是干嘛用的"></a>5. &#x2F;mnt是干嘛用的</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">/mnt 是一个挂载点，用于挂载外部设备（如硬盘、USB 等）到文件系统中的目录。<br>通常，挂载点为 /mnt，但也可以在其他位置创建挂载点。在 Linux 中，MNT 表示挂载点（mount point）的缩写。<br></code></pre></td></tr></table></figure><h5 id="6-mkfs-ext4是什么意思"><a href="#6-mkfs-ext4是什么意思" class="headerlink" title="6. mkfs.ext4是什么意思"></a>6. mkfs.ext4是什么意思</h5><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">mkfs.ext4是一个Linux命令，用于创建ext4文件系统。<br><span class="hljs-string">&quot;mkfs&quot;</span>代表<span class="hljs-string">&quot;make file system&quot;</span><br><span class="hljs-string">&quot;ext4&quot;</span>是第四个扩展文件系统（Extended <span class="hljs-keyword">File</span> <span class="hljs-keyword">System</span>）的缩写<br>是Linux中最常见的文件系统之一<br><br>使用mkfs.ext4命令可以对磁盘分区进行格式化，以便在该分区上创建文件系统并存储数据。<br></code></pre></td></tr></table></figure><h5 id="7-mount-x2F-dev-x2F-sda1-x2F-mnt-x2F-mydisk是什么意思"><a href="#7-mount-x2F-dev-x2F-sda1-x2F-mnt-x2F-mydisk是什么意思" class="headerlink" title="7. mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;mydisk是什么意思"></a>7. mount &#x2F;dev&#x2F;sda1 &#x2F;mnt&#x2F;mydisk是什么意思</h5><p>这是一个Linux命令，用于将设备&#x2F;dev&#x2F;sda1（通常是硬盘分区）挂载（mount）到&#x2F;mnt&#x2F;mydisk目录中。<br>“mount”表示将一个文件系统连接到文件系统树的一个指定位置上<br>将磁盘分区挂载到一个目录中，可以使得该目录下面的文件和文件夹与该分区中的内容相对应。<br>在这个例子中，&#x2F;dev&#x2F;sda1分区上的数据将可以在&#x2F;mnt&#x2F;mydisk目录下访问。注意，要挂载一个设备<br>该设备必须首先被格式化并创建了文件系统，可以使用mkfs命令创建文件系统。</p><h5 id="8-pvcreate-x2F-dev-x2F-sdb-是什么意思"><a href="#8-pvcreate-x2F-dev-x2F-sdb-是什么意思" class="headerlink" title="8. pvcreate &#x2F;dev&#x2F;sdb 是什么意思"></a>8. pvcreate &#x2F;dev&#x2F;sdb 是什么意思</h5><p>这个命令是Linux下用来创建物理卷（Physical Volume）的。具体来说：</p><ul><li>&#x2F;dev&#x2F;sdb 是要创建物理卷的设备文件。</li><li>在运行pvcreate命令之前，这个设备文件必须是未被分区的空闲磁盘或分区。</li><li>执行pvcreate后，该设备文件会被初始化为一个物理卷，然后可以将其添加到卷组（Volume Group）中，以供逻辑卷（Logical Volume）使用。</li></ul><h5 id="9-dd-if-x3D-x2F-dev-x2F-zero-of-x3D-x2F-dev-x2F-sdb-bs-x3D-1M-count-x3D-1024"><a href="#9-dd-if-x3D-x2F-dev-x2F-zero-of-x3D-x2F-dev-x2F-sdb-bs-x3D-1M-count-x3D-1024" class="headerlink" title="9. dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1M count&#x3D;1024"></a>9. dd if&#x3D;&#x2F;dev&#x2F;zero of&#x3D;&#x2F;dev&#x2F;sdb bs&#x3D;1M count&#x3D;1024</h5><p>dd是Unix或类Unix系统中的命令，用于复制文件、转换格式、创建空文件和磁盘映像等操作。它是“数据块（Data Definition）”的缩写，因为它是以固定大小的数据块为单位操作数据的。在Linux系统中，dd命令也被广泛用于备份和还原硬盘，制作启动盘和光盘等操作。<br>该命令表示在 &#x2F;dev&#x2F;sdb 这个硬盘上创建一个大小为 1G 的空白文件。其中 if 表示输入文件，也就是要写入 &#x2F;dev&#x2F;sdb 的数据来源，这里设置为 &#x2F;dev&#x2F;zero，表示读取 0。of 表示输出文件，也就是写入 &#x2F;dev&#x2F;sdb 的数据目的地。bs 表示块大小，这里设置为 1M，表示每次写入 1MB 的数据。count 表示写入的块数，这里设置为 1024，表示一共写入 1024 个块，也就是 1G 的大小。这个命令也称作 dd 零填充，会在硬盘对应的设备文件中写入 0，用来清空硬盘数据。</p><h4 id="10-linux上的空白文件是什么意思"><a href="#10-linux上的空白文件是什么意思" class="headerlink" title="10. linux上的空白文件是什么意思"></a>10. linux上的空白文件是什么意思</h4><p>空白文件是一种大小为零的文件。它们通常用于占据磁盘空间或作为占位符，例如在创建一个空目录时用作占位符文件。<br>使用dd命令创建空白文件可以更精确地控制文件的大小和位置，并且可以在复制或克隆磁盘映像时使用。<br>例如，可以使用dd命令创建一个特定大小的空白文件，并将其用作虚拟磁盘的镜像文件。这种方法经常用于创建虚拟机硬盘映像或备份数据。</p><h5 id="11-什么叫已经给-x2F-dev-x2F-sdb划分了分区，不能不能作为物理卷使用，物理卷和分区是什么意思"><a href="#11-什么叫已经给-x2F-dev-x2F-sdb划分了分区，不能不能作为物理卷使用，物理卷和分区是什么意思" class="headerlink" title="11. 什么叫已经给&#x2F;dev&#x2F;sdb划分了分区，不能不能作为物理卷使用，物理卷和分区是什么意思"></a>11. 什么叫已经给&#x2F;dev&#x2F;sdb划分了分区，不能不能作为物理卷使用，物理卷和分区是什么意思</h5><p>在Linux下，物理卷（Physical Volume）和分区（Partition）是两个不同的概念。</p><ul><li>分区是指将一个磁盘或存储设备分成若干个大小不同的区域，每个分区可以独立地格式化、挂载和使用。</li><li>物理卷是将一个或多个分区或磁盘组合成一个卷组（Volume Group），并对其进行格式化，以提供更灵活的存储管理方式。<br>如果对&#x2F;dev&#x2F;sdb进行分区，那么这个设备就不能作为一个物理卷使用。如果想要将其作为物理卷，需要先执行删除分区的操作，然后使用pvcreate命令将其初始化为一个物理卷。<br>需要注意的是，一般情况下，一个物理卷不能超过硬件限制的容量，而一个分区则可以。因此，使用物理卷可以更灵活地管理不同硬件设备、不同容量的存储资源。</li></ul><h4 id="12-linux的LVM是什么意思"><a href="#12-linux的LVM是什么意思" class="headerlink" title="12. linux的LVM是什么意思"></a>12. linux的LVM是什么意思</h4><p>逻辑卷管理器（Logical Volume Manager）的简称。<br>LVM通过虚拟化磁盘空间，将多个硬盘分区或物理磁盘组合成一个逻辑卷，并允许管理员在运行时动态地调整这些逻辑卷的大小。<br>在LVM中，管理员可以创建两个主要的逻辑卷</p><ul><li>物理卷（Physical Volume）</li><li>卷组（Volume Group）<br>物理卷是指物理磁盘或分区，而卷组是将一个或多个物理卷组合在一起的逻辑单元。<br>LVM提供了更好的磁盘空间管理和灵活性，使管理员可以更好地满足服务器和存储的需求。LVM也广泛用于虚拟化环境中，以便在虚拟机之间动态分配磁盘空间。</li></ul><h3 id="13-df-h是什么，怎么看"><a href="#13-df-h是什么，怎么看" class="headerlink" title="13. df -h是什么，怎么看"></a>13. df -h是什么，怎么看</h3><p>df -h是一条Linux命令，用于显示文件系统磁盘使用情况的简明报告。<br>其中“-h”选项指定以人类可读的方式输出数据，即以可读性较高的GB、MB、KB等单位显示文件系统使用情况。</p><p>通过运行df -h命令，可以查看文件系统磁盘使用情况的报告，<br>包括：文件系统名称、文件系统大小、已用空间、可用空间、使用率、挂载点等信息。按照默认顺序，该命令显示磁盘使用情况信息的单位是KB。<br>例如，下面是一条示例命令及输出结果：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ df -h<br>文件系统           容量  已用  可用 已用% 挂载点<br>udev             <span class="hljs-number">3.9</span>G     <span class="hljs-number">0</span>  <span class="hljs-number">3.9</span>G    <span class="hljs-number">0</span>% /dev<br>tmpfs            <span class="hljs-number">798</span>M  <span class="hljs-number">1.7</span>M  <span class="hljs-number">797</span>M    <span class="hljs-number">1</span>% /run<br>tmpfs            <span class="hljs-number">3.9</span>G  <span class="hljs-number">159</span>M  <span class="hljs-number">3.8</span>G    <span class="hljs-number">4</span>% <span class="hljs-regexp">/dev/</span>shm<br>tmpfs            <span class="hljs-number">5.0</span>M  <span class="hljs-number">4.0</span>K  <span class="hljs-number">5.0</span>M    <span class="hljs-number">1</span>% <span class="hljs-regexp">/run/</span>lock<br>tmpfs            <span class="hljs-number">3.9</span>G     <span class="hljs-number">0</span>  <span class="hljs-number">3.9</span>G    <span class="hljs-number">0</span>% <span class="hljs-regexp">/sys/</span>fs/cgroup<br><span class="hljs-regexp">/dev/</span>sda1         <span class="hljs-number">15</span>G  <span class="hljs-number">6.9</span>G  <span class="hljs-number">7.3</span>G   <span class="hljs-number">49</span>% /<br><span class="hljs-regexp">/dev/</span>sda2        <span class="hljs-number">193</span>G   <span class="hljs-number">77</span>G  <span class="hljs-number">106</span>G   <span class="hljs-number">42</span>% /data<br></code></pre></td></tr></table></figure><p>tmpfs的形式挂载，特定的目录比如&#x2F;tmp、&#x2F;var&#x2F;run、&#x2F;dev&#x2F;shm等的都是内存文件系统</p><p>从上面的输出结果可以看出：该系统一共有5个文件系统，<br>其中&#x2F;dev&#x2F;sda1和&#x2F;dev&#x2F;sda2是已经挂载的硬盘分区，其它3个是内存文件系统。</p><p>其中，&#x2F;dev&#x2F;sda1分区总容量为15G，已经使用了6.9G，还剩7.3G可用空间，使用率为49%；<br>而&#x2F;dev&#x2F;sda2分区总容量为193G，已经使用了77G，还剩106G可用空间，使用率为42%。</p><h3 id="14-fdisk-x2F-dev-x2F-vda的扇区是什么意思"><a href="#14-fdisk-x2F-dev-x2F-vda的扇区是什么意思" class="headerlink" title="14. fdisk &#x2F;dev&#x2F;vda的扇区是什么意思"></a>14. fdisk &#x2F;dev&#x2F;vda的扇区是什么意思</h3><h3 id="15-linux-如何使用fdisk对一个磁盘分区"><a href="#15-linux-如何使用fdisk对一个磁盘分区" class="headerlink" title="15. linux 如何使用fdisk对一个磁盘分区"></a>15. linux 如何使用fdisk对一个磁盘分区</h3><p>使用 fdisk 命令，可以对 Linux 系统的磁盘进行分区。下面是使用 fdisk 命令对磁盘进行分区的步骤：</p><ol><li>首先，使用 fdisk 命令打开要分区的磁盘：  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo fdisk <span class="hljs-regexp">/dev/</span>sdX<br></code></pre></td></tr></table></figure>  其中，sdX 表示要分区的磁盘，例如 sda、sdb 等。</li><li>然后，输入 m 键查看 fdisk 命令的帮助和选项。</li><li>输入 n 命令来创建一个新分区。</li><li>会提示你选择分区类型，如果是普通分区请选择 p，如果是扩展分区请选择 e。</li><li>然后输入分区号（默认为 1），分配分区开始和结束的扇区编号或使用默认值。</li><li>然后分配分区类型（如主分区、扩展分区、逻辑分区）和文件系统类型。</li><li>最后，输入 w 命令保存分区表并退出 fdisk。</li><li>最后使用 mkfs 命令来创建文件系统。  <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo mkfs.ext4 <span class="hljs-regexp">/dev/</span>sdX1<br></code></pre></td></tr></table></figure>  其中，sdX1 表示要创建文件系统的分区，例如 sda1、sdb1 等。<br>完成上述步骤后，您就成功地对磁盘进行了分区。</li></ol><h3 id="16-linux磁盘设计、LVM、扇区"><a href="#16-linux磁盘设计、LVM、扇区" class="headerlink" title="16. linux磁盘设计、LVM、扇区"></a>16. linux磁盘设计、LVM、扇区</h3><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ lsblk<br>$ fdisk<br>$ /etc/sysconfig/network-scripts<br>$ <span class="hljs-built_in">dd</span><br>$ <span class="hljs-built_in">df</span> -h<br>$ <span class="hljs-built_in">df</span> -T<br>$ growpart<br>$ xfs_growfs<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/296777898">一篇看懂！Linux磁盘的管理（分区、格式化、挂载），LVM逻辑卷，RAID磁盘阵列</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>containerd安装</title>
    <link href="/2023/05/06/kubernetes/containerd%E5%AE%89%E8%A3%85/"/>
    <url>/2023/05/06/kubernetes/containerd%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root🐳 ~]<span class="hljs-comment"># uname -a</span><br><span class="hljs-comment"># Linux ming-computer 5.15.0-71-generic #78~20.04.1-Ubuntu SMP Wed Apr 19 </span><br><span class="hljs-comment"># 11:26:48 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux</span><br></code></pre></td></tr></table></figure><h3 id="二、官网地址"><a href="#二、官网地址" class="headerlink" title="二、官网地址"></a>二、官网地址</h3><p><a href="https://github.com/containerd/containerd/blob/v1.7.0/docs/getting-started.md">containerd-v1.7.0&#x2F;docs&#x2F;getting-started</a><br><a href="https://github.com/opencontainers/runc/releases/tag/v1.1.7">runc&#x2F;v1.1.7</a><br><a href="https://github.com/containernetworking/plugins/releases/tag/v1.2.0">containernetworking&#x2F;plugins-CNI-v1.2.0</a></p><h3 id="三、下载并安装runc-CNI-containerd"><a href="#三、下载并安装runc-CNI-containerd" class="headerlink" title="三、下载并安装runc\CNI\containerd"></a>三、下载并安装runc\CNI\containerd</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># runc安装</span><br>$ install -m 755 runc.amd64 /usr/local/sbin/runc<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># CNI安装</span><br>$ <span class="hljs-built_in">mkdir</span> -p /opt/cni/bin<br>$ tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.2.0.tgz<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># containerd安装至/usr/local</span><br><span class="hljs-comment"># Note: no work in Alpine Linux.</span><br>$ tar Cxzvf /usr/local containerd-1.1.7-linux-amd64.tar.gz<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证containerd安装</span><br>$ whereis containerd<br>$ containerd --version<br></code></pre></td></tr></table></figure><h3 id="四、配置containerd"><a href="#四、配置containerd" class="headerlink" title="四、配置containerd"></a>四、配置containerd</h3><ol><li>生成默认配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建文件夹</span><br>$ <span class="hljs-built_in">mkdir</span> -p /etc/containerd<br>$ containerd config default &gt; /etc/containerd/config.toml<br><span class="hljs-comment"># 查看配置</span><br>$ containerd config dump<br></code></pre></td></tr></table></figure><ol start="2"><li>cni配置生成</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看cni配置目录</span><br>$ <span class="hljs-built_in">cat</span> /etc/containerd/config.toml | grep cni<br><br><span class="hljs-comment"># plugins[&quot;io.containerd.grpc.v1.cri&quot;].cni.conf_dir</span><br><span class="hljs-comment"># 配置目录 /etc/cni/net.d</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /etc/cni/net.d<br><span class="hljs-comment"># 生成配置文件</span><br>$ <span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /etc/cni/net.d/10-mynet.conf</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">        &quot;cniVersion&quot;: &quot;0.2.0&quot;,</span><br><span class="hljs-string">        &quot;name&quot;: &quot;mynet&quot;,</span><br><span class="hljs-string">        &quot;type&quot;: &quot;bridge&quot;,</span><br><span class="hljs-string">        &quot;bridge&quot;: &quot;cni0&quot;,</span><br><span class="hljs-string">        &quot;isGateway&quot;: true,</span><br><span class="hljs-string">        &quot;ipMasq&quot;: true,</span><br><span class="hljs-string">        &quot;ipam&quot;: &#123;</span><br><span class="hljs-string">                &quot;type&quot;: &quot;host-local&quot;,</span><br><span class="hljs-string">                &quot;subnet&quot;: &quot;172.19.0.0/24&quot;,</span><br><span class="hljs-string">                &quot;routes&quot;: [</span><br><span class="hljs-string">                        &#123; &quot;dst&quot;: &quot;0.0.0.0/0&quot; &#125;</span><br><span class="hljs-string">                ]</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><ol start="2"><li>systemd</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /usr/local/lib/systemd/system/<br>$ <span class="hljs-built_in">touch</span> /usr/local/lib/systemd/system/containerd.service<br></code></pre></td></tr></table></figure><p>然后拷贝内容 <a href="https://raw.githubusercontent.com/containerd/containerd/main/containerd.service">containerd.service</a> 到 &#x2F;usr&#x2F;local&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;containerd.service, 然后运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl daemon-reload<br>$ systemctl <span class="hljs-built_in">enable</span> --now containerd<br>$ systemctl status containerd<br></code></pre></td></tr></table></figure><h3 id="五、测试containerd运行容器"><a href="#五、测试containerd运行容器" class="headerlink" title="五、测试containerd运行容器"></a>五、测试containerd运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo ctr image pull docker.io/library/busybox:latest<br>$ sudo ctr run --cni -t --<span class="hljs-built_in">rm</span> docker.io/library/busybox:latest hello sh<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-如何查看containerd的插件有哪些"><a href="#1-如何查看containerd的插件有哪些" class="headerlink" title="1.如何查看containerd的插件有哪些"></a>1.如何查看containerd的插件有哪些</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ctr plugin <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><h5 id="2-如何离线安装golang"><a href="#2-如何离线安装golang" class="headerlink" title="2.如何离线安装golang"></a>2.如何离线安装golang</h5><p>要在Linux系统上离线安装Golang，您可以按照以下步骤操作：</p><ol><li>在具有Internet连接的计算机上下载<a href="https://go.dev/dl/">Golang二进制文件包（tar.gz或zip格式）</a></li><li>将下载的文件包复制到您的离线Linux计算机。您可以使用USB驱动器或其他外部存储设备完成此操作</li><li>在Linux计算机上解压缩文件包并将其移动到适当的位置，例如<code>/usr/local/bin</code>目录<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tar -C /usr/local -xzf go1.19.10.linux-arm64.tar.gz<br></code></pre></td></tr></table></figure></li><li>在<code>/etc/profile</code>文件中添加Golang环境变量。将以下行添加到文件底部，将<code>&lt;install-dir&gt;</code>替换为您的Golang安装目录：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=$PATH:/usr/local/go/bin&#x27;</span> | <span class="hljs-built_in">tee</span> -a /etc/profile<br></code></pre></td></tr></table></figure></li><li>保存并关闭文件后，使用以下命令使配置更改生效：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure></li><li>验证Golang是否正确安装并可以使用：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go version<br></code></pre></td></tr></table></figure></li></ol><h3 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h3><p><a href="https://www.cni.dev/">https://www.cni.dev/</a><br><a href="https://github.com/kubernetes/website/blob/dev-1.24/content/en/docs/tasks/administer-cluster/migrating-from-dockershim/troubleshooting-cni-plugin-related-errors.md#an-example-containerd-configuration-file">cni&#x2F;net.d的containerd配置文件示例</a><br><a href="https://github.com/kata-containers/kata-containers/blob/3.0.2/docs/how-to/containerd-kata.md#configuration-for-cri-tools">kata-containers的cri-tools的CNI默认配置</a><br><a href="https://github.com/containerd/containerd/blob/v1.7.0/docs/snapshotters/devmapper.md">containerd-v1.7.0安装snapshotters.devmapper</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何添加node节点</title>
    <link href="/2023/05/06/kubernetes/%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0node%E8%8A%82%E7%82%B9/"/>
    <url>/2023/05/06/kubernetes/%E5%A6%82%E4%BD%95%E6%B7%BB%E5%8A%A0node%E8%8A%82%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ol><li>master节点生成token</li></ol><p><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-token/">setup-tools&#x2F;kubeadm&#x2F;kubeadm-token&#x2F;</a><br><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-join/">setup-tools&#x2F;kubeadm&#x2F;kubeadm-join&#x2F;</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubeadm token create  --description <span class="hljs-string">&quot;test-token&quot;</span> --ttl=0 --print-join-command | grep discovery-token-ca-cert-hash<br>$ kubeadm token list<br>$ kubeadm token delete &lt;token&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>node节点环境搭建</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">containerd<br>cni<br>kubeadm\kubelet\kubectl<br></code></pre></td></tr></table></figure><ol start="3"><li>node节点加入集群</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 已经有集群环境的可以reset一下</span><br>$ kubeadm reset<br><br><span class="hljs-comment"># discovery-token对应token</span><br><span class="hljs-comment"># discovery-token-ca-cert-hash对应上面的hash</span><br>$ kubeadm <span class="hljs-built_in">join</span> &lt;control-plane-host&gt;:&lt;control-plane-port&gt; --token &lt;token&gt; --discovery-token-ca-cert-hash sha256:&lt;<span class="hljs-built_in">hash</span>&gt;<br>$ kubeadm <span class="hljs-built_in">join</span> --discovery-token cmjgty.wy9bqt0y6v8nmkln --discovery-token-ca-cert-hash sha256:93a525dfa1ead4fae6901dabc4bbb3d0467040118b1c8d68bbbb7fc688f069d1 10.16.203.160:6443<br><br><span class="hljs-comment"># 查看kubectl配置</span><br>$ kubectl config view<br>$ <span class="hljs-built_in">cp</span> /etc/kubernetes/kubelet.conf ~/.kube/config<br>$ kubectl get pod<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker集成gvisor</title>
    <link href="/2023/04/23/docker/docker%E9%9B%86%E6%88%90gvisor/"/>
    <url>/2023/04/23/docker/docker%E9%9B%86%E6%88%90gvisor/</url>
    
    <content type="html"><![CDATA[<h3 id="一、安装gvisor"><a href="#一、安装gvisor" class="headerlink" title="一、安装gvisor"></a>一、安装gvisor</h3><p><a href="https://gvisor.dev/docs/user_guide/install/">https://gvisor.dev/docs/user_guide/install/</a></p><h3 id="二、运行容器验证"><a href="#二、运行容器验证" class="headerlink" title="二、运行容器验证"></a>二、运行容器验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前docker支持的运行时</span><br>$ docker info | grep Runtime<br><br><span class="hljs-comment"># 基于runtime=runsc创建容器</span><br>$ docker run --runtime=runsc --memory=1g -itd --name centos-test3 centos:centos7<br><br><span class="hljs-comment"># 进入容器查看</span><br>$ docker <span class="hljs-built_in">exec</span> -it centos-test3 /bin/bash<br><br><span class="hljs-comment"># 比较和宿主机的内存</span><br>$ free -m<br><br><span class="hljs-comment"># 基于runc创建容器试试(验证后发现内存隔离并未生效)</span><br>$ docker run --runtime=runc --memory=1g -itd --name centos-test5 centos:centos7<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://gvisor.dev/docs/user_guide/quick_start/docker/">docker use gvisor</a><br><a href="https://gvisor.dev/docs/user_guide/install/">gvisor install</a><br><a href="https://gvisor.dev/docs/user_guide/containerd/quick_start/">containerd quick_start</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iperf用法</title>
    <link href="/2023/04/23/cni/iperf%E7%94%A8%E6%B3%95/"/>
    <url>/2023/04/23/cni/iperf%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、工具用途"><a href="#一、工具用途" class="headerlink" title="一、工具用途"></a>一、工具用途</h3><p>测试带宽工具，具备类似功能的工具还有scp、wget。</p><h3 id="二、开始带宽测试"><a href="#二、开始带宽测试" class="headerlink" title="二、开始带宽测试"></a>二、开始带宽测试</h3><ol><li><p>直接容器启动一个iperf3的server和client测试带宽，来一个<a href="https://github.com/nerdalert/iperf3/blob/master/README.md">quickstart</a></p></li><li><p>服务器之间带宽测试</p></li></ol><ul><li>install iperf3</li></ul><p>安装包下载地址<a href="https://iperf.fr/iperf-download.php">iperf.fr&#x2F;iperf-download</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 包管理工具安装rpm或者deb</span><br>$ rpm -ih *.rpm<br>$ dpkg -i *.deb<br>$ apt install *.deb<br><br><span class="hljs-comment"># 在线安装</span><br><span class="hljs-comment"># 如果没有找一个可靠的yum源</span><br>yum install iperf3<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 源码编译安装</span><br>yum -y install gcc make wget<br><span class="hljs-built_in">cd</span> /tmp<br>wget https://iperf.fr/download/source/iperf-3.1.3-source.tar.gz<br>tar zxvf iperf-3.1.3-source.tar.gz<br><span class="hljs-built_in">cd</span> iperf-3.1.3<br>./configure<br>make<br>make install<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动client &amp;&amp; server测试</span><br>iperf3 有客户端 和 服务端之别：<br><br>服务端：收包，使用 -s 参数指定， iperf3 -s<br>客户端：发包，使用 -c xx.xx.xx.xx 来指定要往哪个服务端发包， iperf3 -c 172.20.20.200<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/yingsong/p/5682080.html">iperf3详细参数说明</a></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-wget怎么测试带宽"><a href="#1-wget怎么测试带宽" class="headerlink" title="1.wget怎么测试带宽"></a>1.wget怎么测试带宽</h5><p>可以使用 <code>wget</code> 命令来测试带宽，方法如下：</p><ol><li><p>找到一个大文件的下载链接，比如一个 ISO 镜像文件或者大型软件的安装包。</p></li><li><p>在终端中使用以下命令下载该文件，并指定输出日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget -O /dev/null http://example.com/largefile.iso 2&gt;&amp;1 | <span class="hljs-built_in">tee</span> speedtest.log<br></code></pre></td></tr></table></figure><p>其中，<code>-O /dev/null</code> 表示将下载的文件输出到空设备，而不是存储在本地磁盘上，<code>2&gt;&amp;1</code> 表示将错误输出也重定向到日志中，<code>tee</code> 命令则将 <code>wget</code> 命令的输出同时输出到终端和日志文件中。</p></li><li><p>等待下载完成后，查看日志文件中的下载速度，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Downloaded: 1 files, 734M <span class="hljs-keyword">in</span> 8m 30s (1.44 MB/s)<br></code></pre></td></tr></table></figure><p>其中 <code>1.44 MB/s</code> 就是下载速度，单位为兆字节每秒。可以多次测试，取平均值作为最终的带宽测试结果。</p></li></ol><h5 id="2-scp如何测试带宽"><a href="#2-scp如何测试带宽" class="headerlink" title="2.scp如何测试带宽"></a>2.scp如何测试带宽</h5><p>使用 scp 测试带宽的过程如下:</p><ol><li>在一台机器上，作为服务器运行 scp 命令来监听端口。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ scp -v -l 8192 file.tar.gz user@remote-host:/dev/null<br></code></pre></td></tr></table></figure>其中 8192 是带宽大小，文件名为 file.tar.gz，路径为远程主机的 &#x2F;dev&#x2F;null（即丢弃该文件，只是测试带宽）。</li><li>在另一台机器上，作为客户端运行 scp 命令进行下载文件。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ scp -v user@remote-host:/path/to/file.tar.gz /dev/null<br></code></pre></td></tr></table></figure>该命令将从远程主机下载文件并丢弃该文件，只是测试带宽。</li><li>在下载完毕后，scp 将输出带宽测试结果。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">Transferred: ...........Total...........   Speed<br>100% ................ byes  time (s) ...  KB/s<br></code></pre></td></tr></table></figure><p>其中 KB&#x2F;s 表示测试的带宽。</p><h5 id="3-iperf指标查看"><a href="#3-iperf指标查看" class="headerlink" title="3. iperf指标查看"></a>3. iperf指标查看</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">Connecting to host 172.17.0.2, port 5201<br>[  5] <span class="hljs-built_in">local</span> 172.17.0.3 port 33370 connected to 172.17.0.2 port 5201<br>[ ID] Interval           Transfer     Bitrate         Retr  Cwnd<br>[  5]   0.00-1.00   sec  3.55 GBytes  30.5 Gbits/sec    0    185 MBytes       <br>[  5]   1.00-2.00   sec  3.54 GBytes  30.5 Gbits/sec  25972    185 MBytes       <br>[  5]   2.00-3.00   sec  3.57 GBytes  30.6 Gbits/sec    0    185 MBytes       <br>[  5]   3.00-4.00   sec  3.57 GBytes  30.7 Gbits/sec    0    185 MBytes       <br>[  5]   4.00-5.00   sec  3.58 GBytes  30.7 Gbits/sec    0    185 MBytes       <br>[  5]   5.00-6.00   sec  3.54 GBytes  30.4 Gbits/sec    0    185 MBytes       <br>[  5]   6.00-7.00   sec  3.49 GBytes  30.0 Gbits/sec    0    185 MBytes       <br>[  5]   7.00-8.00   sec  3.55 GBytes  30.5 Gbits/sec    0    185 MBytes       <br>[  5]   8.00-9.00   sec  3.52 GBytes  30.2 Gbits/sec    0    185 MBytes       <br>[  5]   9.00-10.00  sec  3.54 GBytes  30.4 Gbits/sec  4294941326   0.00 Bytes    <br></code></pre></td></tr></table></figure><ul><li>Interval：测试的时长</li><li>Transfer：在 Interval 时长里，传输的数据量</li><li>Bitrate：传输速率</li><li>Jitter：网络抖动，连续发送数据包时延差值的平均值，越小说明网络质量越好</li><li>Lost&#x2F;Total Datagrams：丢失的数据包与发送的总数据包</li></ul><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://iperf.fr/iperf-download.php">https://iperf.fr/iperf-download.php</a><br><a href="https://github.com/nerdalert/iperf3">docker images nerdalert&#x2F;iperf3</a><br><a href="https://iperf.fr/download/source/iperf-3.1.3-source.tar.gz">https://iperf.fr/download/source/iperf-3.1.3-source.tar.gz</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iperf</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何配置静态路由</title>
    <link href="/2023/04/23/cni/linux%E4%B8%8A%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/"/>
    <url>/2023/04/23/cni/linux%E4%B8%8A%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是静态路由"><a href="#一、什么是静态路由" class="headerlink" title="一、什么是静态路由"></a>一、什么是静态路由</h3><p>通过手动配置路由表的方式，在网络中设置<code>固定的路由路径</code>以实现数据包的转发和路由选择的方法；</p><h3 id="二、使用route配置静态路由"><a href="#二、使用route配置静态路由" class="headerlink" title="二、使用route配置静态路由"></a>二、使用route配置静态路由</h3><ol><li>将 169.254.0.0&#x2F;16 网络的数据包转发到 10.16.200.0&#x2F;21 子网中：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将目标网络为169.254.0.0，子网掩码为255.255.0.0的数据包通过网关10.16.200.1进行路由转发</span><br><span class="hljs-comment"># 当本机需要访问169.254.0.0/16网络的时候，会直接通过10.16.200.1这个网关进行路由转发</span><br><span class="hljs-comment"># -net 169.254.0.0：指定要添加路由的网络地址。</span><br><span class="hljs-comment"># netmask 255.255.0.0：指定网络掩码。</span><br><span class="hljs-comment"># gw 10.16.200.1：指定网关 IP 地址。</span><br><br>$ route add -net 169.254.0.0 netmask 255.255.0.0 gw 10.16.200.1<br></code></pre></td></tr></table></figure><ol start="2"><li>验证路由是否添加成功：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ route -n<br></code></pre></td></tr></table></figure><h3 id="三、使用ip命令配置静态路由"><a href="#三、使用ip命令配置静态路由" class="headerlink" title="三、使用ip命令配置静态路由"></a>三、使用ip命令配置静态路由</h3><ol><li>添加静态路由</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将目标网络为169.254.0.0，子网掩码为255.255.0.0的数据包通过网关10.16.200.1进行路由转发</span><br><span class="hljs-comment"># 当本机需要访问169.254.0.0/16网络的时候，会直接通过10.16.200.1这个网关进行路由转发</span><br><span class="hljs-comment"># 将 169.254.0.0/16 网络的数据包转发到 10.16.200.0/21 子网中</span><br><span class="hljs-comment"># add 169.254.0.0/16：指定要添加路由的网络地址和掩码。</span><br><span class="hljs-comment"># via 10.16.200.1：指定网关 IP 地址。</span><br><br>$ ip route add 169.254.0.0/16 via 10.16.200.1<br></code></pre></td></tr></table></figure><ol start="2"><li>验证路由是否添加成功：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip route<br></code></pre></td></tr></table></figure><h3 id="四、ping演示数据包流转"><a href="#四、ping演示数据包流转" class="headerlink" title="四、ping演示数据包流转"></a>四、ping演示数据包流转</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip route<br><span class="hljs-comment"># 默认网关是 10.16.207.254</span><br>default via 10.16.207.254 dev enp1s0 proto dhcp metric 100 <br>10.16.200.0/21 dev enp1s0 proto kernel scope <span class="hljs-built_in">link</span> src 10.16.203.189 metric 100 <br><span class="hljs-comment"># （本机无法获取到有效IP地址时，会自动分配一个169.254.x.x的IP地址，并可以在enp1s0接口上进行通信）</span><br>169.254.0.0/16 dev enp1s0 scope <span class="hljs-built_in">link</span> <br>172.17.0.0/16 dev docker0 proto kernel scope <span class="hljs-built_in">link</span> src 172.17.0.1 <br>192.168.122.0/24 dev virbr0 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.122.1 linkdown <br><br><span class="hljs-comment"># 因为169.254.0.0/16是一个保留的私有IP地址范围，通常被用于自动配置设备的IP地址，例如当DHCP服务器不可用时。</span><br><span class="hljs-comment"># 在该路由表中，169.254.0.0/16 dev enp1s0 scope link被定义为本地链接，因此ping 169.254.1.1时</span><br><span class="hljs-comment"># 系统会尝试与本地连接的设备通信，但目标设备不可达，因此会返回&quot;Destination Host Unreachable&quot;。</span><br>$ ping 169.254.1.1<br>PING 169.254.1.1 (169.254.1.1) 56(84) bytes of data.<br>From 10.16.203.189 icmp_seq=1 Destination Host Unreachable<br>From 10.16.203.189 icmp_seq=2 Destination Host Unreachable<br>From 10.16.203.189 icmp_seq=3 Destination Host Unreachable<br><br><span class="hljs-comment"># 没有静态路由</span><br>$ ping 189.12.0.1 <br>PING 189.12.0.1 (189.12.0.1) 56(84) bytes of data.<br>64 bytes from 189.12.0.1: icmp_seq=1 ttl=52 time=368 ms<br>64 bytes from 189.12.0.1: icmp_seq=2 ttl=52 time=367 ms<br>64 bytes from 189.12.0.1: icmp_seq=3 ttl=52 time=366 ms<br><br><br><span class="hljs-comment"># 下一跳是网关 10.16.200.1</span><br>$ ip route add 189.12.0.0/16 via 10.16.200.1<br>$ ip route<br>default via 10.16.207.254 dev enp1s0 proto dhcp metric 100 <br>10.16.200.0/21 dev enp1s0 proto kernel scope <span class="hljs-built_in">link</span> src 10.16.203.189 metric 100 <br>169.254.0.0/16 dev enp1s0 scope <span class="hljs-built_in">link</span> <br>172.17.0.0/16 dev docker0 proto kernel scope <span class="hljs-built_in">link</span> src 172.17.0.1 <br>189.12.0.0/16 via 10.16.200.1 dev enp1s0 <br>192.168.122.0/24 dev virbr0 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.122.1 linkdown <br><br>$ ping 189.12.0.1  <br></code></pre></td></tr></table></figure><p>如果需要通过ping演示，则需要满足以下条件：</p><ol><li>本机的IP地址不属于169.254.0.0&#x2F;16网络；</li><li>网络中存在一个IP地址为10.16.200.1的网关；</li><li>目标主机的IP地址属于169.254.0.0&#x2F;16网络。</li></ol><p>假设目标主机的IP地址为169.254.1.1，可以通过以下命令进行ping测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 根据路由表，数据包将通过enp1s0网络接口发送，首先发送到10.16.200.1</span><br><span class="hljs-comment"># 然后到达目标地址189.12.0.1。如果没有其他的网络配置或防火墙规则阻止，数据包应该能够到达并从目标地址返回。</span><br>ping 169.254.1.1<br></code></pre></td></tr></table></figure><p>如果静态路由配置正确，且网络中存在可达目标主机的路径，那么ping应该可以正常回应。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch隧道GRE&amp;VXLAN</title>
    <link href="/2023/04/23/cni/openvswitch%E9%9A%A7%E9%81%93GRE&amp;VXLAN/"/>
    <url>/2023/04/23/cni/openvswitch%E9%9A%A7%E9%81%93GRE&amp;VXLAN/</url>
    
    <content type="html"><![CDATA[<ol><li>准备linux环境</li></ol><ul><li><a href="https://weiqiangxu.github.io/2023/06/02/cni/openvswitch%E5%AE%89%E8%A3%85/">openvswitch如何安装</a></li><li><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">docker离线安装</a>也可以直接使用yum等包管理工具在线安装</li></ul><ol start="2"><li>host1 (ip 10.16.203.35)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl stop firewalld<br>$ ovs-vsctl add-br ovs-test-br1<br>$ ifconfig ovs-test-br1 192.168.4.10/24 up<br>$ ip route<br></code></pre></td></tr></table></figure><ol start="3"><li>host2 (ip 10.16.203.32)</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl stop firewalld<br>$ ovs-vsctl add-br ovs-test-br1<br>$ ifconfig ovs-test-br1 192.168.4.11/24 up<br>$ ip route<br></code></pre></td></tr></table></figure><ol start="4"><li>host1 ping host2</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ping 192.168.4.11<br></code></pre></td></tr></table></figure><ol start="5"><li>建设GRE隧道</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br>$ ovs-vsctl add-port ovs-test-br1 gre1 -- <span class="hljs-built_in">set</span> interface gre1 <span class="hljs-built_in">type</span>=gre option:remote_ip=10.16.203.32<br>$ ovs-vsctl show<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host2</span><br>$ ovs-vsctl add-port ovs-test-br1 gre1 -- <span class="hljs-built_in">set</span> interface gre1 <span class="hljs-built_in">type</span>=gre option:remote_ip=10.16.203.35<br>$ ovs-vsctl show<br></code></pre></td></tr></table></figure><ol start="6"><li>host1 ping host2</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br><span class="hljs-comment"># 此时可以通讯</span><br>$ ping 192.168.4.11<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br>$ ovs-vsctl del-port ovs-test-br1 gre1<br><span class="hljs-comment"># host2 </span><br>$ ovs-vsctl del-port ovs-test-br1 gre1<br>$ ovs-vsctl show<br><span class="hljs-comment"># host1 ping host2 </span><br><span class="hljs-comment"># 此时已经无法通讯</span><br>$ ping 192.168.4.11<br></code></pre></td></tr></table></figure><ol start="7"><li>建设VXLAN隧道</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># host1</span><br>ovs-vsctl add-port ovs-test-br1 vxlan1 -- <span class="hljs-built_in">set</span> Interface vxlan1 <span class="hljs-built_in">type</span>=vxlan options:remote_ip=10.16.203.32<br><br><span class="hljs-comment"># host2</span><br>ovs-vsctl add-port ovs-test-br1 vxlan1 -- <span class="hljs-built_in">set</span> Interface vxlan1 <span class="hljs-built_in">type</span>=vxlan options:remote_ip=10.16.203.35<br><br><span class="hljs-comment"># host1 </span><br><span class="hljs-comment"># 此时可以通讯</span><br>$ ping 192.168.4.11<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-如何删除下面的所有关于-ovs-test-br0的路由规则"><a href="#1-如何删除下面的所有关于-ovs-test-br0的路由规则" class="headerlink" title="1.如何删除下面的所有关于 ovs-test-br0的路由规则"></a>1.如何删除下面的所有关于 ovs-test-br0的路由规则</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ip route<br><br>default via 10.16.207.254 dev br-ext<br>10.16.200.0/21 dev br-ext proto kernel scope <span class="hljs-built_in">link</span> src 10.16.203.160<br>169.254.0.0/16 dev br-ext scope <span class="hljs-built_in">link</span><br>192.168.4.0/24 dev ovs-test-br0 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.4.10<br>192.168.5.0/24 dev ovs-test-br1 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.5.23<br>192.168.122.0/24 dev virbr0 proto kernel scope <span class="hljs-built_in">link</span> src 192.168.122.1 linkdown<br><br><span class="hljs-comment"># 注意删除规则是: ip route delete &lt;route&gt; </span><br><span class="hljs-comment"># &lt;route&gt;指要删除的路由。该命令用于删除一个已存在的路由</span><br><span class="hljs-comment"># 192.168.4.0/24 dev ovs-test-br0 就是&lt;route&gt;</span><br>$  ip route delete 192.168.4.0/24 dev ovs-test-br0<br></code></pre></td></tr></table></figure><h5 id="2-route-add-default-gw-192-168-5-1-dev-ovs-test-br1-和-route-add-192-168-5-1-dev-ovs-test-br1有什么区别"><a href="#2-route-add-default-gw-192-168-5-1-dev-ovs-test-br1-和-route-add-192-168-5-1-dev-ovs-test-br1有什么区别" class="headerlink" title="2.route add default gw 192.168.5.1 dev ovs-test-br1 和 route add 192.168.5.1 dev ovs-test-br1有什么区别"></a>2.route add default gw 192.168.5.1 dev ovs-test-br1 和 route add 192.168.5.1 dev ovs-test-br1有什么区别</h5><p>   route add default gw 192.168.5.1 dev ovs-test-br1 是将默认路由设置为通过 ovs-test-br1 网桥连接至 192.168.5.1 网关，所有未知目标 IP 地址的流量都将通过该网关路由出去。<br>   route add 192.168.5.1 dev ovs-test-br1 是将指定 IP 地址 192.168.5.1 的路由设置为通过 ovs-test-br1 网桥连接，所有目标为该 IP 地址的流量将通过该网桥路由出去。<br>   两者的区别在于默认路由是指定了所有未知目标 IP 地址的流量都将通过该网关路由出去，而指定一个具体的 IP 地址的路由则只会影响到指定的 IP 地址的流量。</p><h5 id="3-什么是网络出现了环"><a href="#3-什么是网络出现了环" class="headerlink" title="3.什么是网络出现了环"></a>3.什么是网络出现了环</h5><p>   网络出现了环指网络拓扑中出现了连接成环状的情况。<br>   在一个网络中，环路会导致数据包在网络中无限循环，造成网络拥塞和性能下降。<br>   拓扑图是<code>1 -&gt; 2 -&gt; 3 -&gt; 5 -&gt; 4 -&gt; 1</code>表示出现了环。</p><h5 id="4-ovs-vsctl-set-bridge-br-name-stp-enable-x3D-true"><a href="#4-ovs-vsctl-set-bridge-br-name-stp-enable-x3D-true" class="headerlink" title="4. ovs-vsctl set bridge ${br_name} stp_enable&#x3D;true"></a>4. ovs-vsctl set bridge ${br_name} stp_enable&#x3D;true</h5><p>   这句命令是用来设置 Open vSwitch 网桥的 Spanning Tree Protocol (STP) 功能是否启用。<br>   STP 是一种用于在拓扑结构中防止环路出现的协议。当多个交换机互连形成网络时，可能会出现环路，导致网络出现广播风暴等问题。为了避免这种情况，可以使用 STP 协议计算出一个最佳拓扑结构，并通过阻塞某些端口来避免环路的产生。<br>   该命令中的 <code>$&#123;br_name&#125;</code> 是要设置的网桥的名称。将 <code>stp_enable</code> 参数设置为 <code>true</code>，表示启用 STP 功能。如果该参数设置为 <code>false</code>，则表示禁用 STP 功能。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GRE</tag>
      
      <tag>VXLAN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络不通问题排查</title>
    <link href="/2023/04/23/cni/%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <url>/2023/04/23/cni/%E7%BD%91%E7%BB%9C%E4%B8%8D%E9%80%9A%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="一、问题描述"><a href="#一、问题描述" class="headerlink" title="一、问题描述"></a>一、问题描述</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看</span><br>$ kubectl get svc<br>NAME           TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)        AGE<br>kubernetes     ClusterIP   10.96.0.1     &lt;none&gt;        443/TCP        3d23h<br>loki-service   NodePort    10.96.167.4   &lt;none&gt;        80:30009/TCP   37h<br><br><span class="hljs-comment"># 查看service详细</span><br>$ kubectl describe svc kubernetes<br>Name:              kubernetes<br>Namespace:         default<br>Labels:            component=apiserver<br>                   provider=kubernetes<br>Annotations:       &lt;none&gt;<br>Selector:          &lt;none&gt;<br>Type:              ClusterIP<br>IP Family Policy:  SingleStack<br>IP Families:       IPv4<br>IP:                10.96.0.1<br>IPs:               10.96.0.1<br>Port:              https  443/TCP<br>TargetPort:        6443/TCP<br>Endpoints:         10.16.203.160:6443 <span class="hljs-comment"># 端点，表示这个Service对应的backend后台pod服务端点</span><br>Session Affinity:  None<br>Events:            &lt;none&gt;<br><br><span class="hljs-comment"># 进入pod无法访问</span><br>$ kubectl <span class="hljs-built_in">exec</span> -it test-nginx-deployment-ff8c6f675-fjq4l -n sdn-1 -- /bin/sh<br><br>$ curl 10.96.0.1:443<br><span class="hljs-comment"># 没有任何输出表示无法连接</span><br><span class="hljs-comment"># 这一行是正常情况会输出的，但是没有输出 `Client sent an HTTP request to an HTTPS server.`</span><br></code></pre></td></tr></table></figure><h3 id="二、通信原理"><a href="#二、通信原理" class="headerlink" title="二、通信原理"></a>二、通信原理</h3><p>在 pod nginx 之中curl service of kubernetes的 cluster IP，最终会指向 service 的 Endpoints ，也就是说本质上是 pod 与 Endpoints无法连通，继续追踪他们之间的数据流走向。</p><ul><li>1.查看svc of kubernetes的Endpoint <code>kubectl describe svc kubernetes</code></li><li>2.pod的IP可以找到该pod所在的网络接口(需要到pod所在的宿主机才能看到该网络接口)，例如 <code>ovs-vsctl show</code> or <code>ifconfig</code></li><li>3.对pod的网络接口(网卡)进行抓包，该网卡的数据是否发送出去</li><li>4.nginx pod对应的网卡 if2090037512165 在网桥 br0 上面，此时找出网卡 if2090037512165 最终流向是物理网卡 br-ext上面的 enp1s0</li><li>5.那么对物理网卡 enp1s0 进行抓包，可以看到 pod的流量最终是否已经发送出去</li><li>6.在这里如果看到是物理网卡的配置出错了，问题排查结束</li></ul><blockquote><p>通信的大致流程是: 容器POD -&gt; 网络接口eth1 -&gt; 网桥br0 (SDN虚拟网卡所在) -&gt; 网桥 br-ext (傻瓜式网桥分配了物理网卡) -&gt; 网络接口ens1</p></blockquote><h3 id="二、Q-amp-A"><a href="#二、Q-amp-A" class="headerlink" title="二、Q&amp;A"></a>二、Q&amp;A</h3><ol><li>如何查看pod对应的网卡是哪个</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取 pod ip</span><br>$ kubectl get pod test-nginx-deployment-ff8c6f675-2w4d6 -n sdn-1 -o wide<br><span class="hljs-comment"># 获取pod ip对应的网卡</span><br>$ kubectl get nic -A | grep 192.100.0.31<br></code></pre></td></tr></table></figure><ul><li>指令ip a 和ip route和ifconfig有什么区别</li></ul><ol start="2"><li>tcpdump如何监听网卡eth1以及添加过滤条件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ tcpdump -nei br-ext host 10.16.203.160 and host 10.16.203.161<br></code></pre></td></tr></table></figure><ol start="3"><li>当前的拓扑图是什么</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前的网络接口（网卡）和网桥</span><br>$ ovs-vsctl show<br><br>039d1355-682e-490f-ad61-f41ab452a83f<br>    Bridge br-ext<br>        Port <span class="hljs-string">&quot;enp1s0&quot;</span><br>            Interface <span class="hljs-string">&quot;enp1s0&quot;</span><br>        Port eth-ext<br>            Interface eth-ext<br>        Port br-ext<br>            Interface br-ext<br>                <span class="hljs-built_in">type</span>: internal<br>    Bridge <span class="hljs-string">&quot;br0&quot;</span><br>        <span class="hljs-comment"># 表示当前已经连接控制器,其实就是SDN POD的地址</span><br>        Controller <span class="hljs-string">&quot;tcp:127.0.0.1:6632&quot;</span><br>            is_connected: <span class="hljs-literal">true</span><br>        fail_mode: secure<br>        Port <span class="hljs-string">&quot;if1210073dc80a9&quot;</span><br>            Interface <span class="hljs-string">&quot;if1210073dc80a9&quot;</span><br>        Port <span class="hljs-string">&quot;if05000a8c7a14a&quot;</span><br>            Interface <span class="hljs-string">&quot;if05000a8c7a14a&quot;</span><br>        Port <span class="hljs-string">&quot;br0&quot;</span><br>            Interface <span class="hljs-string">&quot;br0&quot;</span><br>                <span class="hljs-built_in">type</span>: internal<br>        Port <span class="hljs-string">&quot;if19100bcc04d54&quot;</span><br>            Interface <span class="hljs-string">&quot;if19100bcc04d54&quot;</span><br>        Port <span class="hljs-string">&quot;if1350034b52b93&quot;</span><br>            Interface <span class="hljs-string">&quot;if1350034b52b93&quot;</span><br>        Port eth-int<br>            Interface eth-int<br></code></pre></td></tr></table></figure><ol start="4"><li>当前无法连接apiserver的pod的ip</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pod test-nginx-deployment-ff8c6f675-2w4d6 -n sdn-1 -o wide<br><br><span class="hljs-comment"># 详细的pod信息输出</span><br>NAME                                    READY   STATUS    RESTARTS   AGE   IP             NODE       NOMINATED NODE   READINESS GATES<br>test-nginx-deployment-ff8c6f675-2w4d6   1/1     Running   0          4d    192.100.0.30   k8s-node   &lt;none&gt;           &lt;none&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>如何查看pod的ip对应的网络接口是哪个</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 所有网络接口（nic）中</span><br><span class="hljs-comment"># 筛选出IP地址为192.100.0.31的网络接口</span><br><br>$ kubectl get nic -A | grep 192.100.0.31<br><span class="hljs-comment"># 找出pod test-nginx-deployment-ff8c6f675-jmglr 使用的网络接口是 if2090037512165</span><br>kube-system   192.100.0.31-vpc-default    test-nginx-deployment-ff8c6f675-fjq4l            if2090037512165<br><br><span class="hljs-comment"># 这个网络接口是 if2090037512165 ,那么pod的流量是经过 if2090037512165出去的，之后经过网桥</span><br><span class="hljs-comment"># 那么对 网络接口 if2090037512165 进行抓包可以看到这个 pod的流量最终的走向</span><br><span class="hljs-comment"># 那么如何对网络接口 if2090037512165 进行抓包呢</span><br><span class="hljs-comment"># 1.需要进入 pod test-nginx-deployment-ff8c6f675-2w4d6 所在的节点</span><br>$ ssh root@k8s-node <br>$ ifconfig<br><br>eth-int: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet6 fe80::68aa:aeff:fe46:f6a6  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether 6a:aa:ae:46:f6:a6  txqueuelen 1000  (Ethernet)<br>        RX packets 16668713  bytes 2776010709 (2.5 GiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 686  bytes 162881 (159.0 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>if2090037512165(网络接口名称): flags=4163&lt;UP (接口的当前状态),BROADCAST(是否支持广播),RUNNING(是否运行),MULTICAST&gt; (是否支持多播)  mtu 1500<br>        inet6 fe80::fc00:37ff:fe51:2165 (分配给接口的IPv6地址)  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        ether fe:00:37:51:21:65 (接口的MAC地址)  txqueuelen 1000  (Ethernet)<br>        <span class="hljs-comment"># RX 和 TX 计数器：它们表示接受和发送的数据包数量和字节数</span><br>        RX packets 0  bytes 0 (0.0 B) <br>        RX errors 0  dropped 0  overruns 0  frame 0 <br>        TX packets 0  bytes 0 (0.0 B) <br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0 <br><br><span class="hljs-comment"># 那么此时可以查看到当前的网卡(网络接口) if2090037512165 详细情况</span><br><span class="hljs-comment"># 在非 k8s-node 节点则没有这个网络接口</span><br>$ ifconfig | grep if2090037512165 <br><span class="hljs-comment"># 没有输出</span><br><br><span class="hljs-comment"># 抓包命令</span><br>$ tcpdump -nei if2090037512165<br><br>dropped privs to tcpdump<br>tcpdump: verbose output suppressed, use -v or -vv <span class="hljs-keyword">for</span> full protocol decode<br>listening on if2090037512165, link-type EN10MB (Ethernet), capture size 262144 bytes<br><br><br><span class="hljs-comment"># 新开另一个窗口</span><br>$ kubectl <span class="hljs-built_in">exec</span> -it test-nginx-deployment-ff8c6f675-fjq4l -n sdn-1 -- /bin/sh<br><br><span class="hljs-comment"># curl svc of kubernetes&#x27;s cluster ip</span><br>$ curl 10.96.0.1:443<br>Client sent an HTTP request to an HTTPS server.<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此时listen的输出</span><br>14:35:24.745030 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 74: 192.100.0.31.41560 &gt; 10.16.203.160.sun-sr-https: Flags [S], <span class="hljs-built_in">seq</span> 1572642610, win 64240, options [mss 1460,sackOK,TS val 2923462901 ecr 0,nop,wscale 7], length 0<br>14:35:24.745319 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype IPv4 (0x0800), length 74: 10.16.203.160.sun-sr-https &gt; 192.100.0.31.41560: Flags [S.], <span class="hljs-built_in">seq</span> 4252626572, ack 1572642611, win 65160, options [mss 1460,sackOK,TS val 535621017 ecr 2923462901,nop,wscale 7], length 0<br>14:35:24.745357 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 66: 192.100.0.31.41560 &gt; 10.16.203.160.sun-sr-https: Flags [.], ack 1, win 502, options [nop,nop,TS val 2923462901 ecr 535621017], length 0<br>14:35:24.745408 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 143: 192.100.0.31.41560 &gt; 10.16.203.160.sun-sr-https: Flags [P.], <span class="hljs-built_in">seq</span> 1:78, ack 1, win 502, options [nop,nop,TS val 2923462901 ecr 535621017], length 77<br>14:35:24.745514 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype IPv4 (0x0800), length 66: 10.16.203.160.sun-sr-https &gt; 192.100.0.31.41560: Flags [.], ack 78, win 509, options [nop,nop,TS val 535621017 ecr 2923462901], length 0<br>14:35:24.745640 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype IPv4 (0x0800), length 142: 10.16.203.160.sun-sr-https &gt; 192.100.0.31.41560: Flags [P.], <span class="hljs-built_in">seq</span> 1:77, ack 78, win 509, options [nop,nop,TS val 535621017 ecr 2923462901], length 76<br>14:35:24.745662 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 66: 192.100.0.31.41560 &gt; 10.16.203.160.sun-sr-https: Flags [.], ack 77, win 502, options [nop,nop,TS val 2923462901 ecr 535621017], length 0<br>14:35:24.745712 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype IPv4 (0x0800), length 66: 10.16.203.160.sun-sr-https &gt; 192.100.0.31.41560: Flags [F.], <span class="hljs-built_in">seq</span> 77, ack 78, win 509, options [nop,nop,TS val 535621017 ecr 2923462901], length 0<br>14:35:24.745755 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype IPv4 (0x0800), length 66: 192.100.0.31.41560 &gt; 10.16.203.160.sun-sr-https: Flags [F.], <span class="hljs-built_in">seq</span> 78, ack 78, win 502, options [nop,nop,TS val 2923462901 ecr 535621017], length 0<br>14:35:24.745843 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype IPv4 (0x0800), length 66: 10.16.203.160.sun-sr-https &gt; 192.100.0.31.41560: Flags [.], ack 79, win 509, options [nop,nop,TS val 535621017 ecr 2923462901], length 0<br>14:35:29.810470 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Request who-has 192.100.0.254 tell 192.100.0.31, length 28<br>14:35:29.811266 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype ARP (0x0806), length 42: Request who-has 192.100.0.31 (d0:00:37:51:21:65) tell 192.100.0.254, length 28<br>14:35:29.811287 d0:00:37:51:21:65 &gt; fe:ff:ff:ff:ff:ff, ethertype ARP (0x0806), length 42: Reply 192.100.0.31 is-at d0:00:37:51:21:65, length 28<br>14:35:29.812634 fe:ff:ff:ff:ff:ff &gt; d0:00:37:51:21:65, ethertype ARP (0x0806), length 42: Reply 192.100.0.254 is-at fe:ff:ff:ff:ff:ff, length 28<br><br><span class="hljs-comment"># 解释一下这个抓包 （http的三次握手）</span><br><span class="hljs-comment"># 如果此时有输出但是没有数据响应 </span><br></code></pre></td></tr></table></figure><ol start="6"><li>虚拟网卡if2090037512165对应走在哪个网桥呢</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ovs-vsctl show<br><span class="hljs-comment"># 从下面可以看到虚拟网卡(网络接口) 在br0网桥</span><br><span class="hljs-comment"># 并且这个网桥受控于 SDN 控制器也就是: Controller &quot;tcp:127.0.0.1:6632&quot;</span><br><span class="hljs-comment"># 最终结论是虚拟网卡 if2090037512165 对应的网卡是 eth-int </span><br><span class="hljs-comment"># 而 eth-int 的网卡对是最终走了物理网卡 enp1s0</span><br><span class="hljs-comment"># 所以需要对物理网卡 enp1s0 抓包</span><br><span class="hljs-comment"># 判定物理网卡 enp1s0 的流量有没有出去</span><br>b621d944-5691-4c9d-b01c-d8add7b7450f<br>    Bridge br-ext<br>        Port <span class="hljs-string">&quot;enp1s0&quot;</span><br>            Interface <span class="hljs-string">&quot;enp1s0&quot;</span><br>        Port br-ext<br>            Interface br-ext<br>                <span class="hljs-built_in">type</span>: internal<br>        Port eth-ext<br>            Interface eth-ext<br>    Bridge <span class="hljs-string">&quot;br0&quot;</span><br>        Controller <span class="hljs-string">&quot;tcp:127.0.0.1:6632&quot;</span><br>            is_connected: <span class="hljs-literal">true</span><br>        fail_mode: secure<br>        Port eth-int<br>            Interface eth-int<br>        Port <span class="hljs-string">&quot;if2320004a0bceb&quot;</span><br>            Interface <span class="hljs-string">&quot;if2320004a0bceb&quot;</span><br>        Port <span class="hljs-string">&quot;if09100a067b6cf&quot;</span><br>            Interface <span class="hljs-string">&quot;if09100a067b6cf&quot;</span><br>        Port <span class="hljs-string">&quot;br0&quot;</span><br>            Interface <span class="hljs-string">&quot;br0&quot;</span><br>                <span class="hljs-built_in">type</span>: internal<br>        Port <span class="hljs-string">&quot;if0300063b9a65f&quot;</span><br>            Interface <span class="hljs-string">&quot;if0300063b9a65f&quot;</span><br>        Port <span class="hljs-string">&quot;if2090037512165&quot;</span><br>            Interface <span class="hljs-string">&quot;if2090037512165&quot;</span><br>    ovs_version: <span class="hljs-string">&quot;2.12.0&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>网络无法连接时候，排查问题的思路就是理解数据的走向，然后对各个网卡进行抓包，如果抓到是物理网卡出现问题那么脱离软件层面</p></blockquote><ol start="7"><li>如何理解ebpf本质上在这次pod与kubernetes.svc.clusterIP通信时候做了什么事情</li></ol><p>kubernetes service clusterIP 转为 Endpoints 是吗</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CRD控制器</title>
    <link href="/2023/04/23/kubernetes/CRD%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
    <url>/2023/04/23/kubernetes/CRD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h4 id="一、quick-start"><a href="#一、quick-start" class="headerlink" title="一、quick start"></a>一、quick start</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于版本v1.27.2</span><br>$ git <span class="hljs-built_in">clone</span> https://github.com/kubernetes/kubernetes.git<br>$ git checkout v1.27.2<br>$ <span class="hljs-built_in">cd</span> /kubernetes/staging/src/k8s.io/sample-controller<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行之前</span><br>└── samplecontroller<br>    ├── register.go      <span class="hljs-comment"># 定义包package名称</span><br>    └── v1alpha1<br>        ├── doc.go       <span class="hljs-comment"># 声明要使用deepconpy-gen以及groupName</span><br>        ├── register.go  <span class="hljs-comment"># 注册资源</span><br>        └── types.go     <span class="hljs-comment"># 定义crd资源对应的go中的结构</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行code gender生成代码</span><br>$ <span class="hljs-built_in">cd</span> kubernetes/staging/src/k8s.io/sample-controller &amp;&amp; sh ./hack/update-codegen.sh<br><span class="hljs-comment"># 更改 addFunc. cache.ResourceEventHandlerFuncs.AddFunc</span><br>$ vim kubernetes/staging/src/k8s.io/sample-controller/controller.go<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#  代码生成后的文件</span><br>├── apis<br>│   └── samplecontroller<br>│       ├── register.go<br>│       └── v1alpha1<br>│           ├── doc.go<br>│           ├── register.go<br>│           ├── types.go<br>│           └── zz_generated.deepcopy.go     <span class="hljs-comment"># 生成的深拷贝方法</span><br>├── generated                                <span class="hljs-comment"># 生成的文件夹</span><br>│   ├── clientset                            <span class="hljs-comment"># 与Kubernetes API交互的Go客户端库</span><br>│   ├── informers                            <span class="hljs-comment"># Kubernetes API资源上监视和响应高级别客户端库</span><br>│   └── listers                              <span class="hljs-comment"># 本地缓存用于资源查询</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 编译controller 设置匹配的cpu架构和os</span><br>$ go <span class="hljs-built_in">env</span> -w GOOS=<span class="hljs-string">&quot;linux&quot;</span><br>$ go <span class="hljs-built_in">env</span> -w GOARCH=<span class="hljs-string">&quot;amd64&quot;</span><br>$ <span class="hljs-built_in">cd</span> kubernetes/staging/src/k8s.io/sample-controller &amp;&amp; go build .<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装k8s的环境</span><br>$ kubelet --version<br>Kubernetes v1.27.2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># crd import</span><br>$ kubectl apply -f kubernetes/staging/src/k8s.io/sample-controller/artifacts/examples/crd.yaml<br>$ kubectl apply -f kubernetes/staging/src/k8s.io/sample-controller/artifacts/examples/example-foo.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动控制器查看CRD监听事件</span><br>$ ./sample-controller  --kubeconfig=/root/.kube/config<br></code></pre></td></tr></table></figure><h3 id="二、客户端注册实现监听机制"><a href="#二、客户端注册实现监听机制" class="headerlink" title="二、客户端注册实现监听机制"></a>二、客户端注册实现监听机制</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">// 注册clientset客户端</span><br><span class="hljs-comment">// 用于生成informer启动</span><br>informers.NewSharedInformerFactory(clientset.NewForConfig(cfg)).Start(ctx)<br><br><span class="hljs-comment">// clientset注入控制器后启动</span><br>Controller.run()<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li>List-watch设计</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. List-watch : List:http短连接；watch:http长连接；<br>2. Informer:<br>        Informer是Client-go中的一个核心工具包<br>        Informer实例中的Lister()方法（该方法包含 了 Get 和 List 方法） -- 可用于List/Get Kubernetes中的Object<br>        很少会直接请求k8s的API进行 List Get资源<br>3. Informer设计：<br>        依赖Kubernetes List/Watch API<br>        可监听事件并触发回调函数的二级缓存工具包<br>        Informer只会调用Kubernetes List和Watch两种类型的API<br>        List/Get Kubernetes中的Object，Informer不会去请求Kubernetes API，而是查找缓存在本地内存中的数据<br>        Informer完全依赖Watch API去维护缓存，没有任何resync机制<br>        Informer通过Kubernetes Watch API监听某种resource下的所有事件<br>4. Informer回调实现：ResourceEventHandler实例；OnAdd(obj interface&#123;&#125;)、OnUpdate(oldObj, newObj interface&#123;&#125;)、OnDelete(obj interface&#123;&#125;)<br>5. Informer缓存： 二级缓存 、DeltaFIFO、LocalStore<br>6. Informaer: Reflect: ListerWatcher的Even丢给Reflector处理、Reflector处理后以Delta结果转入Delta_fifo<br>7. Indexer: 索引器、加速数据的检索<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/kubernetes/kubernetes/tree/v1.27.2">https://github.com/kubernetes/kubernetes/tree/v1.27.2</a><br><a href="https://zhuanlan.zhihu.com/p/59660536">知乎&#x2F;理解 K8S 的设计精髓之 List-Watch机制和Informer模块</a><br><a href="https://blog.csdn.net/ChrisYoung95/article/details/111598273">CSDN&#x2F;理解K8S-Informer机制</a><br><a href="https://zhuanlan.zhihu.com/p/416371779">知乎&#x2F;k8s之informer设计</a><br><a href="https://github.com/kubernetes/code-generator">https://github.com/kubernetes/code-generator</a><br><a href="https://juejin.cn/post/7096484178128011277">code-generator简单介绍 - 写的挺好</a><br><a href="https://herbguo.gitbook.io/client-go/">https://herbguo.gitbook.io/client-go/</a><br><a href="https://github.com/kubernetes/client-go">https://github.com/kubernetes/client-go 写的非常非常好</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>code gender</title>
    <link href="/2023/04/23/kubernetes/code-gender/"/>
    <url>/2023/04/23/kubernetes/code-gender/</url>
    
    <content type="html"><![CDATA[<h3 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h3><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><p><a href="https://github.com/kubernetes/code-generator">github&#x2F;code-generator</a><br><a href="https://juejin.cn/post/7096484178128011277">code-generator简单介绍</a><br><a href="https://github.com/kubernetes/sample-controller">kubernetes&#x2F;sample-controller</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes容器安全</title>
    <link href="/2023/04/23/kubernetes/%20kubernetes%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/"/>
    <url>/2023/04/23/kubernetes/%20kubernetes%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="课题"><a href="#课题" class="headerlink" title="课题"></a>课题</h3><ul><li>容器在k8s是什么</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">轻量级的虚拟化技术，可以打包应用程序及其依赖项，使其更易于部署和管理<br>k8s支持多种容器运行时（Container Runtime），包括Docker、containerd、CRI-O等<br></code></pre></td></tr></table></figure><ul><li>容器运行时Container Runtime是什么意思</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">一种软件，其主要任务是负责在操作系统上启动和管理容器<br>容器运行时通常通过调用操作系统提供的系统调用 - 来创建和管理容器<br>一般和容器编排工具（例如Kubernetes）协同工作，实现容器的自动化部署、扩缩容等<br>常见容器运行时有：Docker容器引擎、rkt、containerd等<br></code></pre></td></tr></table></figure><ul><li>Kubernetes中的容器可能会有哪些安全风险</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 容器之间共享主机系统的资源,可能会通过共享文件或进程来获取其他容器中的敏感信息<br>2. 容器的容量限制不够严格<br>3. 容器镜像来源不可信<br>4. 容器网络安全风险,比如需要访问外部网络或者其他容器<br>5. 容器数据持久化缺少加密<br>6. Kubernetes容器默认以高权限运行，容器内进程的文件系统和主机文件系统是共享的<br></code></pre></td></tr></table></figure><ul><li><p>模拟docker的容器A非法访问容器B的资源</p></li><li><p>NetworkNamespace是在Linux内核中实现的一种机制，用于隔离网络资源，例如网络接口、路由表和iptables规则等</p></li><li><p>kata是什么</p></li><li><p>容器逻辑上分割，物理上的资源区隔的设计是什么样的</p></li><li><p>kubernetes的安全策略，如容器隔离、网络策略、RBAC设计是什么样的</p></li><li><p>iSula是什么</p></li><li><p>iSula+StratoVirt安全容器是什么</p></li><li><p>在容器执行top命令看到宿主机进程，为什么</p></li><li><p>containerd和docker什么关系，有架构图吗</p></li><li><p>runc、cri、运行时是什么</p></li><li><p>容器网络安全是怎么样的</p></li><li><p>k8s的设计的架构图</p></li><li><p>docker架构图</p></li><li><p>Istios是第二代Service Mesh的代表</p></li><li><p>Service Mesh服务网格是一种用于解决微服务架构中服务之间通信的问题的技术</p></li><li><p>namespace和cgroups标准是什么</p></li><li><p>OCI(Open Container Initiative)(开放容器计划)是什么涉及哪些内容</p></li><li><p>Kubernetes的CRI(Container Runtime Interface)的容器运行时接口是什么意思</p></li><li><p>shim的设计:作为适配器将自身容器运行时接口适配到 Kubernetes 的 CRI 接口(dockershim就是Kubernetes对接Docker到CRI接口)</p></li><li><p>CGroup是Control Groups限制\记录\隔离进程组所使用的物理资源</p></li><li><p>Name Space是什么</p></li><li><p>Busy Box是什么</p></li><li><p>k3s是什么</p></li><li><p>Kernel是什么</p></li><li><p>如何添加并使用docker的runtime和查看当前docker支持的runtime</p></li><li><p>docker使用kata runtime 抛出异常 cannot program address in sandbox interface because it conflicts with existing route</p></li><li><p>Qemu是什么</p></li><li><p>KVM是什么</p></li><li><p>KVM 要求 CPU 支持虚拟化扩展，例如 Intel VT 或 AMD-V。如果您的 CPU 不支持这些扩展，则无法使用 KVM</p></li><li><p>Kata Containers如何配置使用QEMU</p></li><li><p>Kata Runtime使用Firecracker</p></li><li><p>QEMU path (&#x2F;usr&#x2F;bin&#x2F;qemu-kvm) does not exist</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install -y qemu<br></code></pre></td></tr></table></figure></li><li><p>Fedora 和 Centos 和 ky10.aarch64是什么关系</p></li><li><p>modprobe是干嘛的</p></li><li><p>docker run –runtime kata-runtime &amp;&amp; Could not access KVM kernel module</p></li><li><p>怎么判断cpu是否支持KVM</p></li><li><p>linux的命名空间是什么</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">命名空间是Linux内核中的一个概念，它可以将不同的系统资源隔离开来，比如网络、进程空间等。<br>通过将容器连接到特定的网络命名空间中，可以实现容器与特定网络资源的隔离和互通<br></code></pre></td></tr></table></figure></li><li><p>kata-containerd 和 kvm 是什么关系</p></li><li><p>kata-containerd 可以不依赖kvm吗</p></li><li><p>使用docker时候用的runtime是kata-runtime 但是不想依赖kvm怎么实现</p></li><li><p>kata containerd 怎么运行需要什么条件</p></li><li><p>KataContainers和Docker如何集成</p></li><li><p>kvm_intel是干嘛的</p></li><li><p>如何判断当前aarch64支持ARM Hyp</p></li><li><p>kata runtime可以不需要kvm吗，怎么实现</p></li><li><p>x86_64, amd64Intel VT-x, AMD SVM 是什么意思</p></li><li><p>aarch64 (“arm64”)ARM Hyp 是什么意思</p></li><li><p>mac 怎么判断 arm64（aarch64）架构是否支持ARM Hypervisor</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 输出1表示支持虚拟化</span><br>$ sysctl kern.hv_support<br></code></pre></td></tr></table></figure><ul><li>kvm 和 ARM Hypervisor什么关系</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt">KVM和ARM Hypervisor都是虚拟化技术，用于在处理器上创建虚拟化环境。<br><br>KVM是用于x86架构的开源虚拟化解决方案，而ARM Hypervisor是用于ARM架构的虚拟化解决方案。<br><br>在ARM架构中，ARM Hypervisor被用于虚拟化环境和资源，它允许多个操作系统同时运行在单个ARM处理器上，每个操作系统都在自己的虚拟机中运行。<br>ARM Hypervisor通过使用虚拟地址空间映射等技术来隔离不同的虚拟机之间的资源，从而保证每个虚拟机的安全性和独立性。<br><br>与此类似，KVM也是一种虚拟化解决方案，它可以在x86架构的处理器上运行多个虚拟机，并将物理资源映射到虚拟机中。<br>KVM通过模拟多种硬件设备，如网络适配器和存储控制器等，为虚拟机提供与物理主机相同的环境，从而保证虚拟机的稳定性和性能。<br><br>总之，KVM和ARM Hypervisor都是虚拟化技术，它们可以在不同的架构上将物理主机资源虚拟化为多个虚拟机，并支持多个操作系统同时运行。<br>相比于x86架构，ARM Hypervisor在ARM架构上提供了更高效和安全的虚拟化环境。<br></code></pre></td></tr></table></figure><ul><li>kvm 和 Intel VT-x, AMD SVM是什么关系</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">Intel VT-x和AMD SVM是虚拟化技术的硬件支持，可以使操作系统在虚拟机中以更高效率的方式运行。<br>kvm是一种基于虚拟化技术的虚拟机监视器，可以在支持Intel VT-x或AMD SVM的处理器上运行。<br>kvm通过硬件虚拟化技术实现虚拟化，提供更高效的虚拟化性能。<br><br>因此，Intel VT-x和AMD SVM是支持kvm运行的基础。<br></code></pre></td></tr></table></figure><ul><li>虚拟化研究中KVM和QEMU的区别</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt"><br>QEMU（Quick Emulator）是一个独立的开源虚拟机软件，纯软件的实现（处理器虚拟化、内存虚拟、虚拟设备模拟）<br><br>Qemu利用KVM提供的LibKvm应用程序接口，通过ioctl系统调用创建和运行虚拟机<br><br>QEMU在上层，KVM在下层<br><br>KVM(Kernel-based Virtual Machine)是基于虚拟化扩展（Intel VT或AMD-V）的X86硬件平台实现的Linux的全虚拟化解决方案<br><br>KVM是x86的东西<br></code></pre></td></tr></table></figure><ul><li>网桥是什么</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">网络设备，连接多个网络。<br>转发不同网络之中的数据流。<br>工作在OSI模型的第二层：数据链路层<br>通过物理地址（MAC地址）识别网络设备来传递数据包<br></code></pre></td></tr></table></figure><ul><li>网段是什么</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">网络地址范围 (表示方式：IP地址和子网掩码)；<br>同一网段的设备可互相通信<br>不同网段需要路由器等设备才可痛心<br></code></pre></td></tr></table></figure><ul><li><p>rootfs是什么</p></li><li><p>Guest Kernel是什么</p></li><li><p>Virtio是什么</p></li><li><p>阿里巴巴的ACK是什么意思</p></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">阿里的ACK的全称是Alibaba Cloud ACK（Alibaba Cloud Container Service for Kubernetes）。<br></code></pre></td></tr></table></figure><h3 id="课题方向"><a href="#课题方向" class="headerlink" title="课题方向"></a>课题方向</h3><ol><li>容器哪里不安全了</li><li>目前的解决方案是什么样的</li><li>解决方案的使用怎样可达到更好的效果</li><li>一些常见的兼容性、性能测试覆盖一下</li></ol><blockquote><p>Containerd 实现了 Kubernetes 容器运行时接口 (CRI)<br>BuildKit 是一种开源工具，它从 Dockerfile 获取指令并“构建”Docker 映像<br>OCI (Open Container Initiative) 开放容器计划（容器规范的开放标准）<br>CRI (Container Runtime Interface) 容器运行时接口，定义了 Kubernetes 与容器运行时之间的接口和协议<br>CRI-O 是实现了CRI和OCI，实现 OCI 和 CRI，等于是containerd</p></blockquote><h3 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h3><p><img src="/images/%E4%BB%80%E4%B9%88%E6%98%AFk8s%E7%9A%84CRI-O.png" alt="什么是k8s的CRI-O"><br><img src="/images/%E6%97%A9%E6%9C%9F%E7%9A%84k8s%E4%B8%8Edocker.png" alt="早期的k8s与docker"><br><img src="/images/containerd%E9%9B%86%E6%88%90cri-containerd-shim%E5%90%8E%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="containerd集成cri-containerd-shim后架构图"><br><img src="/images/docker%E5%92%8Ccontainerd%E5%85%B3%E7%B3%BB.png" alt="docker和containerd关系"><br><img src="/images/docker%E4%BE%9D%E8%B5%96k8s%E6%A0%87%E5%87%86.png" alt="docker依赖k8s标准"><br><img src="/images/k8s-v1.20-24%E5%88%86%E7%A6%BBdocker-shim.png" alt="k8s-v1.20-24分离docker-shim"><br><img src="/images/k8s-v1.20%E4%B9%8B%E5%89%8D%E5%86%85%E7%BD%AEdocker-shim.png" alt="k8s-v1.20之前内置docker-shim"><br><img src="/images/k8s-v1.24%E4%B9%8B%E5%90%8E%E8%87%AA%E8%A1%8C%E5%AE%89%E8%A3%85cri-dockerd.png" alt="k8s-v1.24之后自行安装cri-dockerd"><br><img src="/images/k8s%E5%88%86%E7%A6%BBdocker-shim.png" alt="k8s分离docker-shim"><br><img src="/images/k8s%E4%B8%8Edocker%E5%88%86%E7%A6%BB%E7%9A%84%E5%88%9D%E6%AD%A5%E8%AE%A1%E5%88%92.png" alt="k8s与docker分离的初步计划"><br><img src="/images/kubelet%E5%92%8Ccontainerd%E7%AE%80%E5%8C%96%E8%B0%83%E7%94%A8%E9%93%BE%E8%BF%87%E7%A8%8B.png" alt="kubelet和containerd简化调用链过程"><br><img src="/images/kubelet%E4%B8%8E%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6.png" alt="kubelet与容器运行时"><br><img src="/images/k8s%E5%88%86%E7%A6%BBdocker-shim.png" alt="kubelet与cri内部结构"></p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md">github.com&#x2F;containerd</a><br><a href="https://zhuanlan.zhihu.com/p/61901608">zhihu&#x2F;什么是 Service Mesh</a><br><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html">PhilCalcado&#x2F;Pattern: Service Mesh</a><br><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/">官网运行时container-runtimes</a><br><a href="https://blog.csdn.net/m0_57776598/article/details/126963904">csdn剖析容器docker运行时-说的太细致了</a><br><a href="https://blog.csdn.net/yangyijun1990/article/details/108694011">csdn之IaaS&#x2F;PaaS&#x2F;SaaS&#x2F;DaaS的区别-说的太好了</a><br><a href="https://zhuanlan.zhihu.com/p/279747954">知乎&#x2F;container之runc</a><br><a href="https://zhuanlan.zhihu.com/p/122247284">从零开始入门 K8s | Kata Containers 创始人带你入门安全容器技术</a><br><a href="https://cloud.tencent.com/developer/article/1730700">如何在 Kubernetes 集群中集成 Kata</a><br><a href="https://www.dtstack.com/bbs/article/258">Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了 - 写的太好了</a><br><a href="https://www.huweihuang.com/kubernetes-notes/runtime/kata/kata-container.html">huweihuang&#x2F;Kata-container简介</a><br><a href="https://blog.51cto.com/u_11979904/5676073">kata-containd和docker集成</a><br><a href="https://blog.51cto.com/u_11979904/5676073">如何给docker添加runtime支持</a><br><a href="https://www.cnblogs.com/fanqisoft/p/12096904.html">博客园-KataContainers和Docker的集成</a><br><a href="https://www.qemu.org/">https://www.qemu.org/</a><br><a href="https://github.com/kata-containers/runtime/issues/935">sandbox interface because it conflicts with existing route</a><br><a href="https://www.scholat.com/vpost.html?pid=7294">虚拟化研究中KVM和QEMU的区别-这个图画的很哇塞哦</a><br><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md">k8s官方讲解有多少种CRI</a><br><a href="https://blog.51cto.com/u_15682248/5806851">非常细致描述kata的优势</a></p><h3 id="gVisor和Kata-Containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点："><a href="#gVisor和Kata-Containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点：" class="headerlink" title="gVisor和Kata Containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点："></a>gVisor和Kata Containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点：</h3><h4 id="gVisor的优点："><a href="#gVisor的优点：" class="headerlink" title="gVisor的优点："></a>gVisor的优点：</h4><ul><li>gVisor 使用了一个特殊的沙箱机制，可以提供更高的隔离性和安全性。</li><li>gVisor可以在Linux容器内运行，而无需对宿主机进行特殊设置。</li><li>gVisor的性能比Kata Containers更快。</li></ul><h4 id="gVisor的缺点："><a href="#gVisor的缺点：" class="headerlink" title="gVisor的缺点："></a>gVisor的缺点：</h4><ul><li>gVisor还是一个比较新的项目，尚未被广泛测试和采用。</li><li>gVisor需要的内存和CPU资源比Kata Containers更多。</li><li>系统调用频繁的情况下gvisor的性能差</li></ul><h4 id="Kata-Containers的优点："><a href="#Kata-Containers的优点：" class="headerlink" title="Kata Containers的优点："></a>Kata Containers的优点：</h4><ul><li>Kata Containers运行在轻量级虚拟机中，可以提供与传统虚拟机相似的隔离性和安全性。</li><li>Kata Containers基于OCI标准，可以无缝地与Docker等容器工具集成。</li><li>Kata Containers比gVisor更易于部署和使用。</li><li>Kata Containers的启动时间通常在几百毫秒到一秒左右。</li></ul><h4 id="Kata-Containers的缺点："><a href="#Kata-Containers的缺点：" class="headerlink" title="Kata Containers的缺点："></a>Kata Containers的缺点：</h4><ul><li>Kata Containers的启动速度比gVisor慢（但kata速度仍然非常快，通常在毫秒级别），因为它需要启动轻量级虚拟机。</li><li>由于使用了轻量级虚拟机，Kata Containers的性能比gVisor略低。</li></ul><p>需要注意的是，以上优缺点只是大概的总结，实际的情况可能会因特定的使用场景和需求而发生变化。</p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes架构设计</title>
    <link href="/2023/04/23/kubernetes/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/23/kubernetes/kubernetes%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/high-OCI.png" alt="高级容器运行时"></p><p><img src="/images/docker-oci.png" alt="docker-oci"></p><p><img src="/images/cri-plane.png" alt="docker cri与控制平面"></p><ul><li>拉取镜像 ImageService.PullImage</li><li>运行容器 RuntimeService.RunPodSandbox</li><li>创建容器 RuntimeService.CreateContainer</li><li>启动容器 RuntimeService.StartContainer</li><li>停止容器 RuntimeService.StopContainer</li></ul><p><img src="/images/containerd%E5%8F%91%E5%B1%95%E5%8F%B2.png" alt="containerd发展史"></p><p><img src="/images/kubernetes_diagram-cluster.svg" alt="kubernetes_diagram-cluster红帽"></p><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="https://www.modb.pro/db/407926">高级容器运行时</a><br><a href="https://www.redhat.com/zh/topics/containers/kubernetes-architecture">rehat-k8s的架构设计</a><br><a href="https://www.kubernetes.org.cn/kubernetes%e8%ae%be%e8%ae%a1%e6%9e%b6%e6%9e%84">k8s中文社区-k8s的架构设计</a><br><a href="https://www.kubernetes.org.cn/kubernetes%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5">k8s中文社区-k8s的设计理念</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>containerd和kata&amp;firecracker环境搭建</title>
    <link href="/2023/04/23/kubernetes/containerd%E5%92%8Ckata&amp;firecracker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/04/23/kubernetes/containerd%E5%92%8Ckata&amp;firecracker%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境"><a href="#一、环境" class="headerlink" title="一、环境"></a>一、环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-4-centos ~]<span class="hljs-comment"># uname -a</span><br>Linux x86_64 GNU/Linux<br><br><span class="hljs-comment"># 需要支持虚拟化：有输出表示支持</span><br>$ egrep <span class="hljs-string">&#x27;(vmx|svm)&#x27;</span> /proc/cpuinfo |<span class="hljs-built_in">wc</span> -l<br><br><span class="hljs-comment"># 需要安装kvm</span><br>$ lsmod | grep kvm<br><span class="hljs-comment"># kvm_intel  376832  11</span><br><span class="hljs-comment"># kvm  1015808  1 kvm_intel</span><br><br><span class="hljs-comment"># dev设备</span><br>$ ll /dev/kvm<br></code></pre></td></tr></table></figure><h3 id="二、安装包"><a href="#二、安装包" class="headerlink" title="二、安装包"></a>二、安装包</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">kata-static-3.0.2-x86_64.tar.xz<br></code></pre></td></tr></table></figure><h3 id="三、文档地址"><a href="#三、文档地址" class="headerlink" title="三、文档地址"></a>三、文档地址</h3><ul><li><a href="https://github.com/kata-containers/kata-containers/blob/3.0.2/docs/how-to/containerd-kata.md">kata-containers&#x2F;3.0.2-如何与containerd集成</a></li><li><a href="https://github.com/containerd/containerd/blob/v1.7.0/docs/snapshotters/devmapper.md">containerd-v1.7.0安装snapshotters.devmapper</a></li><li><a href="https://github.com/kata-containers/kata-containers/releases/tag/3.0.2">kata-containerd&#x2F;v3.0.2</a></li><li><a href="https://github.com/kata-containers/kata-containers/blob/main/docs/install/container-manager/containerd/containerd-install.md">kata-container和containerd安装</a></li></ul><h3 id="四、安装kata-containers"><a href="#四、安装kata-containers" class="headerlink" title="四、安装kata-containers"></a>四、安装kata-containers</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载安装包</span><br>$ /home/kata-static-3.0.2-x86_64.tar.xz<br><br><span class="hljs-comment"># 解压至根目录</span><br>$ tar -xvf  kata-static-3.0.2-x86_64.tar.xz -C /<br><br><span class="hljs-comment"># 验证可用</span><br>$ kata-runtime check --no-network-checks<br>$ kata-runtime --show-default-config-paths<br>$ kata-runtime kata-env<br></code></pre></td></tr></table></figure><h3 id="五、配置containerd"><a href="#五、配置containerd" class="headerlink" title="五、配置containerd"></a>五、配置containerd</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml">[<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.kata</span>]<br>  <span class="hljs-string">runtime_type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;io.containerd.kata.v2&quot;</span><br>  <span class="hljs-string">privileged_without_host_devices</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span><br>  <span class="hljs-string">pod_annotations</span> <span class="hljs-string">=</span> [<span class="hljs-string">&quot;io.katacontainers.*&quot;</span>]<br>  <span class="hljs-string">container_annotations</span> <span class="hljs-string">=</span> [<span class="hljs-string">&quot;io.katacontainers.*&quot;</span>]<br>  [<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.kata.options</span>]<br>    <span class="hljs-string">ConfigPath</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;/opt/kata/share/defaults/kata-containers/configuration.toml&quot;</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/kata-containers/kata-containers/blob/main/docs/how-to/containerd-kata.md#kata-containers-as-a-runtimeclass">containerd.plugins.cri.runtimes.kata配置说明</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重启containerd服务</span><br>$ systemctl daemon-reload<br>$ systemctl start containerd <br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ containerd config dump | grep kata<br></code></pre></td></tr></table></figure><h3 id="六、运行容器"><a href="#六、运行容器" class="headerlink" title="六、运行容器"></a>六、运行容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo ctr image pull docker.io/library/busybox:latest<br>$ sudo ctr run --runtime <span class="hljs-string">&quot;io.containerd.kata.v2&quot;</span> --<span class="hljs-built_in">rm</span> -t docker.io/library/busybox:latest test-kata <span class="hljs-built_in">uname</span> -r<br></code></pre></td></tr></table></figure><h3 id="七、使用firecracker创建容器"><a href="#七、使用firecracker创建容器" class="headerlink" title="七、使用firecracker创建容器"></a>七、使用firecracker创建容器</h3><p><a href="https://github.com/kata-containers/kata-containers/blob/3.0.2/docs/how-to/how-to-use-kata-containers-with-firecracker.md">how-to-use-kata-containers-with-firecracker</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># devmapper非常重要</span><br><span class="hljs-comment"># devmapper非常重要</span><br>$ sudo ctr plugins <span class="hljs-built_in">ls</span> | grep devmapper<br><br><span class="hljs-comment"># 创建符号连接否则containerd找不到kata</span><br>$ sudo <span class="hljs-built_in">ln</span> -s /home/opt/kata/bin/containerd-shim-kata-v2 /usr/bin/containerd-shim-kata-v2<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建kata-fc</span><br>$ <span class="hljs-built_in">touch</span> /usr/local/bin/containerd-shim-kata-fc-v2<br><br>$ <span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF &gt; /usr/local/bin/containerd-shim-kata-fc-v2</span><br><span class="hljs-string">#!/bin/bash</span><br><span class="hljs-string">KATA_CONF_FILE=/opt/kata/share/defaults/kata-containers/configuration-fc.toml /opt/kata/bin/containerd-shim-kata-v2 $@</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># containerd.plugin.devmapper需要安装</span><br>$ ctr images pull --snapshotter devmapper docker.io/library/ubuntu:latest<br>$ ctr run --snapshotter devmapper --runtime io.containerd.run.kata-fc.v2 -t --<span class="hljs-built_in">rm</span> docker.io/library/ubuntu:latest test-kata-fc<br>$ ctr run --snapshotter devmapper --runtime io.containerd.run.kata.v2 -t --<span class="hljs-built_in">rm</span> docker.io/library/ubuntu:latest test-kata-qemu<br>$ ctr run --snapshotter devmapper --runtime io.containerd.run.runc.v2 -t --<span class="hljs-built_in">rm</span> docker.io/library/ubuntu:latest test-kata-runc<br><br><span class="hljs-comment"># [root ~]# ctr c ls</span><br><span class="hljs-comment"># CONTAINER         IMAGE                              RUNTIME                         </span><br><span class="hljs-comment"># test-kata-fc      docker.io/library/ubuntu:latest    io.containerd.run.kata-fc.v2    </span><br><span class="hljs-comment"># test-kata-qemu    docker.io/library/ubuntu:latest    io.containerd.run.kata.v2  </span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 宿主机上查看进程</span><br>$ ps -ef | grep test-kata-fc<br>$ ps -ef | grep test-kata-qemu<br></code></pre></td></tr></table></figure><h3 id="八、比较qemu和firecracker的性能"><a href="#八、比较qemu和firecracker的性能" class="headerlink" title="八、比较qemu和firecracker的性能"></a>八、比较qemu和firecracker的性能</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ps -ef<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li>kata-rc怎么和containerd集成</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">kata runtime独立仓库(v1.5) 之前出的一个兼容fc的脚本<br>新版本3.0需要了<br></code></pre></td></tr></table></figure><ul><li>kata-runtime和kata-containerd什么关系</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">kata-container 包含 kata-runtime<br></code></pre></td></tr></table></figure><ul><li><p>containerd怎么集成kata-rc</p></li><li><p>containerd怎么安装扩展plugins.devmapper</p></li><li><p>containerd刚刚安装的时候没有配置文件怎么生成</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ containerd config default &gt; /etc/containerd/config.toml<br></code></pre></td></tr></table></figure><ul><li><p>kata-runtime刚刚生成没有配置文件怎么处理</p></li><li><p>containerd 怎么添加扩展</p></li><li><p>containerd的devmapper是什么来的</p></li><li><p>CNI怎么安装，etc&#x2F;cni&#x2F;net.d&#x2F;这个文件夹下面的配置是怎么填写的</p></li><li><p>rootfs not found</p></li></ul><p><a href="https://github.com/kata-containers/kata-containers/issues/6784">https://github.com/kata-containers/kata-containers/issues/6784</a></p><ul><li>kata container amd64下载</li></ul><p><a href="https://github.com/kata-containers/kata-containers/issues/6776">https://github.com/kata-containers/kata-containers/issues/6776</a></p><ul><li>containerd.plugin.snapshotter的devmapper是什么</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">containerd.plugin.snapshotter的devmapper是一个存储驱动程序，它使用devmapper技术在宿主机上创建镜像和容器快照。<br>它允许容器在宿主机上使用基于写时复制（Copy-on-Write）的快照技术，以减少磁盘空间和I/O使用。<br>devmapper是Docker默认使用的存储驱动程序之一，也可以在containerd中使用。<br></code></pre></td></tr></table></figure><ul><li>snapshotter是什么</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">在Containerd中，snapshotter是一个用于管理和创建容器根文件系统（rootfs）以及容器快照的组件。<br>当容器创建时，snapshotter会根据指定的镜像，创建一个只读的rootfs，并在其上添加一个可写层，以允许容器进行修改。<br>snapshotter还负责为容器创建快照，这可以提供可恢复性和备份能力。<br>Containerd支持多个snapshotter驱动程序，如devmapper、overlayfs和btrfs等，以满足不同的需求和环境。<br></code></pre></td></tr></table></figure><ul><li>ctr对容器的操作</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 停止所有容器</span><br>$ ctr tasks <span class="hljs-built_in">kill</span> -a -s 9 container_id<br><br><span class="hljs-comment"># 删除容器</span><br>$ ctr c <span class="hljs-built_in">rm</span> $(ctr c list -q)<br></code></pre></td></tr></table></figure><ul><li>yum</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>os-release<br>cd <span class="hljs-regexp">/etc/yum</span>.repos.d/<br></code></pre></td></tr></table></figure><ul><li>Fedora RedHat Ubuntu CentOS Debian之间的区别和联系是什么<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">Fedora、RedHat、Ubuntu、CentOS和Debian都是常见的Linux发行版，它们之间有以下区别和联系：<br><br>1. Fedora是由Red Hat公司赞助的社区开发的Linux发行版，Red Hat则是一家提供商业Linux产品的公司。CentOS是基于Red Hat Enterprise Linux (RHEL)源代码的开源发行版，而Ubuntu和Debian是完全独立的发行版。<br><br>2. Fedora、RedHat和CentOS都使用RPM软件包管理系统，而Ubuntu和Debian使用DEB软件包管理系统。<br><br>3. Fedora和Ubuntu都是面向桌面和开发者的发行版，而RedHat和CentOS主要面向企业服务器市场，而Debian则更多用于开发者和服务器上。<br><br>4. Fedora和Ubuntu都有免费版和商业版，而RedHat和CentOS则主要提供商业版。<br><br>5. Fedora和Ubuntu更新频繁，每6个月发布一次新版本，而RedHat和CentOS更新周期较长，通常每2-3年发布一次新版本，Debian则更新周期更为稳定。<br><br>但它们都是基于Linux内核的操作系统。<br></code></pre></td></tr></table></figure></li><li>Fedora RedHat Ubuntu CentOS Debian 关系图</li><li>linux分区操作</li><li>ubuntu 安装yum 可以吗</li><li>Linux两大系列debian和redhat</li><li>yum repolist all干嘛的</li></ul><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://github.com/kata-containers/documentation/wiki/Initial-release-of-Kata-Containers-with-Firecracker-support">kata-firecracker和docker的集成</a><br><a href="https://github.com/kata-containers/kata-containers/blob/3.0.2/docs/how-to/run-kata-with-crictl.md">kata-containers&#x2F;3.0.2&#x2F;crictl创建容器</a><br><a href="https://blog.csdn.net/m0_70885101/article/details/127271416">ubuntu安装使用yum-更新yumde软件源地址即可</a><br><a href="https://mirrors.tuna.tsinghua.edu.cn/">清华大学开源软件镜像站</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识CRD</title>
    <link href="/2023/04/23/kubernetes/%E5%88%9D%E8%AF%86CRD/"/>
    <url>/2023/04/23/kubernetes/%E5%88%9D%E8%AF%86CRD/</url>
    
    <content type="html"><![CDATA[<h3 id="quick-start"><a href="#quick-start" class="headerlink" title="quick start"></a>quick start</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> resourcedefinition.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apiextensions.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CustomResourceDefinition</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-comment"># 名字必需与下面的 spec 字段匹配，并且格式为 &#x27;&lt;名称的复数形式&gt;.&lt;组名&gt;&#x27;</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">crontabs.stable.example.com</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-comment"># 组名称，用于 REST API: /apis/&lt;组&gt;/&lt;版本&gt;</span><br>  <span class="hljs-attr">group:</span> <span class="hljs-string">stable.example.com</span><br>  <span class="hljs-comment"># 列举此 CustomResourceDefinition 所支持的版本</span><br>  <span class="hljs-attr">versions:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">v1</span><br>      <span class="hljs-comment"># 每个版本都可以通过 served 标志来独立启用或禁止</span><br>      <span class="hljs-attr">served:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 其中一个且只有一个版本必需被标记为存储版本</span><br>      <span class="hljs-attr">storage:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-attr">schema:</span><br>        <span class="hljs-attr">openAPIV3Schema:</span><br>          <span class="hljs-attr">type:</span> <span class="hljs-string">object</span><br>          <span class="hljs-attr">properties:</span><br>            <span class="hljs-attr">spec:</span><br>              <span class="hljs-attr">type:</span> <span class="hljs-string">object</span><br>              <span class="hljs-attr">properties:</span><br>                <span class="hljs-attr">cronSpec:</span><br>                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>                <span class="hljs-attr">image:</span><br>                  <span class="hljs-attr">type:</span> <span class="hljs-string">string</span><br>                <span class="hljs-attr">replicas:</span><br>                  <span class="hljs-attr">type:</span> <span class="hljs-string">integer</span><br>  <span class="hljs-comment"># 可以是 Namespaced 或 Cluster</span><br>  <span class="hljs-attr">scope:</span> <span class="hljs-string">Namespaced</span><br>  <span class="hljs-attr">names:</span><br>    <span class="hljs-comment"># 名称的复数形式，用于 URL：/apis/&lt;组&gt;/&lt;版本&gt;/&lt;名称的复数形式&gt;</span><br>    <span class="hljs-attr">plural:</span> <span class="hljs-string">crontabs</span><br>    <span class="hljs-comment"># 名称的单数形式，作为命令行使用时和显示时的别名</span><br>    <span class="hljs-attr">singular:</span> <span class="hljs-string">crontab</span><br>    <span class="hljs-comment"># kind 通常是单数形式的驼峰命名（CamelCased）形式。你的资源清单会使用这一形式。</span><br>    <span class="hljs-attr">kind:</span> <span class="hljs-string">CronTab</span><br>    <span class="hljs-comment"># shortNames 允许你在命令行使用较短的字符串来匹配资源</span><br>    <span class="hljs-attr">shortNames:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">ct</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 一个名为 crontab 的 API 对象，可在 Kubernetes API 中进行 CRUD（创建、读取、更新和删除）操作</span><br><span class="hljs-comment"># &quot;/apis/stable.example.com/v1/namespaces/*/crontabs/...&quot; 是一个 RESTful API 端点的路径</span><br><span class="hljs-comment"># 表示在 Kubernetes 集群中创建一个名为 &quot;crontabs&quot; 的资源，该资源位于所有 Kubernetes 命名空间中</span><br>$ kubectl apply -f resourcedefinition.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get CronTab<br>$ kubectl get ct<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> my-crontab.yaml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 创建定制对象</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">&quot;stable.example.com/v1&quot;</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronTab</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">my-new-cron-object</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">cronSpec:</span> <span class="hljs-string">&quot;* * * * */5&quot;</span><br>  <span class="hljs-attr">image:</span> <span class="hljs-string">my-awesome-cron-image</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl apply -f my-crontab.yaml<br>$ kubectl get crontab<br>$ kubectl get ct -o yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除CRD CronTab</span><br>$ kubectl delete -f resourcedefinition.yaml<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/api-extension/custom-resources/">Kubernetes文档&#x2F;概念&#x2F;扩展Kubernetes&#x2F;扩展KubernetesAPI&#x2F;定制资源</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/">Kubernetes文档&#x2F;使用CustomResourceDefinition扩展KubernetesAPI</a></p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li><p>k8s的spec.scope干嘛的<br> Kubernetes中的spec.scope用于指定资源对象的范围，例如Pod的范围可以是cluster（集群级别）或namespace（命名空间级别）。这个参数通常用于为用户控制资源对象的访问范围，以确保安全性和隔离性。<br> 如果spec.scope设置为namespace，则只能在同一命名空间中访问该资源对象。如果设置为cluster，则可以在整个集群中访问该资源对象。</p></li><li><p>k8s的metadata是干嘛的<br>  Kubernetes (k8s) 的 metadata 是为了给 Kubernetes 对象提供元数据，即对象的描述信息。其中包括：</p><ol><li>名称 (name)：对象的名称。</li><li>命名空间 (namespace)：对象所处的命名空间。</li><li>标签 (labels)：用于标识和分类对象。</li><li>注释 (annotations)：提供额外的对象描述信息，用于描述对象的详细信息。<br>  这些元数据信息在 Kubernetes 中非常重要，可以被用于对象的管理、监视、访问控制和自动化操作等方面。例如，使用标签 (labels) 可以轻松地对多个对象进行批量管理或筛选，并使用注释 (annotations) 来记录对象的详细信息，便于后续跟踪和管理。</li></ol></li><li><p>k8s的spec是什么<br>  在 Kubernetes（k8s）中，<code>spec</code> 是指 Kubernetes 对象中的“规格”或“规范”（specification）。它描述了 Kubernetes 对象的所需状态和属性。<code>spec</code> 是 Kubernetes 对象的一部分，包括 Kubernetes 中的各种对象，如 Pod，Deployment，Service，Namespace 等等。<br>  <code>spec</code> 一般由用户提供，用于描述 Kubernetes 对象的期望状态。例如，对于一个 Deployment 对象，<code>spec</code> 可以指定所部署的容器镜像、容器数量、滚动更新策略等。而对于一个 Pod 对象，<code>spec</code> 可以指定容器镜像、容器的命令和参数、容器间的通信方式等。<br>  <code>spec</code> 是 Kubernetes 控制器的核心输入对象。Kubernetes 控制器根据 <code>spec</code> 中的规范，将 Kubernetes 对象的实际状态调整为用户期望的状态。如果实际状态与 <code>spec</code> 中规定的状态不匹配，则 Kubernetes 控制器会根据设定的策略进行自动修复，以达到用户期望的状态。<br>  总之，<code>spec</code> 提供了 Kubernetes 对象的期望状态和属性，是 Kubernetes 控制器自动管理和操作 Kubernetes 对象的关键输入。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安全容器解决方案</title>
    <link href="/2023/04/23/kubernetes/%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/04/23/kubernetes/%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="一、什么是安全容器"><a href="#一、什么是安全容器" class="headerlink" title="一、什么是安全容器"></a>一、什么是安全容器</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p>安全容器是一种为应用程序提供高度隔离和安全性的技术，它可以控制应用程序访问系统资源和数据的权限，并提供虚拟化，使应用程序能够在隔离的环境中运行。安全容器的概念最早是由 FreeBSD 操作系统的开发者 Jails 提出的，他们在 2000 年左右将这一概念引入 FreeBSD 操作系统。后来，Linux 容器技术发展起来后，安全容器概念也逐渐被引入其中。</p><h4 id="2-kubenertes"><a href="#2-kubenertes" class="headerlink" title="2.kubenertes"></a>2.kubenertes</h4><p>目前k8s或者docker底层容器，通常是依赖于runc，而runc的资源隔离方案底层是 Linux 容器技术。它利用 Linux 内核提供的一些隔离机制，如 namespace、cgroup、seccomp等。具体来说，namespace 用于隔离应用程序的进程空间、网络、文件系统等，cgroup 用于限制应用程序的资源使用，seccomp 用于限制应用程序对系统调用的访问。runc 利用这些机制，将应用程序运行在一个隔离的环境中，从而提高应用程序的安全性和可靠性。但在实际运行中，仍是由宿主机向容器直接提供网络、存储、计算等资源，然而容器的安全性可以概括为两点： a.不会对主机造成影响。b.不会对其他容器造成影响。Docker的不安全表现在共用内核问题、Namespace还不够完善。具体表现：</p><ol><li><p>资源未隔离</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 容器内部输出与宿主机一致</span><br>$ free -m <br><span class="hljs-comment"># 看到宿主机的进程</span><br>$ top<br><span class="hljs-comment"># /dev设备未隔离:容器内查看所有设备与宿主机一致</span><br>$ <span class="hljs-built_in">ls</span> /dev<br><span class="hljs-comment"># 如果runc容器没有隔离/sys</span><br><span class="hljs-comment"># 那么容器内的进程可以轻易地获取主机上的内核信息，如主机的CPU或者内存信息。</span><br><span class="hljs-comment"># 这意味着容器内的恶意进程可以利用这些信息来绕过安全控制，访问主机上的敏感资源或破坏主机的系统</span><br>$ <span class="hljs-built_in">ls</span> /sys<br><span class="hljs-comment"># /proc 未完全隔离</span><br><span class="hljs-comment"># runc 在默认情况下不隔离 /proc，这意味着容器中的进程可以看到宿主机上的进程</span><br>$ <span class="hljs-built_in">ls</span> /proc<br></code></pre></td></tr></table></figure></li><li><p>内核模块未隔离。</p></li><li><p>SELinux、time、syslog等所有现有Namespace之外的信息都未隔离。</p></li><li><p>Root用户未隔离（如果Root用户未隔离，容器中的进程可以通过提升权限来访问宿主机中的资源）</p></li><li><p>攻击案例</p></li></ol><ul><li>CVE-2019-5736 runC 漏洞，它能让普通用户身份运行的恶意程序渗透到宿主机，修改 runC 程序，在下次创建容器时就会调用被修改的 runC，借此，攻击者可以实现任何非法目的</li></ul><h3 id="二、集成安全容器有什么价值"><a href="#二、集成安全容器有什么价值" class="headerlink" title="二、集成安全容器有什么价值"></a>二、集成安全容器有什么价值</h3><ol><li>提升安全性：容器间完全隔离，容器内部无法访问其他容器内部资源。</li><li>提升稳定性：因为隔离的原因，容器只能影响到自身内部无法影响到其他容器以及宿主机；</li><li>更细粒度资源控制：安全容器可以提供更细粒度的资源控制，包括CPU、内存、网络等方面，从而更好地管理和控制容器的资源使用。</li><li>多租户安全保障。 云原生多租户场景下，安全容器可以防止恶意租户对 host 内核的直接攻击并大幅减少机器上其他租户的风险，从而让公有云服务变得更稳定</li></ol><h3 id="三、安全容器相关的技术有哪些"><a href="#三、安全容器相关的技术有哪些" class="headerlink" title="三、安全容器相关的技术有哪些"></a>三、安全容器相关的技术有哪些</h3><ol><li>gvisor Go编写的应用程序内核、虚拟机监控程序（virtual machine monitor）、内部Runsc替代runc集成到docker、用户态的内核；</li></ol><p><img src="/images/%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%99%9A%E6%8B%9F%E5%8C%96-%E6%80%A7%E8%83%BD%E6%B6%88%E8%80%97%E5%A4%A7%E5%AE%89%E5%85%A8%E6%80%A7%E9%AB%98.png" alt="机器级虚拟化-性能消耗大安全性高"></p><p><img src="/images/%E8%A7%84%E5%88%99%E7%BA%A7%E5%88%AB%E8%99%9A%E6%8B%9F%E5%8C%96.png" alt="规则级别虚拟化-类似runc"></p><p><img src="/images/gvisor%E7%9A%84%E8%99%9A%E6%8B%9F%E5%8C%96.png" alt="gvisor的虚拟化.png"></p><ol start="2"><li>firecracker 亚马逊AWS开源，依赖KVM，轻量级虚拟机管理器VMM，QEMU替代品，资源利用率更高，不支持所有设备类型；</li></ol><p><img src="/images/%E4%BB%80%E4%B9%88%E6%98%AFQEMU%E5%92%8Cfirecraker.jpeg" alt="什么是QEMU和firecraker"></p><p><img src="/images/Hypervisor%E6%98%AF%E4%BB%80%E4%B9%88.gif" alt="Hypervisor是什么"></p><p><img src="/images/hypervisor%E7%9A%84%E6%9E%84%E6%88%90.gif" alt="Hypervisor的结构"></p><ol start="3"><li>openeuler StratoVirt 开放原子开源基金会孵化及运营，是基于Linux内核的虚拟机（KVM）的开源轻量级虚拟化技术,轻量级的虚拟机管理器,企业级虚拟化VMM(Virtual Machine Monitor)</li></ol><p><img src="/images/StratoVirt-arch.jpg" alt="StratoVirt架构"></p><p><img src="/images/iSulad%E6%8E%A5%E5%85%A5%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8.png" alt="StratoVirt.iSulad接入安全容器"></p><ol start="4"><li>QEMU 模拟计算机硬件的开源软件,可用作虚拟机管理器，功能齐全，成熟完善，支持所有设备</li></ol><p><img src="/images/qemu-kvm%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="qemu-kvm架构图"></p><p><img src="/images/qemu-kvm%E7%BB%84%E4%BB%B6%E5%9B%BE.png" alt="qemu-kvm组件图"></p><ol start="5"><li>kata-containerd Intel开源项目合并,轻量级的容器运行时</li></ol><p><img src="/images/katacontainers_traditionalvskata_diagram.jpg" alt="katacontainers和传统容器(runc)区别"></p><p><img src="/images/docker%E5%92%8Ckata-runtime.png" alt="docker和kata-runtime"></p><p><img src="/images/kata%E4%B8%8Ek8s.svg" alt="kata与k8s"></p><p><img src="/images/katacontainers_architecture_diagram.jpg" alt="kata与k8s示意图"></p><p><img src="/images/katacontainers-e2e-with-bg.jpg" alt="kubelet执行create pod之后逻辑架构"></p><p><img src="/images/kata3.x-architecture.png" alt="kata3.x-架构"></p><p><img src="/images/hypervisorConfigInkata-3.0.png" alt="kata3.0可选的hypervisor-config"></p><p><img src="/images/kata%E6%AF%94runcs.webp" alt="kata比runcs是GuestOS虚拟化-等效于runc加硬件虚拟化和HostOS虚拟化"></p><h3 id="四、安全容器集成方案"><a href="#四、安全容器集成方案" class="headerlink" title="四、安全容器集成方案"></a>四、安全容器集成方案</h3><h4 id="1-kata-container"><a href="#1-kata-container" class="headerlink" title="1.kata-container"></a>1.kata-container</h4><ol><li>方案：</li></ol><ul><li>背景: Intel Clear Containers 的最佳部分与 <a href="https://github.com/hyperhq">Hyper.sh RunV</a>的合并；</li><li>安装方式：kata-deploy(kubectl apply)、dnf软件包管理器、Snap包管理器等</li><li>依赖：x86_64&#x2F;amd64支持Intel VT-x, AMD SVM；aarch64&#x2F;arm64支持ARM Hyp</li><li>虚拟机管理程序：Dragonball(内置VMM)、firecraker、qemu(默认)、cloud-hypervisor等；</li><li>集成方式：安装kata-contianer，与k8s对接支持两种CRI实现，分别是CRI-O和containerd；</li></ul><ol start="2"><li>优点</li></ol><ul><li>多租户安全保障：防止恶意租户对 host 内核的直接攻击影响其他租户；</li><li>可信&amp;不可信容器混合部署：runC容器、安全容器可以同时部署在同一个宿主机之中；</li><li>Configurable Hypervisor，支持多种虚拟机监控程序，默认支持的是qemu，也可以用firecracker、Dragonball;</li><li>社区：社区活跃，方案成熟，阿里云、蚂蚁和intel共同推动2.0架构，提升多租隔离能力及可观测性；</li><li>安装：方式多样且k8s deploy方便快捷；</li><li>集成：与k8s集成方便快捷,支持CRI-O也可以支持containerd，系统部署复杂度；</li><li>兼容性：应用兼容性好</li><li>安全性：非常可靠，使用Intel VT-x和AMD SVM等硬件虚拟化技术支持硬件级别的隔离，使用SELinux、AppArmor等安全模块实现一系列安全机制；</li></ul><ol start="3"><li>缺点</li></ol><ul><li>性能问题：由于需要额外的虚拟化层，kata-containerd的性能较runc略低。</li><li>复杂性：kata-containerd需要额外的虚拟化层，使得整个系统更加复杂，增加了管理和维护的难度。</li><li>开销：开销较大，启动速度较慢，阿里云官方文档说社区版kata需要500ms而ACK安全沙箱v2约150ms。</li><li>IO比runc慢</li></ul><h4 id="2-gvisor"><a href="#2-gvisor" class="headerlink" title="2.gvisor"></a>2.gvisor</h4><ol><li>方案</li></ol><ul><li>背景：gvisor是google发布的一个安全容器，底层是基于安全模块seccomp、SELinux和 AppArmor，代理系统系统调用实现安全隔离，号称合并的用户态内核和VMM的；</li><li>安装方式：与Containerd集成（containerd&#x2F;config.toml和k8s.spec.runtimeClassName&#x3D;gvisor）、Minikube集成；</li><li>依赖：不依赖硬件虚拟化支持（Intel的Intel VT-x技术，AMD的AMD SVM技术）不依赖kvm，可以在虚拟机上虚拟化，与runc一样依赖Namespaces\cgroup等，只是增加了一层封装实现虚拟机模拟硬件等；</li></ul><ol start="2"><li>优点</li></ol><ul><li>用户态内核，支持虚拟机上虚拟化；</li><li>启动速度更快和占用资源更小：不需要虚拟出硬件设备、安装 Guest 操作系统；</li><li>应用执行性能上：与kata-containers不分伯仲；</li></ul><ol start="3"><li>缺点</li></ol><ul><li>代理系统调用实现隔离，当系统调用繁重时候，性能较差；</li><li>目前并未实现每个系统调用、&#x2F;proc文件或&#x2F;sys文件，因此可能会出现一些不兼容问题，<a href="https://gvisor.dev/docs/user_guide/compatibility/">通过兼容性测试的应用</a>；</li><li>稳定性风险：相对新的容器技术(初版release-20190304)，gvisor可能存在一些稳定性问题和未解决的bug，需要持续的维护和更新来保持稳定性；</li><li>系统调用密集的应用，比如重I&#x2F;O或者重网络的应用，gVisor 就会因为需要频繁拦截系统调用而出现性能急剧下降.</li><li>网络IO性能更差</li></ul><h4 id="3-在hypervisor和CRI-implements做最佳选择"><a href="#3-在hypervisor和CRI-implements做最佳选择" class="headerlink" title="3.在hypervisor和CRI implements做最佳选择"></a>3.在hypervisor和CRI implements做最佳选择</h4><p><img src="/images/%E5%AE%89%E5%85%A8%E5%AE%B9%E5%99%A8%E6%96%B9%E6%A1%88.png" alt="安全容器方案"></p><h4 id="4-kata和stratoVirt集成方案如何集成"><a href="#4-kata和stratoVirt集成方案如何集成" class="headerlink" title="4.kata和stratoVirt集成方案如何集成"></a>4.kata和stratoVirt集成方案如何集成</h4><h4 id="5-kata和firecraker的性能"><a href="#5-kata和firecraker的性能" class="headerlink" title="5.kata和firecraker的性能"></a>5.kata和firecraker的性能</h4><table><thead><tr><th>hypervisor</th><th>启动速度</th><th>内存消耗</th><th>IO性能</th><th>社区</th></tr></thead><tbody><tr><td>qemu</td><td>500ms <a href="https://help.aliyun.com/document_detail/160288.html">阿里云文档</a>  0.7s <a href="https://object-storage-ca-ymq-1.vexxhost.net/swift/v1/6e4619c416ff4bd19e1c087f27a43eea/www-assets-prod/presentation-media/kata-containers-and-gvisor-a-quantitave-comparison.pdf">参考</a></td><td>131MB <a href="https://mp.weixin.qq.com/s/bS2q0oZUK-TyD4T1TSRQHw">参考</a></td><td></td><td>03年推出7.8k</td></tr><tr><td>firecracker</td><td>125ms ,单机秒开150 microVMs</td><td>&lt;5MB  <a href="https://mp.weixin.qq.com/s/bS2q0oZUK-TyD4T1TSRQHw">测试为3MB</a></td><td>比qemu差点</td><td>18年推出21.5k star</td></tr><tr><td>statovirt</td><td>microvm 50ms</td><td>&lt; 4MB</td><td></td><td>18年推出 98 star</td></tr><tr><td>阿里云ACK安全沙箱</td><td>150ms</td><td></td><td></td><td></td></tr><tr><td>Cloud Hypervisor</td><td>100ms</td><td>13MB</td><td></td><td>2.7k star</td></tr></tbody></table><h4 id="6-gvisor和kata-qemu的对比"><a href="#6-gvisor和kata-qemu的对比" class="headerlink" title="6.gvisor和kata+qemu的对比"></a>6.gvisor和kata+qemu的对比</h4><ol><li>Memory Footprint内存占用:kata 70mb、gvisor 20mb；</li><li>Boot time启动时间:gvisor 0.45s、shimv2+kata 0.7s；</li><li>CPU&#x2F;Memory Performance CPU和内存的性能:gvisor和kata &amp; qemu 几乎一致；</li><li>IO性能:部分场景gvisor和kata&amp;qemu几乎一致，部分场景kata&amp;qemu表现更优秀；</li><li>Networking Performance网络性能:kata性能与gvisor差距明显，kata性能好非常多；</li><li>真实案例Nginx:kata的QPS能达到1.4w,gvisor的QPS是309;Transfer rate传输速率应该是12,127kb,而gvisor是255kb；</li><li>真实案例Redis之下，kata的QPS可以达到120,000,gvisor的不超过20,000;</li></ol><p>总结:</p><p>gvisor启动更快内存消耗小，是兼容性差（很多系统调用还未实现），网络IO性能表现非常差，在系统调用频繁的情况下性能非常差；</p><h4 id="7-firecraker的性能"><a href="#7-firecraker的性能" class="headerlink" title="7. firecraker的性能"></a>7. firecraker的性能</h4><ol><li>Firecracker MicroVM的启动时间大约为100毫秒，而QEMU的在200毫秒以上；</li><li>Firecracker内存开销非常低，每个MicroVM约为3MB，而QEMU在131MB左右；</li><li>Firecraker的IO性能约为QEMU的1&#x2F;4;</li><li>firecraker不支持所有的设备类型；</li><li>限于firecracker本身功能过于简单，因为其设计之初就是追求最少的设备、最简洁的功能，firecracker目前很多k8s的功能还不支持，比如volume、secret、configmap等。如果应用比较复杂，对运行环境的要求比较高，就只能使用qemu vm</li></ol><h4 id="8-阿里云的安全容器性能"><a href="#8-阿里云的安全容器性能" class="headerlink" title="8. 阿里云的安全容器性能"></a>8. 阿里云的安全容器性能</h4><ol><li>安全沙箱号称启动约150ms，而kata-container的启动时间500ms；</li></ol><h3 id="五、如何集成到k8s"><a href="#五、如何集成到k8s" class="headerlink" title="五、如何集成到k8s"></a>五、如何集成到k8s</h3><h4 id="1-安装方式"><a href="#1-安装方式" class="headerlink" title="1. 安装方式"></a>1. 安装方式</h4><p>使用containerd集成的方式集成kata，在各个宿主机安装kata，使用runtimeClass的方式注册到k8s之中</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">kind:</span> <span class="hljs-string">RuntimeClass</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">node.k8s.io/v1alpha1</span><br><span class="hljs-attr">metadata:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">native</span> <br><span class="hljs-attr">spec:</span><br>    <span class="hljs-attr">runtimeHandler:</span> <span class="hljs-string">runc</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">RuntimeClass</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">node.k8s.io/v1alpha1</span><br><span class="hljs-attr">metadata:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">kata-containers</span><br><span class="hljs-attr">spec:</span><br>    <span class="hljs-attr">runtimeHandler:</span> <span class="hljs-string">kata-containers</span><br></code></pre></td></tr></table></figure><p>runtimeHandler对应containerd的handler</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># /etc/containerd/config.toml</span><br>[<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.$</span>&#123;<span class="hljs-string">HANDLER_NAME</span>&#125;]<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 示例配置</span><br><span class="hljs-comment"># /etc/containerd/config.yml</span><br>[<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.kata</span>]<br>  <span class="hljs-string">runtime_type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;io.containerd.kata.v2&quot;</span><br>  [<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.kata.options</span>]<br>    <span class="hljs-string">ConfigPath</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;/opt/kata/share/defaults/kata-containers/configuration-qemu.toml&quot;</span><br><br>[<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;.containerd.runtimes.runc</span>]<br>  <span class="hljs-string">runtime_type</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;io.containerd.runc.v2&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>tips:如果各节点的运行时环境不一致，可通过scheduling限制仅调度到支持该 RuntimeClass 的节点上。如未设置 scheduling，默认所有节点均支持此 RuntimeClass</p></blockquote><h4 id="2-如何使用"><a href="#2-如何使用" class="headerlink" title="2. 如何使用"></a>2. 如何使用</h4><p>声明式创建对象的时候，声明runtimeClass的方式创建对象</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">extensions/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">sandboxed-nginx</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">native-nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">native-nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">runtimeClassName:</span> <span class="hljs-string">native</span> <span class="hljs-comment"># runtimeClassName 字段选定运行时使用runc</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><h4 id="3-如何验证"><a href="#3-如何验证" class="headerlink" title="3. 如何验证"></a>3. 如何验证</h4><p>进入容器之中，执行 uname -a 查看内核，如果与宿主机不一致表示当前已经是安全容器之中</p><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li>runc底层原理</li></ol><ul><li>namespace 用于隔离应用程序的进程空间、网络、文件系统等</li><li>cgroup 用于限制应用程序的资源使用 </li><li>seccomp 用于限制应用程序对系统调用的访问</li></ul><ol start="2"><li><p>kata+firecraker 和 kata+StratoVirt 哪个性能更好</p></li><li><p>iSula比Docker强没错，但是iSula和Containerd比呢</p></li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">kata就是一个OCI<br></code></pre></td></tr></table></figure><ol start="4"><li>查看kata-runtime的运行日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">tail</span> -f /var/log/messages | grep kata-runtime<br>$ <span class="hljs-built_in">tail</span> -f /var/log/messages | grep kata-runtime<br></code></pre></td></tr></table></figure><ol start="5"><li>如何查看containerd的容器消耗</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker 查看容器消耗的内存和CPU</span><br>$ docker stats <span class="hljs-variable">$containerdID</span><br></code></pre></td></tr></table></figure><ol start="6"><li>如何查看containerd当前容器列表的虚拟化方式</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># containerd 罗列容器</span><br>$ ctr c <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure><ol start="7"><li>containerd运行一个容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行cni分配终端running后移除容器</span><br>$ ctr run --runtime io.containerd.kata.v2 --cni -t --<span class="hljs-built_in">rm</span> docker.io/library/busybox:latest hello sh<br></code></pre></td></tr></table></figure><ol start="8"><li>journalctl查看系统服务日志</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看containerd日志</span><br>$ journalctl -ucontainerd -f<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://firecracker-microvm.github.io/">https://firecracker-microvm.github.io/</a>  </li><li><a href="https://gvisor.dev/">https://gvisor.dev/</a></li><li><a href="https://katacontainers.io/">https://katacontainers.io/</a></li><li><a href="https://www.qemu.org/">https://www.qemu.org/</a></li><li><a href="https://docs.openeuler.org/zh/docs/22.03_LTS_SP1/docs/StratoVirt/%E5%AE%89%E8%A3%85StratoVirt.html">https://docs.openeuler.org/zh/docs/22.03_LTS_SP1&#x2F;docs&#x2F;StratoVirt&#x2F;</a></li><li><a href="https://www.linux-kvm.org/page/Main_Page">https://www.linux-kvm.org/page/Main_Page</a></li><li><a href="https://libvirt.org/">https://libvirt.org/</a></li><li><a href="https://kubevirt.io/">https://kubevirt.io/</a></li><li><a href="https://selinuxproject.org/page/Main_Page">https://selinuxproject.org/page/Main_Page</a></li><li><a href="https://www.openeuler.org/zh/blog/wangzhigang/howToUseStratoVirt.html">如何安装启动StratoVirt</a></li><li><a href="https://gitee.com/openeuler/stratovirt">https://gitee.com/openeuler/stratovirt</a></li><li><a href="https://gitee.com/openeuler/stratovirt/blob/master/docs/design.ch.md">stratovirt设计</a></li><li><a href="https://rustmagazine.github.io/rust_magazine_2021/chapter_3/hw_rust_stratovirt.html">华为 | 基于Rust的下一代虚拟化平台-StratoVirt</a></li><li><a href="https://cloud.tencent.com/developer/article/1761013">已有Qemu了，为什么还要StratoVirt</a></li><li><a href="https://zhuanlan.zhihu.com/p/72484589">Qemu架构图</a></li><li><a href="https://cdn.jiwenkang.com/QEMU.html">KVM &amp; Qemu &amp;</a></li><li><a href="https://wiki.qemu.org/Documentation/Architecture">Qemu架构图</a></li><li><a href="https://github.com/kata-containers/kata-containers/blob/main/docs/hypervisors.md">kata如何选择hypervisors</a></li><li><a href="https://github.com/kata-containers/documentation/blob/master/design/architecture.md">kata博客架构图</a></li><li><a href="https://github.com/kata-containers/kata-containers/blob/main/docs/Developer-Guide.md#run-kata-containers-with-kubernetes">run kata containers with kubernetes</a></li><li><a href="https://mp.weixin.qq.com/s/X2EbeQEORR3iQXXskomkBQ">迈向Kata 3.0|走进开箱即用的安全容器体验之旅|龙蜥技术</a></li><li><a href="https://mp.weixin.qq.com/s/BTnZw5wiFg774RC2Qz_fsA">阿里云Severeless产品背后的kataContainers</a></li><li><a href="https://mp.weixin.qq.com/s/pUVR8P1bTszB6rPzMAnV3A">Kata Containers 在百度智能云的应用实践</a></li><li><a href="https://www.aliyun.com/solution/security/containersecurity">阿里云官方文档-容器安全解决方案</a></li><li><a href="https://www.aliyun.com/solution/cloudnative/securecontainer">阿里云官方文档-云原生安全容器解决方案</a></li><li><a href="https://help.aliyun.com/document_detail/142151.html">阿里云官方文档-安全容器底层的安全沙箱（runV）容器</a></li><li><a href="https://help.aliyun.com/document_detail/160288.html">阿里云官方文档-ACK安全沙箱和社区KataContainers对比</a></li><li><a href="https://www.infoq.cn/article/rfs60wi3a5ba5fsonpzi">InfoQ-安全容器在阿里巴巴的应用和实践</a></li><li><a href="https://www.infoq.cn/article/2018/05/gvisor-container-sandbox">gVisor:谷歌发布的一个用于提供安全隔离的轻量级容器运行时沙箱</a></li><li><a href="https://gvisor.dev/docs/user_guide/containerd/quick_start/">gvisor Containerd Quick Start</a></li><li><a href="https://www.anquanke.com/post/id/224001">Virtio：一种Linux I&#x2F;O虚拟化框架</a></li><li><a href="https://learn.archervanderwaal.com/13-%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90Kubernetes/09-Kubernetes%E5%AE%B9%E5%99%A8%E8%BF%90%E8%A1%8C%E6%97%B6%20(3%E8%AE%B2)/47%E4%B8%A8%E7%BB%9D%E4%B8%8D%E4%BB%85%E4%BB%85%E6%98%AF%E5%AE%89%E5%85%A8%EF%BC%9AKataContainers%E4%B8%8EgVisor.html">极客时间:kata-containers与gvisor实现原理</a></li><li><a href="https://object-storage-ca-ymq-1.vexxhost.net/swift/v1/6e4619c416ff4bd19e1c087f27a43eea/www-assets-prod/presentation-media/kata-containers-and-gvisor-a-quantitave-comparison.pdf">kata-containers官方文档：kata与gvisor性能</a></li><li><a href="https://www.infoq.cn/article/exQ3fbD02raNmTGJKdvX">Docker 真的要被 Kubernetes 社区剔除了吗</a></li><li><a href="https://mp.weixin.qq.com/s/z6s4QliBHs08pVj0GQ03dw">docker与k8s的发展史</a></li><li><a href="https://lifeng2221dd1.gitee.io/2020/08/17/arch/">CRI架构图</a></li><li><a href="https://mp.weixin.qq.com/s/bS2q0oZUK-TyD4T1TSRQHw">Firecracker性能标准</a></li><li><a href="https://mp.pdnews.cn/Pc/ArtInfoApi/article?id=25177366">Firecraker的缺点</a></li><li><a href="https://kubernetes.io/zh-cn/docs/concepts/containers/runtime-class/">k8s官方手册-容器运行时</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>物理机和虚拟机和容器的区别</title>
    <link href="/2023/04/23/kubernetes/%E7%89%A9%E7%90%86%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/04/23/kubernetes/%E7%89%A9%E7%90%86%E6%9C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><img src="/images/docker-vmm.png" alt="docker&amp;&amp;VMM"><br><img src="/images/docker-and-vmm.png" alt="docker的容器runc和VMM的区别"><br><img src="/images/vm-type.png" alt="虚拟化方式"><br><img src="/images/20201126143904207.png" alt="qemu与内核之间的关系"></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/baiyan83/article/details/110182411">了解以及区分物理机，虚拟机(hypervisor&#x2F;VMM) 和 容器(Docker)的适用场景</a><br><a href="https://blog.csdn.net/yibuchen/article/details/80426680">物理机、虚拟机、容器的比较</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>制作镜像编译k8s以及CICD流程</title>
    <link href="/2023/04/21/kubernetes/%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91k8s/"/>
    <url>/2023/04/21/kubernetes/%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91k8s/</url>
    
    <content type="html"><![CDATA[<h3 id="一、总览"><a href="#一、总览" class="headerlink" title="一、总览"></a>一、总览</h3><ol><li>制作镜像支持编译SDN以及上传helm包和images</li></ol><ul><li>docker in docker</li><li>go version 1.8</li><li>registry.company.net</li><li>buildx</li></ul><ol start="2"><li><p>注册runner到gitlab</p></li><li><p>编写gitlab-ci.yml文件设置CI流水线</p></li></ol><h3 id="一、镜像构建源文件"><a href="#一、镜像构建源文件" class="headerlink" title="一、镜像构建源文件"></a>一、镜像构建源文件</h3><ol><li>目录树</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">project<br>├── Dockerfile<br>├── README.md<br>└── file<br>    ├── buildkitd.toml<br>    ├── daemon.json<br>    └── docker-config.json<br>    └── .ssh<br></code></pre></td></tr></table></figure><ol start="2"><li>Dockerfile</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash">FROM docker:dind<br><br>COPY file/ /tmp/<br><br>ENV GOPATH=<span class="hljs-string">&quot;/home/go&quot;</span> \<br>    GOROOT=<span class="hljs-string">&quot;/usr/local/go&quot;</span> \<br>    GOPROXY=<span class="hljs-string">&quot;https://goproxy.cn,direct&quot;</span> \<br>    GOINSECURE=<span class="hljs-string">&quot;gitlab.company.net&quot;</span> \<br>    GOPRIVATE=<span class="hljs-string">&quot;*.corp.com,gitlab.company.net&quot;</span> \<br>    GONOPROXY=<span class="hljs-string">&quot;gitlab.company.net&quot;</span> \<br>    GONOSUMDB=<span class="hljs-string">&quot;gitlab.company.net&quot;</span> \<br>    PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$PATH</span>:/usr/local/go/bin&quot;</span><br><br><span class="hljs-comment"># install golang</span><br>RUN sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.ustc.edu.cn/g&#x27;</span> /etc/apk/repositories \<br>    &amp;&amp; apk --update add tar make rsync bash \<br>    &amp;&amp; <span class="hljs-built_in">cd</span> /home &amp;&amp; wget https://go.dev/dl/go1.18.linux-arm64.tar.gz &amp;&amp; <span class="hljs-built_in">ls</span> \<br>    &amp;&amp; <span class="hljs-built_in">cd</span> /home &amp;&amp; tar -C /usr/local -xzf go1.18.linux-arm64.tar.gz \<br>    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=$PATH:/usr/local/go/bin&#x27;</span> &gt; /etc/profile \<br>    &amp;&amp; <span class="hljs-built_in">source</span> /etc/profile \<br>    &amp;&amp; apk add --no-cache tzdata gcc g++ binutils libc6-compat build-base git helm \<br>    &amp;&amp; helm plugin install https://github.com/chartmuseum/helm-push \<br>    &amp;&amp; <span class="hljs-built_in">ln</span> -snf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime \<br>    &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Asia/Shanghai&quot;</span> &gt; /etc/timezone \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /root/.docker &amp;&amp; <span class="hljs-built_in">mv</span> /tmp/docker-config.json /root/.docker/config.json \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /etc/docker &amp;&amp; <span class="hljs-built_in">mv</span> /tmp/daemon.json /etc/docker/daemon.json \<br>    &amp;&amp; <span class="hljs-built_in">ln</span> -s /lib/libc.so.6 /usr/lib/libresolv.so.2 \<br>    &amp;&amp; <span class="hljs-built_in">mkdir</span> -p /etc/buildkit &amp;&amp; <span class="hljs-built_in">mv</span> /tmp/buildkitd.toml /etc/buildkit/buildkitd.toml \<br>    &amp;&amp; <span class="hljs-built_in">mv</span> /tmp/.ssh ~<br></code></pre></td></tr></table></figure><ol start="3"><li>buildkitd.toml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml">[<span class="hljs-string">registry.&quot;registry.company.net&quot;</span>]<br>    <span class="hljs-string">http</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span><br>    <span class="hljs-string">insecure</span> <span class="hljs-string">=</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ol start="4"><li>daemon.json</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;insecure-registries&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;registry.company.net&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;debug&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;experimental&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;features&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;buildkit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>docker-config.json</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;auths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;registry.company.net&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx=&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol start="5"><li>.ssh是git库认证的密钥</li></ol><h3 id="三、构建镜像"><a href="#三、构建镜像" class="headerlink" title="三、构建镜像"></a>三、构建镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 构建镜像到本地</span><br>$ <span class="hljs-built_in">cd</span> project &amp;&amp; docker build -t my-builder:v0.0.1 .<br><br><span class="hljs-comment"># 推送镜像到harbor私有库</span><br><span class="hljs-comment"># docker push &lt;Registry&gt;/&lt;Image&gt;</span><br>$ docker tag my-builder:v0.0.1 registry.company.net/devops/my-builder:v0.0.1<br><br><span class="hljs-comment"># docker push registry.example.com/myimage</span><br>$ docker push registry.company.net/devops/my-builder:v0.0.1<br></code></pre></td></tr></table></figure><h3 id="四、镜像验证"><a href="#四、镜像验证" class="headerlink" title="四、镜像验证"></a>四、镜像验证</h3><ol><li><p>容器内编译的过程中遇到的问题以及解决办法</p><ul><li>多架构编译内部无法识别到harbor私有库的域名，需要指定 buildx <code>共享主机网络</code></li><li>需要创建新的 buildx 构建器</li><li>容器内部的docker daemon程序未启动，要注意 dind 的 <code>ENTRYPOINT</code> 入口不要被覆盖</li></ul></li><li><p>在容器之中编译</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意 docker run 后面不能带上 /bin/bash 否则会导致 ENTRYPOINT 被覆盖从而 docker daemon无法启动</span><br><span class="hljs-comment"># 因为会覆盖镜像内部的CMD指令</span><br><span class="hljs-comment"># 跟在镜像名后面的是 command，运行时会替换 CMD 的默认值</span><br>$ docker run -itd --privileged=<span class="hljs-literal">true</span> registry.company.net/devops/my-builder:v0.0.1<br><br>$ docker run -v <span class="hljs-string">&quot;/Users/xuweiqiang/Documents/project:/home/project&quot;</span> -itd --privileged=<span class="hljs-literal">true</span> registry.company.net/devops/my-builder:v0.0.1<br><br><span class="hljs-comment"># 创建一个新的 buildx 构建器，并将其设置为当前正在使用的构建器</span><br><span class="hljs-comment"># 以便在运行 Docker 构建命令时可以使用该构建器进行构建</span><br><span class="hljs-comment"># 通过 network=host 指定共享主机网络</span><br><span class="hljs-comment"># 在容器containerd内部执行的</span><br>$ docker buildx create --config /etc/buildkit/buildkitd.toml --append --driver-opt network=host --use<br><br>$ <span class="hljs-built_in">cd</span> /home/project<br>$ ./build.sh start<br></code></pre></td></tr></table></figure><h3 id="五、CI文件编写"><a href="#五、CI文件编写" class="headerlink" title="五、CI文件编写"></a>五、CI文件编写</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 此处省略runner安装和挂载到gitlab的流程</span><br>$ <span class="hljs-built_in">cd</span> project &amp;&amp; <span class="hljs-built_in">touch</span> .gitlab-ci.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">image:</span> <span class="hljs-string">registry.company.net/devops/my-builder:v0.0.1</span><br><span class="hljs-attr">variables:</span><br>  <span class="hljs-attr">REGISTRY_IP:</span> <span class="hljs-string">&quot;x.x.x.x&quot;</span> <span class="hljs-comment"># 这是harbor私服的ip</span><br><span class="hljs-attr">stages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">one</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">two</span><br><span class="hljs-attr">cni:</span><br>  <span class="hljs-attr">when:</span> <span class="hljs-string">manual</span> <span class="hljs-comment"># 手动触发</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">one</span><br>  <span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker-test</span> <span class="hljs-comment"># runner tag</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">url.&quot;git@gitlab.company.net:&quot;.insteadOf</span> <span class="hljs-string">&quot;https://gitlab.company.net/&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$REGISTRY_IP registry.company.net&quot;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">/etc/hosts</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$CI_COMMIT_REF_NAME&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sed</span> <span class="hljs-string">-i</span> <span class="hljs-string">&quot;s/GIT_VERSION/$CI_COMMIT_REF_NAME/g&quot;</span> <span class="hljs-string">/builds/project/build.sh</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">buildx</span> <span class="hljs-string">create</span> <span class="hljs-string">--config</span> <span class="hljs-string">/etc/buildkit/buildkitd.toml</span> <span class="hljs-string">--append</span> <span class="hljs-string">--driver-opt</span> <span class="hljs-string">network=host</span> <span class="hljs-string">--use</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">/builds/project/</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">./build.sh</span> <span class="hljs-string">one</span><br><span class="hljs-attr">sdn:</span><br>  <span class="hljs-attr">when:</span> <span class="hljs-string">manual</span> <span class="hljs-comment"># 手动触发</span><br>  <span class="hljs-attr">stage:</span> <span class="hljs-string">two</span><br>  <span class="hljs-attr">tags:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker-test</span>  <span class="hljs-comment"># runner tag</span><br>  <span class="hljs-attr">script:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">git</span> <span class="hljs-string">config</span> <span class="hljs-string">--global</span> <span class="hljs-string">url.&quot;git@gitlab.company.net:&quot;.insteadOf</span> <span class="hljs-string">&quot;https://gitlab.company.net/&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$REGISTRY_IP registry.company.net&quot;</span> <span class="hljs-string">&gt;&gt;</span> <span class="hljs-string">/etc/hosts</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">echo</span> <span class="hljs-string">&quot;$CI_COMMIT_REF_NAME&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">sed</span> <span class="hljs-string">-i</span> <span class="hljs-string">&quot;s/GIT_VERSION/$CI_COMMIT_REF_NAME/g&quot;</span> <span class="hljs-string">/builds/project/build.sh</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">docker</span> <span class="hljs-string">buildx</span> <span class="hljs-string">create</span> <span class="hljs-string">--config</span> <span class="hljs-string">/etc/buildkit/buildkitd.toml</span> <span class="hljs-string">--append</span> <span class="hljs-string">--driver-opt</span> <span class="hljs-string">network=host</span> <span class="hljs-string">--use</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">cd</span> <span class="hljs-string">/builds/project/</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">./build.sh</span> <span class="hljs-string">two</span><br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ul><li>如何查看容器内部是否拥有registry的验证</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker login registry.company.net<br></code></pre></td></tr></table></figure><ul><li>如何指定宿主机docker的engine</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ping docker.for.mac.host.internal<br>$ docker -H tcp://192.168.65.2:2375 images<br></code></pre></td></tr></table></figure><ul><li>如何使用github的Action(CI)拉取镜像k8s.gcr.io</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1.github新建项目</span><br><span class="hljs-comment"># 2.在该项目的Action新建工作流</span><br><span class="hljs-comment"># 3.在该项目的setting的secrets and variable添加DOCKER_PASSWORD用于登陆个人hub</span><br><br><span class="hljs-comment"># 或者直接项目根目录</span><br>$ <span class="hljs-built_in">mkdir</span> -p .github/workflows<br>$ <span class="hljs-built_in">touch</span> .github/workflows/main.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># main.yml</span><br><span class="hljs-comment"># This is a basic workflow to help you get started with Actions</span><br><br><span class="hljs-attr">name:</span> <span class="hljs-string">CI</span><br><br><span class="hljs-comment"># Controls when the workflow will run</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-comment"># Triggers the workflow on push or pull request events but only for the &quot;main&quot; branch</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;main&quot;</span> ]<br>  <span class="hljs-attr">pull_request:</span><br>    <span class="hljs-attr">branches:</span> [ <span class="hljs-string">&quot;main&quot;</span> ]<br>  <span class="hljs-attr">workflow_dispatch:</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Run</span> <span class="hljs-string">a</span> <span class="hljs-string">multi-line</span> <span class="hljs-string">script</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          docker pull k8s.gcr.io/build-image/kube-cross:v1.21.0-go1.16.15-buster.0</span><br><span class="hljs-string">          docker tag k8s.gcr.io/build-image/kube-cross:v1.21.0-go1.16.15-buster.0 435861851/k8s.gcr.io:kube-cross-v1.21.0-go1.16.15-buster.0</span><br><span class="hljs-string"></span>      <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Log</span> <span class="hljs-string">in</span> <span class="hljs-string">to</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Hub</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">docker/login-action@f054a8b539a109f9f41c372932f1ae047eff08c9</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">username:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.DOCKER_USERNAME</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">password:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.DOCKER_PASSWORD</span> <span class="hljs-string">&#125;&#125;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Push</span> <span class="hljs-string">to</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Registry</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>          <span class="hljs-string">docker</span> <span class="hljs-string">push</span> <span class="hljs-number">435861851</span><span class="hljs-string">/k8s.gcr.io:kube-cross-v1.21.0-go1.16.15-buster.0</span><br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://docker-practice.github.io/zh-cn/image/dockerfile/entrypoint.html">ENTRYPOINT 入口点</a><br><a href="https://developer.aliyun.com/article/875641">如何用Github轻松拉取谷歌容器镜像</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>cicd</tag>
      
      <tag>dockerfile</tag>
      
      <tag>image</tag>
      
      <tag>katacontainers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>制作镜像编译kata</title>
    <link href="/2023/04/21/kubernetes/%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91kata/"/>
    <url>/2023/04/21/kubernetes/%E5%88%B6%E4%BD%9C%E9%95%9C%E5%83%8F%E7%BC%96%E8%AF%91kata/</url>
    
    <content type="html"><![CDATA[<h3 id="一、编写Dockerfile"><a href="#一、编写Dockerfile" class="headerlink" title="一、编写Dockerfile"></a>一、编写Dockerfile</h3><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Dockerfile"><span class="hljs-keyword">FROM</span> centos:centos7<br><br><span class="hljs-keyword">ENV</span> GOROOT=<span class="hljs-string">&quot;/usr/local/go&quot;</span> \<br>    GOPROXY=<span class="hljs-string">&quot;https://goproxy.cn,direct&quot;</span> \<br>    GOINSECURE=<span class="hljs-string">&quot;gitlab.my-company.net&quot;</span> \<br>    GOPRIVATE=<span class="hljs-string">&quot;*.corp.com,gitlab.my-company.net&quot;</span> \<br>    GONOPROXY=<span class="hljs-string">&quot;gitlab.my-company.net&quot;</span> \<br>    GONOSUMDB=<span class="hljs-string">&quot;gitlab.my-company.net&quot;</span> \<br>    PATH=<span class="hljs-string">&quot;$PATH:/usr/local/go/bin&quot;</span> \<br>    TZ=<span class="hljs-string">&quot;Asia/Shanghai&quot;</span><br><br><span class="hljs-comment"># repo</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> curl https://sh.rustup.rs -sSf | sh -s -- -y &amp;&amp; <span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/.cargo/bin:<span class="hljs-variable">$PATH</span>&quot;</span> &amp;&amp; \</span><br><span class="language-bash">  yum-config-manager --add-repo  https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo &amp;&amp; \</span><br><span class="language-bash">  yum -y install wget &amp;&amp; \</span><br><span class="language-bash">  <span class="hljs-built_in">cd</span> /home &amp;&amp; wget https://go.dev/dl/go1.19.8.linux-arm64.tar.gz &amp;&amp; \</span><br><span class="language-bash">  tar -C /usr/local -xzf go1.19.8.linux-arm64.tar.gz &amp;&amp; \</span><br><span class="language-bash">  <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/usr/local/go/bin &amp;&amp; <span class="hljs-built_in">source</span> /etc/profile &amp;&amp; \</span><br><span class="language-bash">  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;export PATH=$PATH:/usr/local/go/bin&#x27;</span> | <span class="hljs-built_in">tee</span> -a /etc/profile &gt; /etc/profile &amp;&amp; \</span><br><span class="language-bash">  <span class="hljs-built_in">source</span> /etc/profile &amp;&amp; \</span><br><span class="language-bash">  yum install -y automake autoconf libtool make gcc gcc-c++ rsync git &amp;&amp; \</span><br><span class="language-bash">  <span class="hljs-built_in">cp</span> /usr/share/zoneinfo/<span class="hljs-variable">$&#123;TZ&#125;</span> /etc/localtime &amp;&amp; <span class="hljs-built_in">echo</span> <span class="hljs-variable">$&#123;TZ&#125;</span> &gt; /etc/timezone &amp;&amp; \</span><br></code></pre></td></tr></table></figure><h3 id="二、制作镜像"><a href="#二、制作镜像" class="headerlink" title="二、制作镜像"></a>二、制作镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># go 1.19.8 &amp;&amp; centos 7.9 </span><br>$ docker build -t centos-go1.19.8:v1 .<br></code></pre></td></tr></table></figure><h3 id="三、推送镜像到云端"><a href="#三、推送镜像到云端" class="headerlink" title="三、推送镜像到云端"></a>三、推送镜像到云端</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker tag centos-go1.19.8:v2 registry.my.net/devops/centos-go1.19.8:v2<br>docker login<br>docker push registry.my.net/devops/centos-go1.19.8:v2<br>docker <span class="hljs-built_in">logout</span><br></code></pre></td></tr></table></figure><h3 id="四、运行镜像验证"><a href="#四、运行镜像验证" class="headerlink" title="四、运行镜像验证"></a>四、运行镜像验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 验证kata的编译</span><br>$ docker run -itd \<br>    -v /Users/xuweiqiang/Documents/code/kata-containers/:/home/kata-containers \<br>    --privileged=<span class="hljs-literal">true</span> \<br>    --name <span class="hljs-built_in">test</span> \<br>    centos-go1.19.8:v2<br></code></pre></td></tr></table></figure><h3 id="五、构建并安装kata"><a href="#五、构建并安装kata" class="headerlink" title="五、构建并安装kata"></a>五、构建并安装kata</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /home<br>$ <span class="hljs-built_in">pushd</span> kata-containers/src/runtime<br>$ make &amp;&amp; make install<br>$ <span class="hljs-built_in">mkdir</span> -p /etc/kata-containers/<br>$ <span class="hljs-built_in">cp</span> /usr/share/defaults/kata-containers/configuration.toml /etc/kata-containers<br>$ <span class="hljs-built_in">popd</span><br></code></pre></td></tr></table></figure><h3 id="六、验证安装成功"><a href="#六、验证安装成功" class="headerlink" title="六、验证安装成功"></a>六、验证安装成功</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kata-runtime version<br><span class="hljs-comment"># kata-runtime  : 3.1.0</span><br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li><p>kata-deploy怎么支持k8s</p></li><li><p>kata-containerd怎么编译获取手动安装包kata-static-3.1.0-x86_64.tar.xz</p></li></ul><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><p><a href="https://github.com/kata-containers/kata-containers/blob/3.1.0/docs/Developer-Guide.md">官方文档kata-containers-v1.3.0开发者向导</a><br><a href="https://github.com/kata-containers/kata-containers/releases/tag/3.1.0">官方文档kata-containers-v1.3.0二进制包下载链接</a><br><a href="https://github.com/kata-containers/kata-containers/blob/3.1.0/docs/install/container-manager/containerd/containerd-install.md">官方文档kata-containers-v1.3.0手动安装文档</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>cicd</tag>
      
      <tag>dockerfile</tag>
      
      <tag>image</tag>
      
      <tag>katacontainers</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DockerHub私服Registry搭建与使用</title>
    <link href="/2023/04/18/docker/DockerHub%E7%A7%81%E6%9C%8DRegistry%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/04/18/docker/DockerHub%E7%A7%81%E6%9C%8DRegistry%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-本地创建私服镜像目录"><a href="#1-本地创建私服镜像目录" class="headerlink" title="1.本地创建私服镜像目录"></a>1.本地创建私服镜像目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> ~/test<br>$ <span class="hljs-built_in">cd</span> ~/test &amp;&amp; <span class="hljs-built_in">mkdir</span> data auth docker-compose<br>$ <span class="hljs-built_in">touch</span> ~/test/docker-compose/docker-compose.yml<br><span class="hljs-comment"># 创建一个用户，执行完成后会生成文件 /home/auth/registry.password</span><br>$ <span class="hljs-built_in">cd</span> ~/test/auth &amp;&amp; htpasswd -Bc registry.password root<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># docker-compose.yml</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5001:5000&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">REGISTRY_AUTH:</span> <span class="hljs-string">htpasswd</span><br>      <span class="hljs-attr">REGISTRY_AUTH_HTPASSWD_REALM:</span> <span class="hljs-string">MyRegistry</span><br>      <span class="hljs-attr">REGISTRY_AUTH_HTPASSWD_PATH:</span> <span class="hljs-string">/auth/registry.password</span><br>      <span class="hljs-attr">REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY:</span> <span class="hljs-string">/data</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/test/auth:/auth</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">~/test/data:/data</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~/test/docker-compose &amp;&amp; docker-compose up -d<br></code></pre></td></tr></table></figure><h3 id="2-访问registy服务"><a href="#2-访问registy服务" class="headerlink" title="2.访问registy服务"></a>2.访问registy服务</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 访问输入用户名密码 </span><br>$ curl -X GET -u<span class="hljs-string">&#x27;root:123456&#x27;</span> http://localhost:5001/v2/_catalog<br><br><span class="hljs-comment"># 登陆docker registry</span><br>$ docker login localhost:5001<br>Username: root<br>Password: <br>Login Succeeded<br></code></pre></td></tr></table></figure><h3 id="3-添加私有库到docker配置"><a href="#3-添加私有库到docker配置" class="headerlink" title="3.添加私有库到docker配置"></a>3.添加私有库到docker配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># /etc/docker/daemon.json or ~/.docker/daemon.json</span><br>&#123;<br> <span class="hljs-string">&quot;insecure-registries&quot;</span>: [<br>   <span class="hljs-string">&quot;localhost:5001&quot;</span><br> ]<br>&#125;<br><br><span class="hljs-comment"># 登陆registry</span><br>$ docker login localhost:5001<br><br><span class="hljs-comment"># 构建镜像到本地</span><br>$ <span class="hljs-built_in">cd</span> my-project &amp;&amp; docker build -t my-image:v0.0.1 .<br><br><span class="hljs-comment"># 推送镜像到harbor私有库</span><br><span class="hljs-comment"># docker push &lt;Registry&gt;/&lt;Image&gt;</span><br>$ docker tag ovs-aline:v0.0.1 localhost:5001/devops/ovs-aline:v0.0.1<br><br><span class="hljs-comment"># docker push registry.example.com/myimage</span><br><span class="hljs-comment"># # 在 ~/test/data/ 目录存放镜像文件</span><br>$ docker push localhost:5001/devops/ovs-aline:v0.0.1<br><br><span class="hljs-comment"># docker pull registry.example.com/myimage</span><br>$ docker pull localhost:5001/devops/ovs-aline:v0.0.1<br><br><span class="hljs-comment"># 查看仓库镜像列表</span><br>$ curl -X GET -u<span class="hljs-string">&#x27;root:123456&#x27;</span> http://localhost:5001/v2/_catalog<br>&#123;<span class="hljs-string">&quot;repositories&quot;</span>:[<span class="hljs-string">&quot;devops/ovs-aline&quot;</span>]&#125;<br><br><span class="hljs-comment"># 查看仓库镜像tag</span><br>$ curl -X GET -u<span class="hljs-string">&#x27;root:123456&#x27;</span> http://localhost:5001/v2/devops/ovs-aline/tags/list<br>&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;devops/ovs-aline&quot;</span>,<span class="hljs-string">&quot;tags&quot;</span>:[<span class="hljs-string">&quot;v0.0.1&quot;</span>]&#125;<br></code></pre></td></tr></table></figure><h3 id="4-web服务提供registy可视化界面"><a href="#4-web服务提供registy可视化界面" class="headerlink" title="4.web服务提供registy可视化界面"></a>4.web服务提供registy可视化界面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker inspect <span class="hljs-variable">$&#123;registry_id&#125;</span><br><br><span class="hljs-comment"># start</span><br>$ docker run -d -p 8080:8080 \<br>  --name registry-web \<br>  --net docker-compose_default \<br>  --<span class="hljs-built_in">link</span> docker-compose-registry-1 \<br>  -e REGISTRY_URL=http://docker-compose-registry-1:5000/v2 \<br>  -e REGISTRY_BASIC_AUTH=<span class="hljs-string">&quot;cm9vdDoxMjM0NTY=&quot;</span> \<br>  -e REGISTRY_NAME=localhost \<br>  hyper/docker-registry-web<br><br><br><span class="hljs-comment"># REGISTRY_BASIC_AUTH其实是一个base64</span><br><span class="hljs-comment"># 对 `username:password` 进行base64 encode</span><br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-htpasswd是什么命令"><a href="#1-htpasswd是什么命令" class="headerlink" title="1.htpasswd是什么命令"></a>1.htpasswd是什么命令</h5><p>htpasswd命令是Apache Web服务器的一个工具，用于创建和管理用户账户文件的命令行工具，可用于创建新用户、更改密码并删除已有用户。</p><h5 id="2-registry的REGISTRY-AUTH-HTPASSWD-REALM参数是干嘛的"><a href="#2-registry的REGISTRY-AUTH-HTPASSWD-REALM参数是干嘛的" class="headerlink" title="2.registry的REGISTRY_AUTH_HTPASSWD_REALM参数是干嘛的"></a>2.registry的REGISTRY_AUTH_HTPASSWD_REALM参数是干嘛的</h5><p>REGISTRY_AUTH_HTPASSWD_REALM参数是用于设置Docker registry的基本认证（Basic Authentication）的HTTP Realm。如果设置了REGISTRY_AUTH_HTPASSWD_REALM参数值为”My Docker Registry”，则用户在登录时将看到类似于”Please enter your My Docker Registry credentials”的提示，有助于确保用户知道他们正在访问受保护的资源。</p><h5 id="3-registry的参数-REGISTRY-STORAGE-FILESYSTEM-ROOTDIRECTORY-是干嘛的"><a href="#3-registry的参数-REGISTRY-STORAGE-FILESYSTEM-ROOTDIRECTORY-是干嘛的" class="headerlink" title="3.registry的参数 REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY 是干嘛的"></a>3.registry的参数 REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY 是干嘛的</h5><p>REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY参数是用于设置Docker registry存储镜像的根目录。默认情况下，Docker registry使用&#x2F;var&#x2F;lib&#x2F;registry作为默认的存储目录。</p><h5 id="4-监听网卡"><a href="#4-监听网卡" class="headerlink" title="4.监听网卡"></a>4.监听网卡</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo tcpdump -nei lo0 port 5001<br>$ telnet 127.0.0.1 5001<br></code></pre></td></tr></table></figure><h5 id="5-docker-registry的token"><a href="#5-docker-registry的token" class="headerlink" title="5.docker registry的token"></a>5.docker registry的token</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cat</span> ~/.docker/config.json<br></code></pre></td></tr></table></figure><p>对<code>username:password</code>进行base64 encode可以获得。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://hub.docker.com/_/registry">https://hub.docker.com/_&#x2F;registry</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>registry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker离线安装</title>
    <link href="/2023/04/18/docker/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/"/>
    <url>/2023/04/18/docker/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="方式一：导出rpm包或者deb包进行离线安装-推荐"><a href="#方式一：导出rpm包或者deb包进行离线安装-推荐" class="headerlink" title="方式一：导出rpm包或者deb包进行离线安装 - 推荐"></a>方式一：导出rpm包或者deb包进行离线安装 - 推荐</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># rpm包导出</span><br>$ yum -y reinstall --downloadonly --downloaddir=./ docker<br><br><span class="hljs-comment"># 安装rpm包</span><br>$ rpm -ivh ./*.rpm<br>$ rpm -ivh package_name.rpm<br><br><span class="hljs-comment"># deb包导出</span><br>$ apt-get install dpkg-repack<br>$ dpkg-repack <span class="hljs-variable">$&#123;package-name&#125;</span><br></code></pre></td></tr></table></figure><h3 id="方式二：下载离线包并配置systemd"><a href="#方式二：下载离线包并配置systemd" class="headerlink" title="方式二：下载离线包并配置systemd"></a>方式二：下载离线包并配置systemd</h3><ol><li>下载安装包</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt"># docker离线安装包<br><br>Docker离线安装包官方下载链接：<br>Docker Engine: https://docs.docker.com/engine/install/binaries/<br>Docker Compose: https://github.com/docker/compose/releases<br>Docker Machine: https://github.com/docker/machine/releases<br>注意：离线安装包的下载可能比在线安装包的下载时间更长，建议选择适合自己网络和设备的安装方式。<br></code></pre></td></tr></table></figure><ol start="2"><li>上传到linux服务器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 解压</span><br>$ tar xzvf /path/to/&lt;FILE&gt;.tar.gz<br><br><span class="hljs-comment"># 移动</span><br>$ sudo <span class="hljs-built_in">cp</span> docker/* /usr/bin/<br></code></pre></td></tr></table></figure><ol start="3"><li>加入systemctl服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim /etc/systemd/system/docker.service<br></code></pre></td></tr></table></figure><blockquote><p>下面安装的是docker 23.0.0</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Unit]<br>  Description=Docker Application Container Engine<br>  Documentation=https://docs.docker.com<br>  After=network-online.target docker.socket<br>  Wants=network-online.target<br><br>  [Service]<br>  Type=notify<br>  ExecStart=/usr/bin/dockerd<br>  ExecReload=/bin/kill -s HUP $MAINPID<br>  KillMode=process<br>  Restart=on-failure<br>  ExecReload=/bin/kill -s HUP $MAINPID<br>  LimitNOFILE=infinity<br>  TimeoutStartSec=0<br><br>  [Install]<br>  WantedBy=multi-user.target<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">chmod</span> +x /etc/systemd/system/docker.service<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 重载配置</span><br>$ systemctl daemon-reload<br><br><span class="hljs-comment"># 加入docker服务</span><br>systemctl <span class="hljs-built_in">enable</span> docker<br><br><span class="hljs-comment"># 启动docker</span><br>systemctl start docker<br><br><span class="hljs-comment"># status</span><br>systemctl status docker<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://docs.docker.com/engine/install/binaries/">docs.docker.com&#x2F;docker的二进制安装</a></p>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何制作多架构镜像</title>
    <link href="/2023/04/18/docker/%E5%88%B6%E4%BD%9C%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F/"/>
    <url>/2023/04/18/docker/%E5%88%B6%E4%BD%9C%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="方式一、使用buildx"><a href="#方式一、使用buildx" class="headerlink" title="方式一、使用buildx"></a>方式一、使用buildx</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文件目录</span><br><span class="hljs-comment"># bin目录是go程序编译结果 go build GOOS=linx GOARCH=amd64 \ GOARCH=arm64</span><br>.<br>├── Dockerfile<br>├── README.md<br>├── bin<br>│   ├── amd64<br>│   │   └── tool<br>│   └── arm64<br>│       └── tool<br>├── golang<br>│   ├── go.mod<br>│   └── main.go<br>└── sh<br>    └── start.sh<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基础架构就是支持多架构的 https://hub.docker.com/_/alpine/tags</span><br>FROM --platform=<span class="hljs-variable">$TARGETPLATFORM</span> alpine:3.18.4<br><br>WORKDIR /app<br><br>ARG TARGETPLATFORM<br>ARG TARGETARCH<br><br><span class="hljs-comment"># 将对应架构的go程序放在app目录</span><br>COPY bin/<span class="hljs-variable">$TARGETARCH</span>/* /app<br><br><span class="hljs-comment"># 镜像启动脚本</span><br>COPY sh/start.sh /app<br><br>RUN <span class="hljs-built_in">chmod</span> +x /app/start.sh<br><br><span class="hljs-comment"># ENTRYPOINT无法被覆盖,CMD可以被覆盖,使用CMD是为了方便helm包安装镜像时候更改启动指令</span><br>CMD [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;/app/start.sh&quot;</span>] <br></code></pre></td></tr></table></figure><h3 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker配置文件如下</span><br>/root/.docker/config.json<br>/etc/docker/daemon.json<br></code></pre></td></tr></table></figure><h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建一个新的 buildx 构建器，并将其设置为当前正在使用的构建器</span><br><span class="hljs-comment"># 以便在运行 Docker 构建命令时可以使用该构建器进行构建</span><br><span class="hljs-comment"># 通过 network=host 指定共享主机网络</span><br>$ docker buildx create --name builder --config /etc/buildkit/buildkitd.toml \<br>    --platform linux/arm64,linux/amd64 \<br>    --append --driver-opt network=host --use<br><br><span class="hljs-comment"># 开始构建</span><br>$ docker buildx build -t registry.my.net/develop/tool:v0.0.1 --platform=linux/arm64,linux/amd64 . --push<br></code></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li><p>私有库ssl验证 (<code>docker login my.net</code>),配置文件<code>/root/.docker/config.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br> <span class="hljs-attr">&quot;auths&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;registry.my.net&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>             <span class="hljs-attr">&quot;auth&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;xxx&quot;</span><br>         <span class="hljs-punctuation">&#125;</span><br>     <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>绕过私有库ssl验证(experimental是开启实验功能,buildkit开启多架构功能),配置文件<code>/etc/docker/daemon.json</code></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>     <span class="hljs-attr">&quot;insecure-registries&quot;</span> <span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-string">&quot;registry.my.net&quot;</span> <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>     <span class="hljs-attr">&quot;experimental&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span> <br>     <span class="hljs-attr">&quot;features&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>         <span class="hljs-attr">&quot;buildkit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br>     <span class="hljs-punctuation">&#125;</span><br> <span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>docker buildx绕过ssl验证,配置文件<code>/etc/buildkit/buildkitd.toml</code></p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs toml"><span class="hljs-section">[registry.&quot;registry.my.net&quot;]</span><br> <span class="hljs-attr">http</span> = <span class="hljs-literal">true</span><br> <span class="hljs-attr">insecure</span> = <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="方式二、使用manifest创建清单"><a href="#方式二、使用manifest创建清单" class="headerlink" title="方式二、使用manifest创建清单"></a>方式二、使用manifest创建清单</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先制作镜像</span><br>$ docker images<br>- registry.bingosoft.net/bingokube/etcd:v3.5.0-amd64<br>- registry.bingosoft.net/bingokube/etcd:v3.5.0-arm64<br><br><span class="hljs-comment"># 制作清单</span><br>$ docker manifest create --insecure registry.bingosoft.net/bingokube/etcd:v3.5.0 registry.bingosoft.net/bingokube/etcd:v3.5.0-amd64 registry.bingosoft.net/bingokube/etcd:v3.5.0-arm64<br><br><span class="hljs-comment"># 推送清单</span><br>$ docker manifest push --insecure registry.bingosoft.net/bingokube/etcd:v3.5.0<br><br><span class="hljs-comment"># 查看清单</span><br>$ docker manifest inspect registry.bingosoft.net/bingokube/etcd:v3.5.0<br>&#123;<br>   <span class="hljs-string">&quot;schemaVersion&quot;</span>: 2,<br>   <span class="hljs-string">&quot;mediaType&quot;</span>: <span class="hljs-string">&quot;application/vnd.docker.distribution.manifest.list.v2+json&quot;</span>,<br>   <span class="hljs-string">&quot;manifests&quot;</span>: [<br>      &#123;<br>         <span class="hljs-string">&quot;mediaType&quot;</span>: <span class="hljs-string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,<br>         <span class="hljs-string">&quot;size&quot;</span>: 1783,<br>         <span class="hljs-string">&quot;digest&quot;</span>: <span class="hljs-string">&quot;sha256:abc&quot;</span>,<br>         <span class="hljs-string">&quot;platform&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;architecture&quot;</span>: <span class="hljs-string">&quot;amd64&quot;</span>,<br>            <span class="hljs-string">&quot;os&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span><br>         &#125;<br>      &#125;,<br>      &#123;<br>         <span class="hljs-string">&quot;mediaType&quot;</span>: <span class="hljs-string">&quot;application/vnd.docker.distribution.manifest.v2+json&quot;</span>,<br>         <span class="hljs-string">&quot;size&quot;</span>: 1576,<br>         <span class="hljs-string">&quot;digest&quot;</span>: <span class="hljs-string">&quot;sha256:abc&quot;</span>,<br>         <span class="hljs-string">&quot;platform&quot;</span>: &#123;<br>            <span class="hljs-string">&quot;architecture&quot;</span>: <span class="hljs-string">&quot;arm64&quot;</span>,<br>            <span class="hljs-string">&quot;os&quot;</span>: <span class="hljs-string">&quot;linux&quot;</span><br>         &#125;<br>      &#125;<br>   ]<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在docker之中集成kata</title>
    <link href="/2023/04/18/docker/%E5%9C%A8docker%E4%B9%8B%E4%B8%AD%E9%9B%86%E6%88%90kata/"/>
    <url>/2023/04/18/docker/%E5%9C%A8docker%E4%B9%8B%E4%B8%AD%E9%9B%86%E6%88%90kata/</url>
    
    <content type="html"><![CDATA[<h3 id="一、离线安装Docker"><a href="#一、离线安装Docker" class="headerlink" title="一、离线安装Docker"></a>一、离线安装Docker</h3><p><a href="https://weiqiangxu.github.io/2023/04/18/kubernetes/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">离线安装docker</a></p><blockquote><p><a href="https://download.docker.com/linux/static/stable/aarch64/docker-23.0.4.tgz">https://download.docker.com/linux/static/stable/aarch64/docker-23.0.4.tgz</a></p></blockquote><h3 id="二、kata-containers安装"><a href="#二、kata-containers安装" class="headerlink" title="二、kata-containers安装"></a>二、kata-containers安装</h3><ol><li>检测是否支持kata-containers</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 先查看当前架构</span><br>$ <span class="hljs-built_in">uname</span> -a<br><br><span class="hljs-comment"># Intel的处理器支持Intel VT-x技术，而AMD的处理器支持AMD SVM技术</span><br><span class="hljs-comment"># aarch64\arm64 支持 ARM Hyp</span><br><span class="hljs-comment"># 支持kvm</span><br>$ kata-runtime kata-check<br><br><span class="hljs-comment"># 输出表示支持</span><br><span class="hljs-comment"># System is capable of running Kata Containers</span><br><span class="hljs-comment"># System can currently create Kata Containers</span><br></code></pre></td></tr></table></figure><ol start="2"><li>安装教程</li></ol><p><a href="https://github.com/kata-containers/kata-containers/tree/main/docs/install">kata-containers&#x2F;docs&#x2F;install</a></p><h3 id="三、配置docker使用kata-containers"><a href="#三、配置docker使用kata-containers" class="headerlink" title="三、配置docker使用kata-containers"></a>三、配置docker使用kata-containers</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第一种方式：systemd</span><br>$ <span class="hljs-built_in">mkdir</span> -p /etc/systemd/system/docker.service.d/<br><br>$ <span class="hljs-built_in">cat</span> &lt;&lt;<span class="hljs-string">EOF | sudo tee /etc/systemd/system/docker.service.d/kata-containers.conf</span><br><span class="hljs-string">[Service]</span><br><span class="hljs-string">ExecStart=</span><br><span class="hljs-string">ExecStart=/usr/bin/dockerd -D --add-runtime kata-runtime=/usr/bin/kata-runtime --default-runtime=kata-runtime</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 第二种方式：daemon.json</span><br>$ vim /etc/docker/daemon.json<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml">&#123;<br>  <span class="hljs-attr">&quot;default-runtime&quot;:</span> <span class="hljs-string">&quot;kata-runtime&quot;</span>,<br>  <span class="hljs-attr">&quot;runtimes&quot;:</span> &#123;<br>    <span class="hljs-attr">&quot;kata-runtime&quot;:</span> &#123;<br>      <span class="hljs-attr">&quot;path&quot;:</span> <span class="hljs-string">&quot;/usr/bin/kata-runtime&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看docker支持的runtime有哪些</span><br>$ docker info | grep runtime<br></code></pre></td></tr></table></figure><h3 id="四、验证使用kata-containerd启动容器"><a href="#四、验证使用kata-containerd启动容器" class="headerlink" title="四、验证使用kata-containerd启动容器"></a>四、验证使用kata-containerd启动容器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基于kata-runtime执行</span><br>$ docker run --net=none -itd --name centos-test centos:centos7<br><br><span class="hljs-comment"># 基于runc执行</span><br><span class="hljs-comment"># --net=none 网络模式为 &quot;none&quot;，表示该容器不与任何网络相连</span><br>$ docker run --net=none --runtime=runc -itd --name centos-test1 centos:centos7<br><br><span class="hljs-comment"># 进入容器之中</span><br>$ docker <span class="hljs-built_in">exec</span> -it centos-test1  /bin/bash<br>$ docker <span class="hljs-built_in">exec</span> -it centos-test  /bin/bash<br><br><span class="hljs-comment"># 运行时为runc的内存和运行时为kata-runtime的是不一样的</span><br><span class="hljs-comment"># 运行时为runc的内存和宿主机上直接的内存是一样的</span><br>$ free -m<br><br></code></pre></td></tr></table></figure><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ul><li>OCI runtime create failed: QEMU path (&#x2F;usr&#x2F;bin&#x2F;qemu-kvm) does not exist</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install -y qemu-kvm<br></code></pre></td></tr></table></figure><ul><li>messages from qemu log: Could not access KVM kernel module: No such file or directory</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">f2进入bios界面，查找virtual字样的选项，将其开启(<span class="hljs-built_in">enable</span>)<br></code></pre></td></tr></table></figure><ul><li>sandbox interface because it conflicts with existing route</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建容器时，Docker无法为容器设置网络接口的IP地址</span><br><span class="hljs-comment"># 因为该IP地址与已经存在的路由发生了冲突</span><br><span class="hljs-comment"># 检查当前系统上的路由表和网络设置</span><br>--net=none<br></code></pre></td></tr></table></figure><ul><li>容器安全</li></ul><p>使用Docker轻量级的容器时，最大的问题就是会碰到安全性的问题，其中几个不同的容器可以互相的进行攻击，如果把这个内核给攻掉了，其他所有容器都会崩溃。<br>如果使用KVM等虚拟化技术，会完美解决安全性的问题，但响应的性能会受到一定的影响。<br>单单就Docker来说，安全性可以概括为两点： - 不会对主机造成影响 - 不会对其他容器造成影响所以安全性问题90%以上可以归结为隔离性问题。<br>而Docker的安全问题本质上就是容器技术的安全性问题，这包括共用内核问题以及Namespace还不够完善的限制： </p><ol><li>&#x2F;proc、&#x2F;sys等未完全隔离 </li><li>Top, free, iostat等命令展示的信息未隔离 </li><li>Root用户未隔离 </li><li>&#x2F;dev设备未隔离 </li><li>内核模块未隔离 </li><li>SELinux、time、syslog等所有现有Namespace之外的信息都未隔离</li></ol><ul><li>arm64 和 aarch64 是什么关系</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">arm64 和 aarch64 是同一架构的两个不同名称。<br>它们都指的是 ARMv8-A（也称为 ARMv8，或者 simply ARM64）指令集架构。<br>AArch64 是 ARMv8-A 的官方名称，而 arm64 是苹果公司用于描述其 64 位 ARM 架构（即 AArch64）的术语。<br>因此，它们只是不同的命名方式。<br></code></pre></td></tr></table></figure><ul><li>ARM Hyp 是什么来的</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">ARM Hypervisor（简称 ARM Hyp）是 ARM 公司推出的一种虚拟化技术，旨在为 ARM 架构下的虚拟化提供支持。<br>ARM Hypervisor 通过在硬件和软件层面上提供虚拟化支持，可以将多个操作系统或者虚拟机同时运行在单一的 ARM 处理器上。<br></code></pre></td></tr></table></figure><ul><li>运行时环境变量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 可以在kata-runtime模块查看到config文件</span><br><span class="hljs-comment"># kata-containers/configuration.toml的路径</span><br>$ kata-runtime kata-env<br></code></pre></td></tr></table></figure><ul><li>docker的网络知识</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有当前系统中存在的 Docker 网络</span><br>$ docker network <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 默认一共有3种网络</span><br><span class="hljs-comment"># [root@worker01 ~]# docker network ls</span><br><span class="hljs-comment"># NETWORK ID          NAME                DRIVER              SCOPE</span><br><span class="hljs-comment"># d813d4a6408a        bridge              bridge              local    桥接模式</span><br><span class="hljs-comment"># eaa62c897209        host                host                local    宿主模式</span><br><span class="hljs-comment"># 59edd3de4fde        none                null                local</span><br><br><span class="hljs-comment"># --net指定网络</span><br>$ docker run -itd --net=host  --name centos-test centos:centos7 <br><br><span class="hljs-comment"># docker run 默认使用的net网络是bridge 吗？--net=bridge 和 --net=default是不是同一个</span><br>$ docker run <span class="hljs-comment">#默认使用的网络是bridge网络，而--net=bridge 和 --net=default是同义词,它们都表示使用Docker默认的bridge网络</span><br><br><span class="hljs-comment"># Docker中的bridge模式是桥接模式，用于在多个容器之间建立网络连接</span><br><span class="hljs-comment"># host模式则是将容器直接放在宿主机的网络命名空间中，可以直接使用宿主机的网络接口和端口，端口冲突概率更大</span><br></code></pre></td></tr></table></figure><ul><li>bridge 和 host 网络有什么区别</li></ul><p>Docker支持用户自定义四种网络模式：bridge、host、overlay和macvlan。其中比较常用的是bridge和host网络，两者的区别如下：</p><ol><li>Bridge网络模式：使用Docker默认的bridge网络模式进行通信。Docker容器可以通过同一bridge网络的IP地址相互通信，同时也可以与宿主机进行通信。但是，容器之间的通信需要通过网络转发，可能会降低通信速度。</li><li>Host网络模式：使用宿主机的网络进行通信，容器会直接使用宿主机的网络接口，可以通过宿主机的IP地址进行通信，容器启动后就可以访问宿主机上的服务。但是，在Host网络模式下，容器的端口会被绑定到宿主机上，可能会导致端口冲突。<br>综上所述，Bridge网络模式适用于容器之间需要相互通信的场景，Host网络模式适用于容器需要直接访问宿主机上的服务的场景。</li></ol><ul><li><p>docker run –net&#x3D;bridge的时候出现 conflict exist route 怎么排查路由冲突</p></li><li><p>什么叫做路由冲突</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ifconfig<br><span class="hljs-comment"># 如果输出的docker0的网络接口 inet 172.17.0.1 ，还有另一个存在一个名为 `eth0` 的网络接口，其 IP 地址为 `172.17.1.100`，子网掩码为 `255.255.0.0`</span><br><span class="hljs-comment"># 那么表示冲突：ifconfig 输出有2个网络接口的inet一模一样</span><br></code></pre></td></tr></table></figure><ul><li>ifconfig输出的docker0 和eth0是什么意思</li></ul><p>ifconfig命令用于查看和配置网络接口。在Linux系统中，docker0和eth0是两个常见的网络接口，其含义如下：</p><ol><li>docker0：是Docker容器的默认网桥接口，它用于将Docker容器连接到宿主机网络上。当使用Docker创建容器时，容器会自动创建并连接到docker0网桥上，从而能够实现与宿主机以及其他容器的网络通信。</li><li>eth0：是Linux系统默认的第一个以太网接口，通常连接到物理网络上。Linux系统中的网络连接都是基于网络接口的，eth0是最常用的网络接口之一，它通常用于连接到Internet或局域网中的其他设备。</li></ol><ul><li>route -n查看的是什么东西</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 主机的路由表信息</span><br><br>$ route -n <br>$ ifconfig <br><br><span class="hljs-comment"># route -n命令显示的是网络路由表，而ifconfig命令显示的是网络接口信息，一些情况下，docker0接口可能会被添加到路由表中</span><br><span class="hljs-comment"># kata containerd和docker0都使用默认的网段172.17.0.0。这是因为它们都属于Docker网络模型的一部分</span><br><span class="hljs-comment"># 但是可以改变kata-agent或者docker容器的网段</span><br><br><span class="hljs-comment"># docker容器启动的时候</span><br>$ docker run --network=192.168.0.0/16 &lt;image_name&gt;<br>$ docker run --network=host &lt;image_name&gt;<br></code></pre></td></tr></table></figure><ul><li>docker run的时候为什么runtime更改为runc时候正常，更改为kata-runtime 却告知conflict exist route</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改为kata-runtime时，会使用一个不同的网络命名空间</span><br><span class="hljs-comment"># 而这个命名空间可能与先前运行的容器使用的命名空间冲突</span><br><span class="hljs-comment"># 在运行容器时指定一个不同的网络命名空间</span><br><span class="hljs-comment"># 默认是bridge</span><br>$ docker run --runtime=kata-runtime --network=host myimage<br></code></pre></td></tr></table></figure><ul><li>docker run 的网络命名空间是什么</li></ul><p>容器与主机或其他容器之间的网络隔离环境。每个容器都会有自己的网络命名空间（内部 IP 地址、端口等网络配置信息隔离），默认有（bridge桥接、host宿主），也可以自己创建，docker run的时候指定网络。</p><ul><li>ifconfig之中的docker0的inet是什么意思</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">inet 是 inet_address<br>Docker daemon在安装时自动创建一个虚拟网络接口docker0<br>docker0的inet地址是指docker0网桥的IP地址<br>用于容器之间和宿主机之间通信<br><br>docker0接口是一个为Docker提供网络连接的虚拟网桥<br>inet地址是Docker网络的网段地址<br>docker0的inet地址与本地网络中的某个设备的IP地址冲突，就意味着在网络中存在重复的IP地址<br></code></pre></td></tr></table></figure><ul><li>ifconfig之中的docker0的inet 的冲突表示什么意思</li></ul><p>运行Docker时，发现docker0的inet地址与本地网络中的某个设备的IP地址有冲突，那么表示Docker虚拟网络与本地网络发生了IP地址冲突。<br>这可能导致网络连接问题，容器可能无法正常访问外部网络或本地网络。为解决这个问题，可以尝试更改Docker虚拟网络的子网地址，或在本地网络中修改IP地址。</p><ul><li>docker network之中的bridge网络命名空间之中，如何查看该命名空间下的所有ip和端口</li></ul><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://zhuanlan.zhihu.com/p/109256949">什么是容器安全</a><br><a href="https://blog.gmem.cc/kata-containers-study-note">Kata Containers如何与k8s集成</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>kata</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何安装kubernetes</title>
    <link href="/2023/04/18/kubernetes/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85kubernetes/"/>
    <url>/2023/04/18/kubernetes/%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85kubernetes/</url>
    
    <content type="html"><![CDATA[<h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><p>CentOS 7.6 64bit 2核 2G * 2 ( 操作系统的版本至少在7.5以上 )</p><p><a href="https://v1-26.docs.kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/">1.环境准备之 kubernetes v1.26 CRI</a><br><a href="https://v1-26.docs.kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/">2.使用部署工具kubeadm安装 kubernetes v1.26</a></p><h4 id="1-防火墙"><a href="#1-防火墙" class="headerlink" title="1.防火墙"></a>1.防火墙</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ systemctl stop firewalld<br>$ systemctl <span class="hljs-built_in">disable</span> firewalld<br>$ systemctl status firewalld<br></code></pre></td></tr></table></figure><h4 id="2-设置主机名"><a href="#2-设置主机名" class="headerlink" title="2.设置主机名"></a>2.设置主机名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在master节点执行</span><br>$ hostnamectl set-hostname k8s-master<br><br><span class="hljs-comment"># 在其他节点执行</span><br>$ hostnamectl set-hostname k8s-node1<br><br><span class="hljs-comment"># 查看当前主机名称</span><br>$ <span class="hljs-built_in">uname</span> -a<br></code></pre></td></tr></table></figure><h4 id="3-主机域名解析"><a href="#3-主机域名解析" class="headerlink" title="3.主机域名解析"></a>3.主机域名解析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取本机在本地网络中的ip地址</span><br><span class="hljs-comment"># ifconfig输出的是 网络接口，各个网络接口</span><br><span class="hljs-comment"># 一般是ifconfig的第一个网络接口eth0的ipV4</span><br><span class="hljs-comment"># etho的全称是 Ethernet interface 0,表示第一块以太网网卡的接口</span><br><span class="hljs-comment"># 还有其他网络接口比如docker0(docker创建的虚拟网络接口用于容器之间、容器与主机通信)</span><br><span class="hljs-comment"># 网络接口lo全称是loopback：本地回环接口，主机与自己通话用的</span><br><br><span class="hljs-comment"># ifconfig的eth0的ipV4</span><br><br><span class="hljs-comment"># 注意：这里的IP地址是机器的局域网IP地址</span><br>$ <span class="hljs-built_in">cat</span> &gt;&gt; /etc/hosts &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">10.16.203.44 k8s-master</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 查看设置的内容</span><br>$ <span class="hljs-built_in">cat</span> /etc/hosts<br></code></pre></td></tr></table></figure><h4 id="4-统一时间"><a href="#4-统一时间" class="headerlink" title="4.统一时间"></a>4.统一时间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看当前时间</span><br>$ <span class="hljs-built_in">date</span><br><br><span class="hljs-comment"># ntpdate是一个程序</span><br><span class="hljs-comment"># 用于在Linux或其他类Unix操作系统中同步计算机时钟与网络时间协议（NTP）服务器的系统时间</span><br><span class="hljs-comment"># 它可以在启动时自动更新系统时间，或者手动运行以进行时间同步</span><br>$ yum install ntpdate -y<br>$ ntpdate time.windows.com<br></code></pre></td></tr></table></figure><h4 id="5-关闭selinux"><a href="#5-关闭selinux" class="headerlink" title="5.关闭selinux"></a>5.关闭selinux</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看是否安装SELinux模块</span><br><span class="hljs-comment"># rpm Linux操作系统上管理RPM软件包的命令行工具</span><br>$ rpm -q selinux-policy<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看selinux是否开启</span><br>$ getenforce<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 永久关闭selinux，需要重启</span><br><span class="hljs-comment"># 使用sed工具在/etc/selinux/config文件中查找包含“enforcing”的行并将其替换为“disabled”</span><br>$ sed -i <span class="hljs-string">&#x27;s/enforcing/disabled/&#x27;</span> /etc/selinux/config<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">SELinux（Security-Enhanced Linux） 安全机制，更为细粒度的安全策略控制<br>要查看SELinux是否启用，可以在终端输入以下命令：getenforce<br><br>Enforcing 强制模式<br>Permissive 宽容模式<br>Disabled 被禁用<br></code></pre></td></tr></table></figure><h4 id="6-关闭swap分区"><a href="#6-关闭swap分区" class="headerlink" title="6.关闭swap分区"></a>6.关闭swap分区</h4><p>Linux swap分区是一种特殊的分区，为内存不足时提供交换空间，可以将一部分硬盘空间作为虚拟内存使用。当物理内存不足时，系统将部分不常用的数据和进程暂存到swap分区中，以释放物理内存。swap分区对于提高系统的稳定性和可靠性非常重要。</p><p>要查看Linux系统中是否存在swap分区，可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 没有输出表示当前系统并没有启用swap分区</span><br>$ sudo swapon --show<br><br><span class="hljs-comment"># 关闭已经启用的swap分区</span><br>$ sudo swapoff -a<br><br><span class="hljs-comment"># 重新开启swap分区</span><br>$ sudo swapon -a<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 永久关闭swap分区，需要重启：</span><br><span class="hljs-comment"># 使用sed工具在/etc/fstab文件中查找任何包含“swap”的行</span><br><span class="hljs-comment"># 并在每行前加上“#”注释符，从而将它们全部注释掉</span><br>$ sed -ri <span class="hljs-string">&#x27;s/.*swap.*/#&amp;/&#x27;</span> /etc/fstab<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看包含swap的行是否已经注释</span><br>$ <span class="hljs-built_in">cat</span> /etc/fstab | grep swap<br></code></pre></td></tr></table></figure><h4 id="7-启用桥接网络模块的IPv6-IPv4-数据包过滤功能"><a href="#7-启用桥接网络模块的IPv6-IPv4-数据包过滤功能" class="headerlink" title="7.启用桥接网络模块的IPv6\IPv4 数据包过滤功能"></a>7.启用桥接网络模块的IPv6\IPv4 数据包过滤功能</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启用桥接网络模块的 IPv6 数据包过滤功能</span><br><span class="hljs-comment"># 启用桥接网络模块的 IPv4 数据包过滤功能</span><br><span class="hljs-comment"># 系统会在下次启动时自动加载这些参数</span><br>$ <span class="hljs-built_in">cat</span> &gt; /etc/sysctl.d/k8s.conf &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="hljs-string">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 重新加载系统参数并应用任何更改</span><br><span class="hljs-comment"># 通常用于修改系统级别的参数，例如内核参数、网络配置等</span><br>$ sysctl --system<br></code></pre></td></tr></table></figure><ol start="8"><li>安装</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果有一些工具没有安装</span><br>$ yum install bridge-utils ebtable<br>$ systemctl restart network.service<br><br><span class="hljs-comment"># 开启bridge相关的内核模块</span><br><span class="hljs-comment"># modprobe是Linux中用于加载内核模块的命令</span><br><span class="hljs-comment"># br_netfilter是Linux内核网络功能的一个模块</span><br><span class="hljs-comment"># 用于实现网络桥接口的内核网络过滤器功能</span><br>$ modprobe br_netfilter<br><br><span class="hljs-comment"># ip_forward控制Linux内核是否开启IP包转发功能</span><br><span class="hljs-comment"># 如果不开启，则无法实现网络之间的数据传输</span><br><span class="hljs-comment"># 开启ip_forward</span><br><span class="hljs-comment"># 更改为1则永久开启IP包转发功能</span><br><span class="hljs-comment"># 将下面的net.ipv4.ip_forward的一行的值更改为1</span><br><span class="hljs-comment"># 如果没有添加一行 net.ipv4.ip_forward = 1</span><br>$ <span class="hljs-built_in">cat</span> /etc/sysctl.conf | grep net.ipv4.ip_forward<br><br><span class="hljs-comment"># 刷新配置</span><br>$ sysctl -p<br><br><span class="hljs-comment"># 验证更改是否成功</span><br>$ sysctl -a | grep net.ipv4.ip_forward<br></code></pre></td></tr></table></figure><h3 id="二、安装二进制程序"><a href="#二、安装二进制程序" class="headerlink" title="二、安装二进制程序"></a>二、安装二进制程序</h3><h4 id="1-containerd安装"><a href="#1-containerd安装" class="headerlink" title="1.containerd安装"></a>1.containerd安装</h4><p><a href="https://weiqiangxu.github.io/2023/05/06/k8s/containerd%E5%AE%89%E8%A3%85/">containerd v1.7.0 的安装</a></p><p>更改镜像地址 &#x2F;etc&#x2F;containerd&#x2F;config.yml:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 注意这里因为网络原因更改sanbox镜像地址否则会无法kubeadm init</span><br>[<span class="hljs-string">plugins.&quot;io.containerd.grpc.v1.cri&quot;</span>]<br>  <span class="hljs-string">sandbox_image</span> <span class="hljs-string">=</span> <span class="hljs-string">&quot;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-添加kubernetes镜像源"><a href="#2-添加kubernetes镜像源" class="headerlink" title="2.添加kubernetes镜像源"></a>2.添加kubernetes镜像源</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意下面的mirrors是区分架构的</span><br><span class="hljs-comment"># 查看当前机器的架构</span><br>$ <span class="hljs-built_in">arch</span><br><br><span class="hljs-comment"># 访问地址 https://mirrors.aliyun.com/kubernetes/yum/repos 获取所有架构镜像源</span><br><span class="hljs-comment"># 更改下面的 baseurl</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这里需要yum工具</span><br><span class="hljs-comment"># 注意执行之前确保baseurl后面的镜像源架构是否匹配</span><br>$ <span class="hljs-built_in">cat</span> &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; <span class="hljs-string">EOF</span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=0</span><br><span class="hljs-string">repo_gpgcheck=0</span><br><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 更新缓存</span><br>$ yum clean all<br>$ yum makecache<br></code></pre></td></tr></table></figure><h4 id="3-安装kubeadm-v1-27-1-kubelet-v1-27-1-kubectl-v1-27-1"><a href="#3-安装kubeadm-v1-27-1-kubelet-v1-27-1-kubectl-v1-27-1" class="headerlink" title="3.安装kubeadm v1.27.1\kubelet v1.27.1\kubectl v1.27.1"></a>3.安装kubeadm v1.27.1\kubelet v1.27.1\kubectl v1.27.1</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在线安装</span><br>$ yum install -y kubelet-1.27.1 kubeadm-1.27.1 kubectl-1.27.1<br><br><span class="hljs-comment"># 启用kubelet服务,开机自启动</span><br>$ systemctl <span class="hljs-built_in">enable</span> kubelet<br><br>$ kubeadm version -o json<br>$ kubelet --version<br>$ kubectl version -o json<br><br><span class="hljs-comment"># 移除kubelet的CNI网络插件设置</span><br><span class="hljs-comment"># 文件`/var/lib/kubelet/kubeadm-flags.env`中</span><br><span class="hljs-comment"># 将所有的`--network-plugin=cni`字符串替换为空字符串</span><br>$ sed -i <span class="hljs-string">&#x27;s/--network-plugin=cni//&#x27;</span> /var/lib/kubelet/kubeadm-flags.env<br>$ systemctl restart kubelet<br><br><span class="hljs-comment"># 配置在Kubernetes集群中使用Flannel网络插件时的CNI插件参数</span><br><span class="hljs-comment"># Flannel是一种软件定义网络（SDN）解决方案，它使用虚拟网络来连接容器和节点</span><br><span class="hljs-comment"># 需要在集群中的每个节点上配置Flannel CNI插件参数</span><br><span class="hljs-comment"># 以便容器运行环境能够正确使用Flannel网络插件</span><br>$ <span class="hljs-built_in">mkdir</span> -p /etc/cni/net.d<br>$ <span class="hljs-built_in">cat</span> &gt; /etc/cni/net.d/10-flannel.conf &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;name&quot;: &quot;cbr0&quot;,</span><br><span class="hljs-string">  &quot;cniVersion&quot;: &quot;0.2.0&quot;,</span><br><span class="hljs-string">  &quot;type&quot;: &quot;flannel&quot;,</span><br><span class="hljs-string">  &quot;delegate&quot;: &#123;</span><br><span class="hljs-string">    &quot;isDefaultGateway&quot;: true</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125; </span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><p>如果你想要离线安装，二进制文件下载可以访问<a href="https://kubernetes.io/releases/download/">Kubernetes文档&#x2F;入门&#x2F;下载Kubernetes</a> 或者 <a href="https://www.downloadkubernetes.com/">https://www.downloadkubernetes.com/</a>，kubeadm和kubectl可以直接离线二进制文件移动至&#x2F;usr&#x2F;bin完成安装，而kubelet需要systemend注册，比较麻烦可以通过离线下载rpm包的方式进行安装.详细说明查看 <a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/kubelet-integration/#the-kubelet-drop-in-file-for-systemd">kubelet 的 systemd drop-in 文件</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 如果需要离线安装建议下载rpm包</span><br>$ sudo yum install yum-utils<br>$ sudo yumdownloader --resolve kubelet-1.27.1 kubeadm-1.27.1 kubectl-1.27.1<br><br><span class="hljs-comment"># 下载后所有的kubelet-1.27.1-0.x86_64.rpm\kubeadm-1.27.1-0.x86_64.rpm等</span><br><span class="hljs-comment"># 以及libnetfilter_cthelper-1.0.0-11.el7.x86_64.rpm之类的依赖</span><br><span class="hljs-comment"># 手动安装文件夹下面所有的rpm包</span><br>$ sudo rpm -ivh *.rpm<br>$ systemctl status kubelet<br></code></pre></td></tr></table></figure><h4 id="4-安装CNI插件"><a href="#4-安装CNI插件" class="headerlink" title="4.安装CNI插件"></a>4.安装CNI插件</h4><p>CNI插件是二进制文件移动到系统环境变量里面完成安装，各个架构下的各个版本下载可以访问<a href="https://github.com/containernetworking/plugins/releases">github.com&#x2F;containernetworking&#x2F;plugins</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># https://github.com/containernetworking/plugins/releases</span><br><span class="hljs-comment"># 进入下载页根据架构选择安装包</span><br>$ <span class="hljs-built_in">arch</span><br>$ aarch64<br><br><span class="hljs-comment"># AArch64是一种ARMv8架构</span><br>$ wget https://github.com/containernetworking/plugins/releases/download/v1.2.0/cni-plugins-linux-arm64-v1.2.0.tgz<br><br><span class="hljs-comment"># 解压至/opt/cni/bin/</span><br>$ tar xvf cni-plugins-linux-arm64-v1.2.0.tgz -C /opt/cni/bin/<br><br><span class="hljs-comment"># or 先解压，后移动bin,注意这个插件很重要</span><br>$ <span class="hljs-built_in">mv</span> /home/cni-plugins-linux-arm64-v1.2.0/* /opt/cni/bin/<br></code></pre></td></tr></table></figure><h4 id="6-kubeadm初始化集群"><a href="#6-kubeadm初始化集群" class="headerlink" title="6.kubeadm初始化集群"></a>6.kubeadm初始化集群</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看k8s所需的镜像</span><br>$ kubeadm config images list<br><br><span class="hljs-comment"># 可以提前拉好镜像</span><br>$ kubeadm config images pull --image-repository registry.aliyuncs.com/google_containers<br><br><span class="hljs-comment"># 部署k8s的master节点</span><br><span class="hljs-comment"># apiserver-advertise-address更改为部署master的节点的</span><br><span class="hljs-comment"># 局域网IP地址(默认值是本地网络接口中第一个非回环地址,使用ifconfig查看所有网络接口)</span><br><span class="hljs-comment"># pod-network-cidr 集群中Pod的IP地址段 常用的有10.244.0.0/16</span><br><span class="hljs-comment"># service-cidr.集群中Service的IP地址段.默认为10.96.0.0/12</span><br>$ kubeadm init \<br>  --apiserver-advertise-address=192.168.18.100 \<br>  --image-repository registry.aliyuncs.com/google_containers \<br>  --kubernetes-version v1.27.1 \<br>  --service-cidr=10.96.0.0/12 \<br>  --pod-network-cidr=10.244.0.0/16<br><br><br><span class="hljs-comment"># 可以使用简单版本 ,apiserver-advertise-address使用默认值</span><br><span class="hljs-comment"># 注意v1.27.1搭配docker需要额外安装cri-dockerd </span><br>$ kubeadm init \<br>  --apiserver-advertise-address=10.16.203.44 \<br>  --image-repository registry.aliyuncs.com/google_containers \<br>  --kubernetes-version v1.27.1 \<br>  --service-cidr=10.96.0.0/12 \<br>  --pod-network-cidr=10.244.0.0/16 \<br>  --v=5<br><br><span class="hljs-comment">### kubueadm init 失败的时候</span><br>$ kubeadm reset<br><br><span class="hljs-comment"># 重新init的时候带上 --v=5 查看详细</span><br><br><span class="hljs-comment"># kubeadm生成默认配置并且用来启动</span><br>$ kubeadm config <span class="hljs-built_in">print</span> init-defaults &gt; init.default.yaml<br>$ kubeadm init --config=init.default.yaml<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在你执行kubectl get ns之前拷贝一下配置</span><br><span class="hljs-comment"># 在你执行kubectl get ns之前拷贝一下配置</span><br><span class="hljs-comment"># 在你执行kubectl get ns之前拷贝一下配置</span><br><br>[root@k8s-master ~]<span class="hljs-comment"># mkdir -p $HOME/.kube</span><br>[root@k8s-master ~]<span class="hljs-comment"># sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br>[root@k8s-master ~]<span class="hljs-comment"># sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br>[root@k8s-master ~]<span class="hljs-comment"># kubectl get pod</span><br><br><span class="hljs-comment"># 否则会抛异常</span><br><br>[root@k8s-master home]<span class="hljs-comment"># kubectl get pod</span><br>W0522 18:32:07.948191  915987 request.go:1480] the not healthz host trigger to upate base url: localhost:8080:6443<br>W0522 18:32:07.950403  915987 request.go:1480] the not healthz host trigger to upate base url: localhost:8080:6443<br>W0522 18:32:07.952802  915987 request.go:1480] the not healthz host trigger to upate base url: localhost:8080:6443<br>W0522 18:32:07.955076  915987 request.go:1480] the not healthz host trigger to upate base url: localhost:8080:6443<br>W0522 18:32:07.957487  915987 request.go:1480] the not healthz host trigger to upate base url: localhost:8080:6443<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@i-C5B261D3 home]<span class="hljs-comment"># kubeadm version</span><br>kubeadm version: &amp;version.Info&#123;Major:<span class="hljs-string">&quot;1&quot;</span>, Minor:<span class="hljs-string">&quot;22&quot;</span>, GitVersion:<span class="hljs-string">&quot;v1.22.21&quot;</span>, GitCommit:<span class="hljs-string">&quot;ca62f64bd6397f9ab41f68c22d2d48d87d8edb91&quot;</span>, GitTreeState:<span class="hljs-string">&quot;clean&quot;</span>, BuildDate:<span class="hljs-string">&quot;2023-01-15T13:33:59Z&quot;</span>, GoVersion:<span class="hljs-string">&quot;go1.17.1&quot;</span>, Compiler:<span class="hljs-string">&quot;gc&quot;</span>, Platform:<span class="hljs-string">&quot;linux/arm64&quot;</span>&#125;<br><br><br><span class="hljs-comment"># 这个不知道为啥 </span><br><span class="hljs-comment"># 为啥 kube-controller-manager 和 kube-scheduler 是Exited的状态</span><br>[root@k8s-master home]<span class="hljs-comment"># crictl ps -a</span><br>CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID<br>d529ea99a5dda       20654f2150dd5       6 seconds ago       Exited              kube-controller-manager   2                   26d5a6aaca513<br>bcb291b686f32       717e2b2b33bd0       6 seconds ago       Exited              kube-scheduler            16                  93a27ed44a6fb<br>efed94a74ba8c       78d0a9e0b092c       17 seconds ago      Running             kube-apiserver            2                   48c0c294eeeca<br>924e523f0b13c       2252d5eb703b0       17 seconds ago      Running             etcd                      4                   0fe680e794e71<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 生成的 init.default.yaml 配置</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta3</span><br><span class="hljs-attr">bootstrapTokens:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">groups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">system:bootstrappers:kubeadm:default-node-token</span><br>  <span class="hljs-attr">token:</span> <span class="hljs-string">abcdef.0123456789abcdef</span><br>  <span class="hljs-attr">ttl:</span> <span class="hljs-string">24h0m0s</span><br>  <span class="hljs-attr">usages:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">signing</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">authentication</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">InitConfiguration</span><br><span class="hljs-attr">localAPIEndpoint:</span><br>  <span class="hljs-comment"># 1.更改为当前局域网IP地址</span><br>  <span class="hljs-attr">advertiseAddress:</span> <span class="hljs-number">10.16</span><span class="hljs-number">.203</span><span class="hljs-number">.44</span><br>  <span class="hljs-attr">bindPort:</span> <span class="hljs-number">6443</span><br><span class="hljs-attr">nodeRegistration:</span><br>  <span class="hljs-comment"># 2.更改CRI，默认是docker如果用containerd需要更改</span><br>  <span class="hljs-attr">criSocket:</span> <span class="hljs-string">/run/containerd/containerd.sock</span><br>  <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>  <span class="hljs-comment"># 3.更改为hostname</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">k8s-master</span><br>  <span class="hljs-attr">taints:</span> <span class="hljs-literal">null</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiServer:</span><br>  <span class="hljs-attr">timeoutForControlPlane:</span> <span class="hljs-string">4m0s</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta3</span><br><span class="hljs-attr">certificatesDir:</span> <span class="hljs-string">/etc/kubernetes/pki</span><br><span class="hljs-attr">clusterName:</span> <span class="hljs-string">kubernetes</span><br><span class="hljs-attr">controllerManager:</span> &#123;&#125;<br><span class="hljs-attr">dns:</span> &#123;&#125;<br><span class="hljs-attr">etcd:</span><br>  <span class="hljs-attr">local:</span><br>    <span class="hljs-attr">dataDir:</span> <span class="hljs-string">/var/lib/etcd</span><br><span class="hljs-comment"># 4.更改镜像为国内镜像</span><br><span class="hljs-attr">imageRepository:</span> <span class="hljs-string">registry.aliyuncs.com/google_containers</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterConfiguration</span><br><span class="hljs-comment"># 5.更改目标kubernetes版本</span><br><span class="hljs-attr">kubernetesVersion:</span> <span class="hljs-number">1.22</span><span class="hljs-number">.0</span><br><span class="hljs-attr">networking:</span><br>  <span class="hljs-attr">dnsDomain:</span> <span class="hljs-string">cluster.local</span><br>  <span class="hljs-comment"># 6.设置集群中Pod的IP地址段</span><br>  <span class="hljs-attr">podSubnet:</span> <span class="hljs-number">172.16</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/16</span><br>  <span class="hljs-comment"># 7.设置集群中Service的IP地址段</span><br>  <span class="hljs-attr">serviceSubnet:</span> <span class="hljs-number">10.96</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/12</span><br><span class="hljs-attr">scheduler:</span> &#123;&#125;<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 执行初始化集群，如果已经初始化集群的则 kubeadm reset 一下</span><br><span class="hljs-comment"># 注意：kubeadm reset 不会删除 $HOME/.kube</span><br><span class="hljs-comment"># 所以 kubeadm reset之后手动删除 $HOME/.kube</span><br>$ kubeadm init --config=init.default.yaml<br></code></pre></td></tr></table></figure><blockquote><p> kubeadm reset之后手动删除 $HOME&#x2F;.kube</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看集群所有容器</span><br>$ crictl ps -a<br></code></pre></td></tr></table></figure><blockquote><p> 为啥 <code>ctr c list</code> 查看不到k8s的所有容器呢</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看contianerd是否正常</span><br><span class="hljs-comment"># 可能看到/etc/containerd/config.yml的sandbox_image pull fail</span><br><span class="hljs-comment"># 可以改成 registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5</span><br>$ journalctl -xeu containerd --no-pager<br><br><span class="hljs-comment"># 监听containerd</span><br>$ journalctl -xeu kubelet -f<br>$ journalctl -xeu containerd -f<br><br><span class="hljs-comment"># 查看是否有containerd的镜像启动</span><br>$ ctr --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/#docker">k8s v1.27.1默认移除dockershim，需要安装cri-dockerd</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建成功输出</span><br>$ Your Kubernetes control-plane has initialized successfully!<br><br>$ kubeadm <span class="hljs-built_in">join</span> 192.168.1.1:6443 --token xxx.xx \<br>    --discovery-token-ca-cert-hash sha256:xxx<br></code></pre></td></tr></table></figure><h4 id="7-配置kubectl环境"><a href="#7-配置kubectl环境" class="headerlink" title="7.配置kubectl环境"></a>7.配置kubectl环境</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 配置信息指定Kubernetes API的访问地址、认证信息、命名空间、资源配额以及其他配置参数</span><br>$ <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$HOME</span>/.kube<br><br><span class="hljs-comment"># 将admin.conf复制到当前用户的$HOME/.kube/config</span><br><span class="hljs-comment"># kubectl命令在使用时默认使用该文件</span><br><span class="hljs-comment"># 否则使用kubectl命令时必须明确指定配置文件路径或设置环境变量</span><br>$ sudo <span class="hljs-built_in">cp</span> -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config<br><br><span class="hljs-comment"># 将配置文件的所有权赋予给当前用户</span><br>$ sudo <span class="hljs-built_in">chown</span> $(<span class="hljs-built_in">id</span> -u):$(<span class="hljs-built_in">id</span> -g) <span class="hljs-variable">$HOME</span>/.kube/config<br></code></pre></td></tr></table></figure><h3 id="三、部署集群中Flannel网络插件"><a href="#三、部署集群中Flannel网络插件" class="headerlink" title="三、部署集群中Flannel网络插件"></a>三、部署集群中Flannel网络插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看节点状态</span><br>$ kubectl get nodes<br><br><span class="hljs-comment"># 使用kubectl工具将kube-flannel.yml文件中定义的Flannel网络插件之中</span><br><span class="hljs-comment"># Deployment、DaemonSet、ServiceAccount等Kubernetes资源部署到集群中</span><br><span class="hljs-comment"># 从而为集群中的宿主机和容器、容器间提供网络互联功能</span><br>$ wget https://github.com/flannel-io/flannel/releases/download/v0.21.5/kube-flannel.yml<br>$ kubectl apply -f kube-flannel.yml<br><br><span class="hljs-comment"># 查看集群pods确认是否成功</span><br>$ kubectl get pods -n kube-system<br><br><span class="hljs-comment"># 查看集群健康状况(显示了控制平面组件</span><br><span class="hljs-comment"># Control Plane Component）的健康状态</span><br><span class="hljs-comment"># etcd/kube-apiserver/kube-controller-manager/kube-scheduler</span><br>$ kubectl get cs<br><br><span class="hljs-comment"># 显示集群的相关信息(DNS\证书\密钥等)</span><br>$ kubectl cluster-info<br></code></pre></td></tr></table></figure><p>kubectl怎么安装flannel的,新添加的节点又是如何安装flannel的呢,在文件夹&#x2F;etc&#x2F;cni&#x2F;net.d的配置是如何拷贝的呢,请访问<a href="https://zhuanlan.zhihu.com/p/450140876">K8s网络之深入理解CNI</a></p><h3 id="四、部署nginx服务测试集群"><a href="#四、部署nginx服务测试集群" class="headerlink" title="四、部署nginx服务测试集群"></a>四、部署nginx服务测试集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 部署Nginx</span><br>$ kubectl create deployment nginx --image=nginx:1.14-alpine<br><br><span class="hljs-comment"># 暴露端口</span><br>$ kubectl expose deployment nginx --port=80 --<span class="hljs-built_in">type</span>=NodePort<br><br><span class="hljs-comment"># 查看服务状态需要看到nginx服务为running</span><br>$ kubectl get pods,svc<br><br><span class="hljs-comment"># 访问nginx服务需要看到输出Welcome to nginx!</span><br>$ curl k8s-master:30185<br></code></pre></td></tr></table></figure><h3 id="五、其他节点部署服务并加入到集群之中"><a href="#五、其他节点部署服务并加入到集群之中" class="headerlink" title="五、其他节点部署服务并加入到集群之中"></a>五、其他节点部署服务并加入到集群之中</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># worker node 安装Docker/kubeadm/kubelet/kubectl</span><br><span class="hljs-comment"># master节点生成token(2小时过期)</span><br>$ kubeadm token create --print-join-command<br><br><span class="hljs-comment"># master节点生成一个永不过期的token</span><br>$ kubeadm token create --ttl 0 --print-join-command<br><br><span class="hljs-comment"># 在worker node执行</span><br><span class="hljs-comment"># --token：用于新节点加入集群的令牌</span><br><span class="hljs-comment"># --discovery-token-ca-cert-hash：用于验证令牌的证书哈希值(集群初始化生成)</span><br><span class="hljs-comment"># --control-plane：如果要将新节点添加到控制平面，则需要指定此选项</span><br><span class="hljs-comment"># --node-name：指定新节点的名称</span><br>$ kubeadm <span class="hljs-built_in">join</span> 192.168.18.100:6443 \<br>    --token xxx \<br>    --discovery-token-ca-cert-hash sha256:xxx<br></code></pre></td></tr></table></figure><h3 id="六、相关疑问"><a href="#六、相关疑问" class="headerlink" title="六、相关疑问"></a>六、相关疑问</h3><ul><li>kubeadmn如何重新初始化</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubeadm reset<br></code></pre></td></tr></table></figure><ul><li>查看pod详情</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl describe pod <span class="hljs-variable">$pod_name</span><br>$ kubectl describe pod nginx-deployment-xxx<br>$ kubectl describe pod mongodb -n NamespaceName<br></code></pre></td></tr></table></figure><ul><li>run&#x2F;flannel&#x2F;subnet.env无法找到</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 当错误是/run/flannel/subnet.env无法找到时候手动创建subnet.env内容是</span><br>$ FLANNEL_NETWORK=10.244.0.0/16<br>$ FLANNEL_SUBNET=10.244.0.1/24<br>$ FLANNEL_MTU=1450<br>$ FLANNEL_IPMASQ=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><ul><li>docker离线安装包</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">Docker离线安装包官方下载链接：<br>Docker Engine: https://docs.docker.com/engine/install/binaries/<br>Docker Compose: https://github.com/docker/compose/releases<br>Docker Machine: https://github.com/docker/machine/releases<br>注意：离线安装包的下载可能比在线安装包的下载时间更长，建议选择适合自己网络和设备的安装方式。<br></code></pre></td></tr></table></figure><ul><li>路径的docker.repo是干嘛的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc/yum.repos.d/docker.repo <br><br><span class="hljs-comment"># etc/yum.repos.d/docker.repo 是一个yum源配置文件，用于添加docker的官方仓库到yum源中。</span><br><span class="hljs-comment"># 通过该文件，可以使用yum命令在CentOS/RHEL系统中安装、更新、卸载docker软件包</span><br></code></pre></td></tr></table></figure><ul><li><p>ebtables  和bridge-utils 是干嘛的</p><p> ebtables是一种基于Linux内核的防火墙软件，可以实现在数据包到达网络接口之前或之后对其进行过滤、修改等操作。ebtables是专门用于网桥设备的防火墙，可以识别和处理以太网帧，可以基于MAC地址、VLAN标签等进行过滤和转发操作。</p><p> bridge-utils是一组用于配置和管理Linux内核中的网络桥设备的命令行工具。它可以进行网桥的创建、删除、配置等操作。bridge-utils提供了一些命令行工具，例如brctl，可以用来查询、设置和管理网络桥接口，如添加和删除网桥、添加和删除网桥端口、设置网桥参数等。通过bridge-utils，用户可以方便地搭建以太网桥接网络，实现不同物理网络间的数据转发和通信。</p></li><li><p>Failed to download metadata for repo ‘docker-ce-stable</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /etc/yum.repos.d<br>$ <span class="hljs-built_in">rm</span> -rf docker*<br>$ yum update<br>$ yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure><ul><li>yum-config-manager –add-repo干嘛用的</li></ul><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">yum-<span class="hljs-built_in">config</span>-manager <span class="hljs-comment">--add-repo用于添加一个新的yum软件源地址，并将其保存在yum配置文件中</span><br>以便yum命令可以从该软件源中下载和安装软件包。该命令可以帮助用户获得更多的软件源<br>以便在软件包依赖项解决方案中更好地满足其需求。<br></code></pre></td></tr></table></figure><ul><li>kubueadm 的–pod-network-cidr是什么</li></ul><p>“kubeadm –pod-network-cidr” 是一个命令行参数，用于指定 Kubernetes 集群中 Pod 网络的 CIDR 范围。这个参数需要在初始化 Kubernetes 集群时使用，在部署网络插件时使用。Pod 网络 CIDR 是一个 IP 地址段，用于定义 Kubernetes 集群中 Pod 之间通信的网络地址。这个 CIDR 范围定义了 Kubernetes 集群中 Pod 网络的 IP 地址。常见的 CIDR 范围包括 10.244.0.0&#x2F;16、172.16.0.0&#x2F;16 等。正确设置 Pod 网络 CIDR 很重要，因为它对 Kubernetes 集群的网络和通信架构有重要的影响。</p><ul><li>kuernetes.repo</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># repo地址</span><br><span class="hljs-built_in">cat</span> /etc/yum.repos.d/kubernetes.repo<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> &lt;&lt; <span class="hljs-string">EOF &gt; /etc/yum.repos.d/kubernetes.repo </span><br><span class="hljs-string">[kubernetes]</span><br><span class="hljs-string">name=Kubernetes</span><br><span class="hljs-string">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="hljs-string">enabled=1</span><br><span class="hljs-string">gpgcheck=1</span><br><span class="hljs-string">repo_gpgcheck=1</span><br><span class="hljs-string">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="hljs-string">EOF</span><br></code></pre></td></tr></table></figure><ul><li>kube-flannel是干嘛的</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">kube-flannel是一个CNI插件，用于为Kubernetes集群创建和管理网络。<br>它提供了一种简单而有效的方法，让容器在不同节点上进行通信，而无需手动配置网络。<br>kube-flannel使用VXLAN或UDP封装技术来创建一个覆盖整个集群的扁平网络，<br>使得Kubernetes Pod能够互相通信，同时确保网络性能的高效和可靠性。<br></code></pre></td></tr></table></figure><ul><li>k8s的控制平面有哪些</li></ul><ol><li>kube-apiserver：Kubernetes API服务器，提供Kubernetes API的访问入口，以及对Kubernetes内部对象的认证、授权和验证。</li><li>etcd：Kubernetes使用etcd作为其默认的分布式键值存储系统，用于存储Kubernetes集群的所有配置数据、元数据和状态信息。</li><li>kube-scheduler：负责将新创建的Pod调度到集群中的Node上，选择最佳的Node来运行Pod。</li><li>kube-controller-manager：Kubernetes控制器管理器，包含了多个控制器，用于自动化管理Kubernetes集群中的各种资源和对象。</li><li>cloud-controller-manager：云控制器管理器，负责管理云平台上的资源，如EC2、ELB等，并将这些资源与Kubernetes集群进行集成。</li></ol><blockquote><p>这些组件共同组成了Kubernetes控制平面，负责管理和控制整个Kubernetes集群的运行状态。</p></blockquote><ul><li>检查 IP 为 192.168.1.1 的计算机的端口 80 是否开放</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ yum install telnet<br>$ telnet 192.168.1.1 80<br></code></pre></td></tr></table></figure><ul><li>kubectl get svc的输出解释</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ NAME：Service名称。<br>$ TYPE：Service类型。通常有ClusterIP、NodePort、LoadBalancer和ExternalName四种类型。<br>$ CLUSTER-IP：Service的Cluster IP地址。<br>$ EXTERNAL-IP：Service的外部IP地址（仅适用于LoadBalancer类型）。<br>$ PORT(S)：Service暴露的端口号和协议。<br>$ AGE：Service被创建后的时间。<br><br>例如，以下是一段`kubectl get svc`命令的输出结果：<br><br>NAME           TYPE           CLUSTER-IP      EXTERNAL-IP     PORT(S)          AGE<br>my-service     ClusterIP      10.0.0.5        &lt;none&gt;          80/TCP           5d<br>app-service    LoadBalancer   10.0.0.15       203.0.113.10   80:30000/TCP     2d<br><br>解释：<br><br>$ `my-service`是一个ClusterIP类型的Service，其Cluster IP地址为`10.0.0.5`，暴露的端口号为80/TCP。<br>$ `app-service`是一个LoadBalancer类型的Service，其Cluster IP地址为`10.0.0.15`<br>    暴露的端口号为80/TCP，同时外部IP地址为`203.0.113.10`，将请求转发到NodePort `30000`上<br></code></pre></td></tr></table></figure><ul><li>kubeadm config print init-defaults</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">kubeadm config print init-defaults 是一个命令，用于打印 kubeadm 初始化时的默认配置。<br>这个命令可以帮助用户了解 kubeadm 在默认情况下会使用哪些配置，以及这些配置如何影响 Kubernetes 集群的部署和运行。<br></code></pre></td></tr></table></figure><ul><li>containerd出现异常 failed to pull and unpack image “registry.k8s.io&#x2F;pause:3.8”</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 镜像拉取失败</span><br>$ ctr image pull registry.k8s.io/pause:3.8<br><br><span class="hljs-comment"># 需要配置sanbox为</span><br>sandbox_image = <span class="hljs-string">&quot;registry.cn-hangzhou.aliyuncs.com/google_containers/pause:3.5&quot;</span><br></code></pre></td></tr></table></figure><ul><li>kubeadm init的时候监听日志</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ journalctl -xeu kubelet -f<br></code></pre></td></tr></table></figure><p><a href="https://docker-practice.github.io/zh-cn/kubernetes/setup/kubeadm.html">使用 kubeadm 部署 kubernetes(CRI 使用 containerd)</a></p><ul><li>linux怎么样验证一个端口通不通</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># telnet</span><br>$ telnet <span class="hljs-variable">$&#123;IP地址&#125;</span> <span class="hljs-variable">$&#123;端口号&#125;</span><br>$ telnet 192.168.1.10 80<br><br><span class="hljs-comment"># success</span><br>$ Connected to <span class="hljs-variable">$ip</span><br></code></pre></td></tr></table></figure><ul><li>telnet 127.0.0.1 30022 出现Connection refused</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 没有运行正在监听30022端口的服务或防火墙等安全设置阻止了连接</span><br>$ sudo firewall-cmd --state<br>$ sudo firewall-cmd --list-ports<br></code></pre></td></tr></table></figure><ul><li>只有master节点无法调度怎么办</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取节点信息</span><br>$ kubuctl get node<br><br><span class="hljs-comment"># 查看当前mster节点所有taint</span><br><span class="hljs-comment"># 输出之中所有的Taints:node.kubernetes.io/not-ready:NoExecute...</span><br>$ kubectl describe node<br><br><span class="hljs-comment"># 取消标记语法</span><br>$ kubectl taint nodes &lt;master-node-name&gt; node-role.kubernetes.io/master:NoSchedule-<br><br><span class="hljs-comment"># 取消2个标记</span><br>$ kubectl taint nodes k8s-master node.kubernetes.io/not-ready:NoExecute-<br>$ kubectl taint nodes k8s-master node.kubernetes.io/not-ready:NoSchedule-<br>$ kubectl taint nodes k8s-master node-role.kubernetes.io/master:NoSchedule-<br></code></pre></td></tr></table></figure><ul><li>k8s会默认设置Taints在主节点吗</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 给主节点打上一个Key为`node-role.kubernetes.io/master`，value为`NoSchedule`的Taint，即在主节点上设置Taints</span><br><span class="hljs-comment"># kubectl taint nodes `master-node-name` node-role.kubernetes.io/master=:NoSchedule</span><br><br>默认情况下，Kubernetes会在主节点上设置Taints。这是为了确保主节点不被普通的Pod调度和运行。<br>只有具有对应Tolerations的Pod才能被调度和运行在主节点上。<br>这可以确保主节点保持稳定和安全，防止普通的Pod对主节点产生负面影响。<br></code></pre></td></tr></table></figure><ul><li>yum怎么下载rpm安装包</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo yum install yum-utils<br>$ sudo yumdownloader --resolve docker-ce-18.06.3.ce-3.el7<br></code></pre></td></tr></table></figure><ul><li>Port 10250 is in use</li></ul><blockquote><p>$ kubeadm reset</p></blockquote><ul><li>k8s的默认CNI配置在哪里获取</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs log">默认情况下，Kubernetes使用CNI插件来管理容器网络，其中包括常见的插件如Flannel、Calico、Weave Net等。<br><br></code></pre></td></tr></table></figure><ul><li>linux 的 &#x2F;etc&#x2F;cni&#x2F;net.d&#x2F; 里面的配置是干嘛的</li></ul><p>&#x2F;etc&#x2F;cni&#x2F;net.d&#x2F;目录是用于存放Kubernetes CNI插件的配置文件的，默认情况下是在kubelet启动时从这个目录读取配置文件。Kubernetes的默认CNI插件是<code>kubelet</code>在启动时自动加载。在使用kubelet启动Kubernetes集群时，kubelet会检查<code>/etc/cni/net.d/</code>目录中是否存在<code>10-kubenet.conf</code>或<code>10-bridge.conf</code>文件。CNI插件是Kubernetes系统中用于管理网络的组件，它可以为不同的Pod分配IP地址、创建和删除网络接口等操作。在该目录下，可以指定使用哪一个CNI插件，并为该插件提供相应的配置参数，例如网络类型、IP地址池、MTU等等。不同的CNI插件有不同的配置方式，但这个目录是它们的公共配置目录。</p><ul><li>k8s安装以后有哪些服务</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># nginx是唯一的业务pod</span><br>$ kubectl get pod -A -o wide<br><br><span class="hljs-comment"># NAMESPACE      NAME                                 READY   STATUS    </span><br><span class="hljs-comment"># default        nginx-55f8fd7cfc-vjqq5               1/1     Running</span><br><span class="hljs-comment"># kube-flannel   kube-flannel-ds-fs2wf                1/1     Running</span><br><span class="hljs-comment"># kube-system    coredns-7ff77c879f-hwjtl             1/1     Running  </span><br><span class="hljs-comment"># kube-system    coredns-7ff77c879f-pqjdk             1/1     Running </span><br><span class="hljs-comment"># kube-system    etcd-k8s-master                      1/1     Running </span><br><span class="hljs-comment"># kube-system    kube-apiserver-k8s-master            1/1     Running</span><br><span class="hljs-comment"># kube-system    kube-controller-manager-k8s-master   1/1     Running</span><br><span class="hljs-comment"># kube-system    kube-proxy-5qzvn                     1/1     Running</span><br><span class="hljs-comment"># kube-system    kube-scheduler-k8s-master            1/1     Running</span><br></code></pre></td></tr></table></figure><ul><li>ifconfig 输出的 eth0是什么意思</li></ul><p>eth0是指计算机中的第一个以太网接口，通常用于连接本地网络或连接到互联网的路由器。该接口可以通过ifconfig命令进行配置和管理。</p><ul><li>ifconfig 输出的 eth0之中的 inet 和 inet6是什么意思</li></ul><p>ifconfig 输出的 eth0 中的 inet 和 inet6 是指该接口所分配的 IPv4 和 IPv6 地址。inet 是 IPv4 地址，inet6 是 IPv6 地址。这两个地址用于标识网络中的设备，以便它们可以相互通信。inet 和 inet6 地址是网络编程中常用的概念，它们分别对应着 IPv4 和 IPv6 协议，用于实现网络数据传输。</p><ul><li>couldn’t get current server API group list: Get “<a href="http://localhost:8080/api">http://localhost:8080/api</a></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;export KUBECONFIG=/etc/kubernetes/admin.conf&quot;</span> &gt;&gt; ~/.bash_profile<br>$ <span class="hljs-built_in">source</span> ~/.bash_profile<br></code></pre></td></tr></table></figure><ul><li>CRI为containerd的k8s集群如何定位异常</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ crictl ps -a<br>$ crictl logs <span class="hljs-variable">$&#123;containerdID&#125;</span><br></code></pre></td></tr></table></figure><ul><li>k8s的版本怎么看，在安装了k8s集群的环境下</li></ul><p>可以通过 <code>$ kubectl version</code> 输出结果中会有两个版本号，一个是Client Version，一个是Server Version，其中Server Version即为当前集群的Kubernetes版本号。如果使用的是kubeadm搭建的集群，也可以通过 <code>$ kubeadm version</code> 输出结果中的kubernetes版本号即为当前集群的版本号。</p><ul><li>为什么安装了containerd的机器，执行 <code>ctr c list</code> 查看不到任何东西但是 <code>crictl ps -a</code> 却可以查看到容器列表</li></ul><p>可能是因为 <code>ctr c</code> 和 <code>crictl ps</code> 使用的不同的容器运行时。<code>ctr c</code> 是使用 containerd 运行时查看容器，而<code>crictl</code> 是使用 CRI (Container Runtime Interface) 运行时查看容器。因此，如果您使用的容器运行时与 containerd 不同，那么您可能无法使用 <code>ctr c</code> 查看容器。建议您使用 CRI 运行时，使用 <code>crictl ps</code> 来查看容器。</p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/tools/kubeadm/install-kubeadm/">kubernetes.io&#x2F;zh-cn&#x2F;安装kubeadm</a><br><a href="https://download.docker.com/linux/static/stable">官方docker离线安装</a><br><a href="https://mirrors.aliyun.com/kubernetes/yum/repos/">kubernetes&#x2F;yum&#x2F;repos各个架构下的</a><br><a href="https://zhuanlan.zhihu.com/p/602370492">zhihu&#x2F;k8s 1.16.0 版本的coreDNS一直处于pending状态的解决方案</a><br><a href="https://blog.csdn.net/qq_41586875/article/details/124688043">k8s部署flannel时报failed to find plugin &#x2F;opt&#x2F;cni&#x2F;bin</a><br><a href="https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/">kubernetes.io使用kubeadm安装集群</a><br><a href="https://kubernetes.io/zh-cn/docs/reference/setup-tools/kubeadm/kubeadm-init/#without-internet-connection">离线运行kubeadm初始化集群</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>snapshot备份数据</title>
    <link href="/2023/04/18/prometheus/snapshot%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE/"/>
    <url>/2023/04/18/prometheus/snapshot%E5%A4%87%E4%BB%BD%E6%95%B0%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="一、主库搭建"><a href="#一、主库搭建" class="headerlink" title="一、主库搭建"></a>一、主库搭建</h3><ol><li>创建配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/master.yml<br>$ <span class="hljs-built_in">mkdir</span> /Users/xuweiqiang/Desktop/tmp<br></code></pre></td></tr></table></figure><ol start="2"><li>文件配置内容</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># remote write</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">1s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">1s</span><br><span class="hljs-attr">remote_write:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://slave:9090/api/v1/write&quot;</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;request_count&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/metrics&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;docker.for.mac.host.internal:6969&quot;</span>]<br></code></pre></td></tr></table></figure><ol start="3"><li>启动数据采集节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run \<br>    --name master \<br>    -d \<br>    -p 8989:9090 \<br>    --network p_net \<br>    --network-alias master \<br>    -v /Users/xuweiqiang/Desktop/tmp:/tmp \<br>    -v /Users/xuweiqiang/Desktop/master.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus \<br>    --storage.tsdb.path=/tmp \<br>    --web.enable-admin-api \<br>    --config.file=/etc/prometheus/prometheus.yml<br></code></pre></td></tr></table></figure><h3 id="二、将主库的历史数据同步过来"><a href="#二、将主库的历史数据同步过来" class="headerlink" title="二、将主库的历史数据同步过来"></a>二、将主库的历史数据同步过来</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># master</span><br>$ curl -XPOST 127.0.0.1:9090/api/v1/admin/tsdb/snapshot<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;success&quot;</span><span class="hljs-punctuation">,</span><span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;20230418T015823Z-29b962a698b24a01&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><h3 id="三、从库搭建"><a href="#三、从库搭建" class="headerlink" title="三、从库搭建"></a>三、从库搭建</h3><ol><li>创建写主机配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/slave.yml<br></code></pre></td></tr></table></figure><ol start="2"><li>写主机配置内容</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># write config</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">1s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">1s</span><br></code></pre></td></tr></table></figure><ol start="3"><li>启动写主机</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 注意:storage.tsdb.path执行快照数据</span><br><span class="hljs-comment"># 也就是执行 /api/v1/admin/tsdb/snapshot 后返回的data里面的name表示文件夹名称 </span><br><span class="hljs-comment"># 原来的prometheus的实例指向的 storage.tsdb.path/data.name</span><br>$ docker run \<br>    --name slave \<br>    -d \<br>    -p 7979:9090 \<br>    --network p_net \<br>    --network-alias slave \<br>    -v /Users/xuweiqiang/Desktop/tmp:/tmp \<br>    -v /Users/xuweiqiang/Desktop/slave.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus \<br>    --storage.tsdb.path=/tmp/snapshots/20230418T015823Z-29b962a698b24a01 \<br>    --web.enable-remote-write-receiver \<br>    --config.file=/etc/prometheus/prometheus.yml<br></code></pre></td></tr></table></figure><h3 id="四、如何保证主库数据完整"><a href="#四、如何保证主库数据完整" class="headerlink" title="四、如何保证主库数据完整"></a>四、如何保证主库数据完整</h3><p>主库执行snapshot之前，更改master.prometheus.yml的配置，remote write到slave，此刻开始所有push不过去的数据会被加入队列重试，当slave使用备份快照启动成功后，这些数据会被写入，从而保证不丢失。</p><blockquote><p>2小时内（取决于落盘时间）</p></blockquote><h3 id="五、remote-write数据完整性"><a href="#五、remote-write数据完整性" class="headerlink" title="五、remote write数据完整性"></a>五、remote write数据完整性</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /prometheus/storage</span><br><span class="hljs-keyword">package</span> remote<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWriteStorage</span><span class="hljs-params">(logger log.Logger, reg prometheus.Registerer, dir <span class="hljs-type">string</span>, flushDeadline time.Duration, sm ReadyScrapeManager)</span></span> *WriteStorage<br><br><span class="hljs-comment">// 阻塞，直到元数据被发送到远程写入端点或hardShutdownContext过期。</span><br>mw.writer.AppendMetadata(mw.hardShutdownCtx, metadata)<br><br><span class="hljs-comment">// AppendMetadata sends metadata to the remote storage. Metadata is sent in batches, but is not parallelized.</span><br><span class="hljs-comment">// 逐个发送</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *QueueManager)</span></span> AppendMetadata(ctx context.Context, metadata []scrape.MetricMetadata)<br><br><span class="hljs-comment">// 具体发送动作</span><br><span class="hljs-comment">// /Users/xuweiqiang/Documents/code/prometheus/storage/remote/queue_manager.go</span><br><span class="hljs-keyword">type</span> WriteClient <span class="hljs-keyword">interface</span> &#123;<br>    Store(context.Context, []<span class="hljs-type">byte</span>) <span class="hljs-type">error</span><br>&#125;<br><br><span class="hljs-comment">// 发送失败动作</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sendWriteRequestWithBackoff</span><span class="hljs-params">(ctx context.Context, cfg config.QueueConfig, l log.Logger, attempt <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">error</span>, onRetry <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>) <span class="hljs-type">error</span><br><br>MinBackoff: model.Duration(<span class="hljs-number">30</span> * time.Millisecond)<br>MaxBackoff: model.Duration(<span class="hljs-number">5</span> * time.Second)<br><br><span class="hljs-comment">// 发送失败以后sleep 30 * time.Millisecond然后再次重试，每次重试间隔不断double，直至最大5s，</span><br><span class="hljs-comment">// 如果一直失败，不是会跳过而是直接不再发送</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *QueueManager)</span></span> Stop()<br><br><span class="hljs-comment">// 使用远程写入会增加 Prometheus 的内存占用。大多数用户报告内存使用量增加了约 25%，但该数字取决于数据的形状</span><br><span class="hljs-comment">// 除非远程端点保持关闭超过 2 小时，否则将重试失败而不会丢失数据。2小时后，WAL会被压缩，没有发送的数据会丢失</span><br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>WAL落盘机制</li></ul><blockquote><p>是每隔2小时落盘1次还是不断地将超过2小时的数据落盘，如果是每隔2小时一次那开始和结束时间怎么计算</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">Prometheus 默认情况下是每个块的时间范围为 2 个小时。<br>当一个块完成时，它将被写入磁盘。<br>块的开始时间和结束时间是按照 Prometheus 的时间轴进行计算的。<br>例如，如果当前时间是 9:00 AM，那么 Prometheus 将从 7:00 AM 到 9:00 AM 计算该块的开始和结束时间。<br>因此，Prometheus会每隔2小时落盘，并且块的开始和结束时间是基于当前时间计算的<br></code></pre></td></tr></table></figure><ul><li>remote write 丢数据</li></ul><blockquote><p>remote write如果发送数据时候目标机器挂了，后面目标机器服务又起来了，会丢失多少数据</p></blockquote><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">prometheus间隔2h落盘在1h55min时候，打了快照，并且在2h1min之后服务才起来，那么是不是意味着这5min的数据丢失了<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/prometheus-remote-storage">yunlzheng.gitbook.io&#x2F;prometheus-book&#x2F;远程存储</a><br><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/prometheus-and-high-availability">yunlzheng.gitbook.io&#x2F;prometheus-book&#x2F;高可用方案选型</a><br><a href="https://www.robustperception.io/taking-snapshots-of-prometheus-data/">robustperception.io&#x2F;snapshot</a><br><a href="https://prometheus.io/docs/practices/remote_write/#remote-write-tuning">prometheus.io&#x2F;远程写入调整</a><br><a href="https://prometheus.io/docs/prometheus/latest/querying/api/#snapshot">prometheus.io&#x2F;如何使用快照进行数据备份</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prometheus的资源占用分析</title>
    <link href="/2023/04/13/prometheus/prometheus%E7%9A%84%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/"/>
    <url>/2023/04/13/prometheus/prometheus%E7%9A%84%E8%B5%84%E6%BA%90%E5%8D%A0%E7%94%A8%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、消耗多少内存"><a href="#一、消耗多少内存" class="headerlink" title="一、消耗多少内存"></a>一、消耗多少内存</h3><h4 id="1-怎么看当前实例消耗内存大小"><a href="#1-怎么看当前实例消耗内存大小" class="headerlink" title="1. 怎么看当前实例消耗内存大小"></a>1. 怎么看当前实例消耗内存大小</h4><p><a href="https://weiqiangxu.github.io/2023/04/12/prometheus/%E6%9F%A5%E7%9C%8Bprometheus%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/">查看prometheus占用内存大小</a></p><h4 id="2-内存消耗的来源是哪些"><a href="#2-内存消耗的来源是哪些" class="headerlink" title="2. 内存消耗的来源是哪些"></a>2. 内存消耗的来源是哪些</h4><ul><li>查询负载</li><li>指标数据（落盘机制）</li></ul><h4 id="3-影响内存消耗的配置有哪些"><a href="#3-影响内存消耗的配置有哪些" class="headerlink" title="3. 影响内存消耗的配置有哪些"></a>3. 影响内存消耗的配置有哪些</h4><ul><li><p><code>scrape_interval</code>和<code>evaluation_interval</code>：这两个参数分别控制着Prometheus的采集频率和计算频率，值越小，内存消耗越高</p></li><li><p><code>retention</code>：这个参数控制着数据的保留时间，值越大，内存消耗越高(查询范围大的时候)。<br>  默认保留数据15天也就是在磁盘超过15天的数据会被清理。<br>  –storage.tsdb.retention.time&#x3D;15d</p></li><li><p><code>chunk_size</code>：这个参数控制着每个时间序列数据块的大小，值越大，内存消耗越高。<br>  –storage.tsdb.max-block-duration（MaxBlockDuration）TSDB 存储时每个块的最大时间范围。默认值为 2 小时<br>  –storage.tsdb.max-block-chunk-segment-size(MaxBlockChunkSegmentSize)默认值为32MB<br>控制每个块（block）中的chunk在持久化时是否分割成多个片段（segment），以及每个片段的大小</p></li><li><p><code>query.max-samples</code>：这个参数控制着每个查询返回的最大样本数，值越大，内存消耗越高。<br>   指定了查询语句返回的最大样本数。它是一个安全机制，用于避免由于查询错误或者滥用，导致过多的样本数被返回<br>   参数–query.max-samples默认值为5000w</p></li></ul><h4 id="3-怎样做可以降低内存消耗"><a href="#3-怎样做可以降低内存消耗" class="headerlink" title="3. 怎样做可以降低内存消耗"></a>3. 怎样做可以降低内存消耗</h4><ul><li>落盘机制（缩小数据块加速落盘）</li><li>缩小指标数量</li><li>限制查询时间范围</li><li>减少标签数量</li></ul><h4 id="4-场景模拟"><a href="#4-场景模拟" class="headerlink" title="4. 场景模拟"></a>4. 场景模拟</h4><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">假设有<span class="hljs-number">1000</span>个指标，每个指标有<span class="hljs-number">10</span>个标签，每个标签有<span class="hljs-number">10</span>种值类型，消耗的内存大小<br><br><span class="hljs-built_in">Number</span> <span class="hljs-variable">of</span> <span class="hljs-variable">Time</span> <span class="hljs-built_in">Series</span><span class="hljs-punctuation">(</span>时间序列数量<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><span class="hljs-number">100</span><span class="hljs-operator">,</span><span class="hljs-number">000</span><br><span class="hljs-variable">Average</span> <span class="hljs-variable">Labels</span> <span class="hljs-variable">Per</span> <span class="hljs-variable">Time</span> <span class="hljs-built_in">Series</span><span class="hljs-punctuation">(</span>每个时间序列上平均的标签数<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><span class="hljs-number">10</span><br><span class="hljs-built_in">Number</span> <span class="hljs-variable">of</span> <span class="hljs-built_in">Unique</span> <span class="hljs-built_in">Label</span> <span class="hljs-variable">Pairs</span><span class="hljs-punctuation">(</span>一个时间序列的标签组合数量<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><span class="hljs-number">100</span><br><span class="hljs-variable">Average</span> <span class="hljs-variable">Bytes</span> <span class="hljs-variable">per</span> <span class="hljs-built_in">Label</span> <span class="hljs-variable">Pair</span><span class="hljs-punctuation">(</span>平均每个标签对所占用的字节数<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><span class="hljs-number">20</span><br><span class="hljs-variable">Scrape</span> <span class="hljs-built_in">Interval</span><span class="hljs-punctuation">(</span>拉取间隔<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><span class="hljs-number">15</span><span class="hljs-variable">s</span><br><span class="hljs-variable">Bytes</span> <span class="hljs-variable">per</span> <span class="hljs-variable">Sample</span><span class="hljs-punctuation">(</span>每个样本值所占用的字节数<span class="hljs-punctuation">)</span><span class="hljs-operator">:</span><span class="hljs-number">4</span><br><br>理论上综合消耗内存：<span class="hljs-number">827</span><span class="hljs-variable">MB</span><br></code></pre></td></tr></table></figure><h3 id="二、磁盘占用多少"><a href="#二、磁盘占用多少" class="headerlink" title="二、磁盘占用多少"></a>二、磁盘占用多少</h3><h4 id="1-影响磁盘损耗的因素有："><a href="#1-影响磁盘损耗的因素有：" class="headerlink" title="1. 影响磁盘损耗的因素有："></a>1. 影响磁盘损耗的因素有：</h4><ul><li>样本数据的数量</li><li>每个数据点的标签数量和标签值的长度</li><li>数据点的采样频率</li><li>存储时间范围</li></ul><h4 id="2-场景"><a href="#2-场景" class="headerlink" title="2. 场景"></a>2. 场景</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">如果每5秒钟采集 2000个样本，每个样本在磁盘占用大约1~2字节，假设2字节<br>那么30天大概需要 0.96GB<br><br>2000 * (86400 / 5) * 30 / (1024*1024*1024) = 0.96GB<br></code></pre></td></tr></table></figure><h3 id="三、CPU消耗情况"><a href="#三、CPU消耗情况" class="headerlink" title="三、CPU消耗情况"></a>三、CPU消耗情况</h3><h4 id="1-怎么查看cpu消耗"><a href="#1-怎么查看cpu消耗" class="headerlink" title="1. 怎么查看cpu消耗"></a>1. 怎么查看cpu消耗</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># metrics端点查看</span><br>$ curl http://localhost:9300/metrics<br><br><span class="hljs-comment"># 指标名称</span><br>process_cpu_seconds_total<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># top命令查看</span><br>$ ps -ef | grep prometheus<br><br>$ top -p <span class="hljs-variable">$&#123;pid&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-cpu消耗大小"><a href="#2-cpu消耗大小" class="headerlink" title="2. cpu消耗大小"></a>2. cpu消耗大小</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 场景描述<br>prometheus启动时长7天左右，process_cpu_seconds_total大概是 1260.77s<br>平均每小时占用cpu 7.5秒<br></code></pre></td></tr></table></figure><h4 id="3-影响cpu消耗的因素"><a href="#3-影响cpu消耗的因素" class="headerlink" title="3. 影响cpu消耗的因素"></a>3. 影响cpu消耗的因素</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">作为一个开源的监控系统，Prometheus 的 CPU 消耗并不算特别大。<br>它的 CPU 消耗主要来源于收集数据、数据进行存储和分析以便后续的查询和报警<br> Prometheus 使用了一些高效的算法和技术，它的 CPU 消耗并不会特别高<br></code></pre></td></tr></table></figure><h4 id="4-如何降低cpu消耗"><a href="#4-如何降低cpu消耗" class="headerlink" title="4. 如何降低cpu消耗"></a>4. 如何降低cpu消耗</h4><ul><li>降低抓取频率</li><li>缩小指标种类</li><li>优化内存分配</li><li>优化查询（如时间范围）</li></ul><h3 id="四、查询优化"><a href="#四、查询优化" class="headerlink" title="四、查询优化"></a>四、查询优化</h3><h4 id="1-查询带来的内存消耗多大"><a href="#1-查询带来的内存消耗多大" class="headerlink" title="1. 查询带来的内存消耗多大"></a>1. 查询带来的内存消耗多大</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 范围查询1个月内一个指标的所有样本<br><br>假设指标每秒钟有1个样本，一个月大概有30 * 24 * 60 * 60 = 2,592,000个样本<br>假设该指标的值是64位双精度浮点数，则每个样本需要8个字节。<br>因此，查询一个月内的所有样本将需要大约20 MB的内存。<br><br>但真实的场景下，查询1个月的所有样本，不会把所有样本读取<br>会设置步长，并且设置标签可以筛选掉很多数据;<br>所以1个查询最多也就10MB不到，并发20个图表的情况下是200MB<br><br>查询消耗取决于TSDB查询性能<br></code></pre></td></tr></table></figure><h4 id="2-如何优化查询降低内存消耗"><a href="#2-如何优化查询降低内存消耗" class="headerlink" title="2. 如何优化查询降低内存消耗"></a>2. 如何优化查询降低内存消耗</h4><ul><li>缩小时间范围</li><li>查询带着具体标签值查询</li><li>多个Prometheus实例分摊查询压力</li><li>全局配置超时global.query_timeout:30s</li><li>单个查询5min以内数据并配置10s超时<br>query_name{label&#x3D;value}[5m:10s]</li></ul><h4 id="3-如何强制限制查询时间范围"><a href="#3-如何强制限制查询时间范围" class="headerlink" title="3. 如何强制限制查询时间范围"></a>3. 如何强制限制查询时间范围</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">storage.retention.time<br>历史数据存储最大时长就等于了最大的查询的时长范围<br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li><p>理论上prometheus的内存和指标等计算规则是什么</p></li><li><p>evaluation 和 scrape 是什么意思</p></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">evaluation_interval被设置为1分钟。Prometheus会在每分钟计算一次告警规则和记录规则。<br>scrape_interval被设置为15秒，表示Prometheus每15秒向job_name为prometheus的job收集监控数据<br></code></pre></td></tr></table></figure><ul><li>chunk_size是什么意思</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">一个概念，tsdb的数据块大小，以时间为单位的。<br>在prometheus的main.go之中有配置项（storate.tsdb为前缀的配置）<br>默认2小时；<br><br>1. 当查询Prometheus时，如果需要的数据超出了一个块的范围，那么Prometheus会将多个块合并成一个大块<br>然后在该大块上执行查询操作。chunk_size参数的值越小，需要合并的块的数量就越多，查询效率就越低；<br><br>2. 设置的块很大查询的时候如果需要合并数据块，又会因为合并的时间很久而降低了查询效率；<br></code></pre></td></tr></table></figure><ul><li>storage.tsdb.max-block-duration的具体意义</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">该参数确实可以影响Prometheus的落盘机制的时间，因为它决定了TSDB块文件的最大持续时间。<br>当块文件的持续时间达到该参数设置的值时，Prometheus会停止在该文件中写入新的数据，并创建一个新的块文件。<br>从而实现了落盘机制。默认情况下，该参数设置为2小时。<br>因此，可以通过调整该参数的值来控制Prometheus的落盘机制的时间<br></code></pre></td></tr></table></figure><ul><li>时间序列</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">每个指标（Metric）都有一个名称（Name）和多个标签（Label）<br>指标将与时间戳形成一个样本（Sample），它包含指标值、时间戳和标签值。<br>这些样本被存储在称为时间序列（Time Series）的数据结构中。<br>时间序列将由指标名称和标签集合唯一确定<br>每一个时间序列由指标名称和一组标签共同标识<br></code></pre></td></tr></table></figure><ul><li>prometheus理论上每个样本在磁盘之中占据多少内存</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">prometheus的存储模型是基于TSDB，影响样本在磁盘占据内存大小的因素有：<br>压缩格式、标签数量、附加属性预测、抽样和分析等；<br><br>通常情况下，一个时间序列的每个样本占用的磁盘空间大约在1-2字节左右<br></code></pre></td></tr></table></figure><ul><li>process_cpu_seconds_total指标</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">process_cpu_seconds_total是Prometheus指标名称，表示当前进程（一个应用程序）的CPU使用时间总量。<br>它是一个累加器指标，可以用来监控进程的CPU利用率和运行时间。<br>该指标记录了进程启动以来的总CPU时间，单位为秒。<br></code></pre></td></tr></table></figure><ul><li>文件拷贝data目录时候网络选择问题</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">待定...<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://www.robustperception.io/how-much-ram-does-prometheus-2-x-need-for-cardinality-and-ingestion/">官方计算prometheus理论上的内存消耗</a><br><a href="https://www.kancloud.cn/pshizhsysu/prometheus/1803792">Series在prometheus是什么概念</a><br><a href="https://yasongxu.gitbook.io/container-monitor/yi-.-kai-yuan-fang-an/di-2-zhang-prometheus/prometheus-use">yasongxu.gitbook高可用完问题-大内存问题以及容量规划</a><br><a href="http://www.xuyasong.com/?p=1601">容器监控实践—Prometheus存储机制</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
      <tag>api</tag>
      
      <tag>监控</tag>
      
      <tag>内存分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ifconfig怎么读</title>
    <link href="/2023/04/12/linux/ifconfig%E6%80%8E%E4%B9%88%E8%AF%BB/"/>
    <url>/2023/04/12/linux/ifconfig%E6%80%8E%E4%B9%88%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="一、实例"><a href="#一、实例" class="headerlink" title="一、实例"></a>一、实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># ifconfig只能查看本机的网络配置和IP地址</span><br>[root@i-33D71DFC ~]<span class="hljs-comment"># ifconfig</span><br><br><span class="hljs-comment"># 网卡名称或者叫网络接口名称: enp1s0</span><br><span class="hljs-comment"># 后面的&lt;&gt;必须要有UP才表示启用状态 如果没有启用可以使用 ip link set xxx up</span><br>enp1s0: flags=4163&lt; UP,BROADCAST 支持广播,RUNNING ,MULTICAST 支持多播 &gt;  mtu 1500 最大传输单元为1500字节（网络接口能够传输的最大数据大小）<br>        <span class="hljs-comment"># IP 地址           # 子网掩码              # 当前网络接口的广播地址</span><br>        inet 10.16.123.39  netmask 255.255.248.0  broadcast 10.16.207.255<br>        <span class="hljs-comment"># ipv6地址</span><br>        inet6 fe80::ca83:3404:d922:1960  prefixlen 64  scopeid 0x20&lt;<span class="hljs-built_in">link</span>&gt;<br>        <span class="hljs-comment"># ether查看 MAC 地址</span><br>        ether d0:0d:33:d7:1d:<span class="hljs-built_in">fc</span>  txqueuelen 1000  (Ethernet)<br>        <span class="hljs-comment"># 接受和发送的数据包数量和字节数</span><br>        RX packets 34122  bytes 612851235 (584.4 MiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 31682  bytes 5632014 (5.3 MiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 311  bytes 27368 (26.7 KiB)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 311  bytes 27368 (26.7 KiB)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500<br>        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255<br>        ether 52:54:00:0a:e9:3a  txqueuelen 1000  (Ethernet)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br></code></pre></td></tr></table></figure><h3 id="二、解释"><a href="#二、解释" class="headerlink" title="二、解释"></a>二、解释</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">执行 &quot;ifconfig&quot; 命令可以查看 Linux 系统上的网络接口信息。以下是该命令输出的一些字段及其含义：<br><br><span class="hljs-bullet">- </span>网络接口名称（例如 enp0s3）：这是网络接口的名称，每个接口都有一个唯一的名称。<br><span class="hljs-bullet">- </span>flags 属性：它告诉您接口的当前状态，如是否启用（UP）、是否支持广播（BROADCAST）、是否运行（RUNNING）和是否支持多播（MULTICAST）。<br><span class="hljs-bullet">- </span>inet 属性：它显示分配给接口的 IP 地址。<br><span class="hljs-bullet">- </span>netmask 属性：它显示子网掩码。<br><span class="hljs-bullet">- </span>ether 属性：它显示该接口的 MAC 地址。<br><span class="hljs-bullet">- </span>RX 和 TX 计数器：它们表示接受和发送的数据包数量和字节数。<br><span class="hljs-bullet">- </span>错误计数器：它们表示在传输或接收数据包时发生的错误数量。<br><span class="hljs-bullet">- </span>dropped 计数器：它们表示在传输或接收数据包时被丢弃的数据包数量。<br><span class="hljs-bullet">- </span>overruns 计数器：它们表示在传输数据包时，以高于接口处理能力的速度到达的数据包的数量。<br><span class="hljs-bullet">- </span>collisions 计数器：它们表示在传输数据包时，同一时间有多个设备试图传输数据包的数量。<br><br>通过查看这些信息，您可以了解有关每个网络接口及其配置的详细信息。<br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>linux如何查看当前机器的局域网ip</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">在Linux系统中，可以使用如下命令查看当前机器的局域网IP：<br><br>1. 打开终端，输入命令：ifconfig，查看当前机器的网络信息。<br><br>2. 在ifconfig的输出结果中，找到本地连接的IP地址，通常是以“inet”开头的一行，例如：inet 192.168.1.100。<br><br>3. 以192.168.1.100为例，该地址是当前机器的IP地址，可以通过它获取当前机器的局域网IP。<br>    假设子网掩码为255.255.255.0，则将IP地址中的最后一段改为0，即192.168.1.0，这就是当前机器所在的局域网IP地址。<br><br>如果想查看当前机器所连接的网络设备的状态，可以使用命令：ip addr show。该命令可以列出当前机器所有的网络设备及其IP地址。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>uname</title>
    <link href="/2023/04/12/linux/uname/"/>
    <url>/2023/04/12/linux/uname/</url>
    
    <content type="html"><![CDATA[<h3 id="一、实例"><a href="#一、实例" class="headerlink" title="一、实例"></a>一、实例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@i-33D71DFC home]<span class="hljs-comment"># uname -a</span><br>Linux k8s-master 4.19.90-23.4.v2101.ky10.aarch64 <span class="hljs-comment">#1 SMP Wed Mar 3 15:41:26 CST 2021 aarch64 aarch64 aarch64 GNU/Linux</span><br><br>操作系统内核版本号:4.19.90-23.4.v2101.ky10.aarch64<br>处理器架构:aarch64<br></code></pre></td></tr></table></figure><h3 id="二、如何理解"><a href="#二、如何理解" class="headerlink" title="二、如何理解"></a>二、如何理解</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">Linux myserver 4.15.0-154-generic #161-Ubuntu SMP Fri Jul 23 17:59:01 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux<br><br>- `Linux` 表示操作系统名称<br>- `myserver` 是主机名<br>- `4.15.0-154-generic` 是操作系统内核版本号<br>- `#161-Ubuntu` 是内核版本号的修订版号<br>- `SMP` 表示内核启用了多处理器支持<br>- `Fri Jul 23 17:59:01 UTC 2021` 是内核构建时间<br>- `x86_64` 表示处理器架构<br>- `GNU/Linux` 表示操作系统类型与内核类型<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>alertmanager高可用机制</title>
    <link href="/2023/04/12/prometheus/alertmanager%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/04/12/prometheus/alertmanager%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、官方推荐的高可用架构"><a href="#一、官方推荐的高可用架构" class="headerlink" title="一、官方推荐的高可用架构"></a>一、官方推荐的高可用架构</h3><p><img src="/images/prom-ha-with-am-gossip.png" alt="alertmanager集群架构图"></p><h3 id="二、如何保证消息不重复"><a href="#二、如何保证消息不重复" class="headerlink" title="二、如何保证消息不重复"></a>二、如何保证消息不重复</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">Alertmanager使用Gossip机制来解决消息在多台Alertmanager之间的传递问题。<br><br>通过在Alertmanager之间相互交流，将信息同步到所有Alertmanager的方式来避免重复发送给receiver<br><br><span class="hljs-comment"># 告警流程</span><br><br>1. 当一台Alertmanager接收到告警信息后，它会将这个信息广播给其他Alertmanager；<br>2. 其他Alertmanager也会将这个信息广播给其他Alertmanager，直到所有Alertmanager都收到了这个信息；<br>3. 其中只有一台Alertmanager会将这个告警通知发送给接收者；<br></code></pre></td></tr></table></figure><p><img src="/images/ha-alertmanager.png" alt="高可用架构示意图"></p><h3 id="三、Gossip协议"><a href="#三、Gossip协议" class="headerlink" title="三、Gossip协议"></a>三、Gossip协议</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">一种去中心化的信息传播协议<br><br># 基本思想是<br>将消息从一个节点向其他节点随机传播，直到所有节点都收到了该消息，从而实现整个网络范围内的消息传递<br>任意节点是对等的，无固定中心节点（去中心化、高可用性、可扩展性）<br><br># 应用场景<br>Gossip 协议可以应用于分布式数据库复制、分布式存储系统、大规模传感器网络等场景中<br></code></pre></td></tr></table></figure><p><img src="/images/gossip-protoctl.png" alt="Gossip协议节点通讯示意图"></p><h3 id="四、协议在Alertmanager的应用场景"><a href="#四、协议在Alertmanager的应用场景" class="headerlink" title="四、协议在Alertmanager的应用场景"></a>四、协议在Alertmanager的应用场景</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Slience</span><br><br>Alertmanager启动阶段基于Pull-based从集群其它节点同步Silence状态<br>新的Silence产生时使用Push-based方式在集群中传播Gossip信息<br><br><span class="hljs-comment"># 告警通知发送完</span><br>Push-based同步告警发送状态<br><br><span class="hljs-comment"># 集群alertmanager成员变化</span><br>成员发现、故障检测和成员列表更新等，简而言之，每个alertmanager都知道所有的alertmanager的存在<br></code></pre></td></tr></table></figure><h3 id="五、Alertmanager如何基于Gossip实现告警不重复的"><a href="#五、Alertmanager如何基于Gossip实现告警不重复的" class="headerlink" title="五、Alertmanager如何基于Gossip实现告警不重复的"></a>五、Alertmanager如何基于Gossip实现告警不重复的</h3><ol><li>首先，Alertmanager节点之间通过Gossip协议建立相互联系。每个Alertmanager节点都会维护一个Gossip池，用于存储其他节点的状态信息。</li><li>当集群之中某一个Alertmanager节点接到告警时，首先会计算该告警的Fingerprint（即告警内容的摘要），并将其作为ID使用。</li><li>然后Alertmanager将该告警的Fingerprint广播给其他Alertmanager节点。</li><li>接收到广播的Alertmanager会将该Fingerprint添加到自己的已知Fingerprint列表中。</li><li>当Alertmanager要发送一个告警通知时，会检查该告警的Fingerprint是否已经存在于已知Fingerprint列表中。如果已经存在，则不会发送该告警通知。</li></ol><blockquote><p>也就是说每一个alertmanager节点都拥有所有的告警的Fingerprint，这个Fingerprint列表就是抑制重复发送的ID</p></blockquote><h3 id="六、Alertmanager的Gossip协议有哪些特点"><a href="#六、Alertmanager的Gossip协议有哪些特点" class="headerlink" title="六、Alertmanager的Gossip协议有哪些特点"></a>六、Alertmanager的Gossip协议有哪些特点</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 高效：Gossip协议使用随机化的节点选择和增量式的消息传递方式，能够在短时间内将信息传递给集群中的所有节点。<br>2. 可靠：Gossip协议采用反馈机制和故障检测算法，能够检测并快速恢复集群中的故障节点，保证集群的稳定性和可靠性。<br>3. 去中心化：Gossip协议不依赖于任何中心节点或集中式控制器，所有节点都是平等的，能够自组织、自平衡和自适应。<br></code></pre></td></tr></table></figure><h3 id="七、Alertmanager的集群缺点"><a href="#七、Alertmanager的集群缺点" class="headerlink" title="七、Alertmanager的集群缺点"></a>七、Alertmanager的集群缺点</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 增加了复杂性：Alertmanager集群需要进行配置和管理，增加了系统复杂性。<br>2. 需要更多的资源：Alertmanager集群需要更多的资源，包括计算、存储和网络等。<br>3. 需要进行监控和日志管理：Alertmanager集群需要进行监控和日志管理，以便及时发现和解决问题。<br>5. 信息安全性：Alertmanager集群需要注意安全性，尤其是在跨网络或公共网络上运行时。<br></code></pre></td></tr></table></figure><h3 id="八、什么情况下告警仍然重复发送"><a href="#八、什么情况下告警仍然重复发送" class="headerlink" title="八、什么情况下告警仍然重复发送"></a>八、什么情况下告警仍然重复发送</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 集群中的某些节点出现网络故障（比如节点1和节点2同时接收到同一个告警，但是节点1和节点2之间无法通讯）<br></code></pre></td></tr></table></figure><h3 id="九、两台alertmanager同时接收到告警不会各自立刻发送给receiver导致重复发送吗"><a href="#九、两台alertmanager同时接收到告警不会各自立刻发送给receiver导致重复发送吗" class="headerlink" title="九、两台alertmanager同时接收到告警不会各自立刻发送给receiver导致重复发送吗"></a>九、两台alertmanager同时接收到告警不会各自立刻发送给receiver导致重复发送吗</h3><p><img src="/images/alertmanager-HA-arch.png" alt="alertmanager pipeline"></p><blockquote><p>当一个Alertmanager实例将告警通知发送给Receiver时，它会将该通知标记为“暂停发送”，同时向其他实例发送消息，告诉它们“我已经发送了这个告警通知，你们不用再发送了”。这种方式可以确保告警通知在多个实例之间被正确地合并，避免重复发送。剩余多个Alertmanager实例同时接收到相同的告警信息，并且它们之间的通信还没有完成，那么它们都会标记该告警信息为“暂停发送”，并在通信完成之后再决定由哪个实例发送该告警通知。因此，在Alertmanager中，重复发送同一告警通知的情况应该是非常少见的。</p></blockquote><h3 id="十、docker搭建alertmanager集群"><a href="#十、docker搭建alertmanager集群" class="headerlink" title="十、docker搭建alertmanager集群"></a>十、docker搭建alertmanager集群</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 集群模式下 alertmanager 绑定的 IP 地址和端口号</span><br><span class="hljs-comment"># 用于与其他 alertmanager 节点进行通信。</span><br><span class="hljs-comment"># 通过 cluster.listen-address 监听并接收来自其他 alertmanager 节点的请求，并将自己的状态信息同步给其他节点</span><br><span class="hljs-string">cluster.listen-address</span><br><br><span class="hljs-comment"># alertmanager的cluster.peer是指alertmanager节点在集群中的对等节点</span><br><span class="hljs-comment"># 用于配置alertmanager的高可用性，确保即使某个节点出现问题，其他节点也能够继续工作</span><br><span class="hljs-comment"># 当alertmanager节点加入到集群中时，它会将自己的peer信息发送给其他节点，其他节点也会将自己的peer信息发送给它</span><br><span class="hljs-comment"># 这样，每个alertmanager节点就可以知道其他节点的状态，并在需要时进行切换和故障转移。</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># 实例的cluster.peer参数，以指定其对等节点的地址</span><br><span class="hljs-string">cluster.peer</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建alertmanager的配置</span><br><span class="hljs-comment"># 接收到告警之后甩给webhook</span><br><br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/a1.yml<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/a2.yml<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/a3.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 配置alertmanager向webhook发送告警信息</span><br><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;default-receiver&#x27;</span><br><span class="hljs-attr">receivers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">default-receiver</span><br>    <span class="hljs-attr">webhook_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;http://docker.for.mac.host.internal:5001/&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># a1</span><br>$ docker run -d \<br>    --network p_net \<br>    --network-alias a1 \<br>    --name=a1 \<br>    -p 9093:9093 \<br>    -v /Users/xuweiqiang/Desktop/a1.yml:/etc/alertmanager/config.yml \<br>    prom/alertmanager:latest \<br>    --web.listen-address=<span class="hljs-string">&quot;:9093&quot;</span> \<br>    --cluster.listen-address=<span class="hljs-string">&quot;:8001&quot;</span> \<br>    --config.file=/etc/alertmanager/config.yml \<br>    --log.level=debug<br></code></pre></td></tr></table></figure><p><a href="http://localhost:9093/#/status">http://localhost:9093/#/status</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># a2</span><br>$ docker run -d \<br>    --network p_net \<br>    --network-alias a2 \<br>    --name=a2 \<br>    -p 9094:9094 \<br>    -v /Users/xuweiqiang/Desktop/a2.yml:/etc/alertmanager/config.yml \<br>    prom/alertmanager:latest \<br>    --web.listen-address=<span class="hljs-string">&quot;:9094&quot;</span> \<br>    --cluster.listen-address=<span class="hljs-string">&quot;:8001&quot;</span> \<br>    --cluster.peer=a1:8001 \<br>    --config.file=/etc/alertmanager/config.yml \<br>    --log.level=debug<br></code></pre></td></tr></table></figure><p><a href="http://localhost:9094/#/status">http://localhost:9094/#/status</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># a3</span><br>$ docker run -d \<br>    --network p_net \<br>    --network-alias a3 \<br>    --name=a3 \<br>    -p 9095:9095 \<br>    -v /Users/xuweiqiang/Desktop/a3.yml:/etc/alertmanager/config.yml \<br>    prom/alertmanager:latest \<br>    --web.listen-address=<span class="hljs-string">&quot;:9095&quot;</span> \<br>    --cluster.listen-address=<span class="hljs-string">&quot;:8001&quot;</span> \<br>    --cluster.peer=a1:8001 \<br>    --config.file=/etc/alertmanager/config.yml \<br>    --log.level=debug<br></code></pre></td></tr></table></figure><p><a href="http://localhost:9095/#/status">http://localhost:9095/#/status</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># webhook</span><br>$ go install github.com/prometheus/alertmanager/examples/webhook<br><span class="hljs-comment"># 启动服务</span><br>$ webhook<br></code></pre></td></tr></table></figure><h3 id="十一、测试发送告警"><a href="#十一、测试发送告警" class="headerlink" title="十一、测试发送告警"></a>十一、测试发送告警</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">alerts1=<span class="hljs-string">&#x27;[</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;labels&quot;: &#123;</span><br><span class="hljs-string">       &quot;alertname&quot;: &quot;DiskRunningFull&quot;,</span><br><span class="hljs-string">       &quot;instance&quot;: &quot;example1&quot;</span><br><span class="hljs-string">     &#125;,</span><br><span class="hljs-string">     &quot;annotations&quot;: &#123;</span><br><span class="hljs-string">        &quot;info&quot;: &quot;The disk sdb1 is running full&quot;,</span><br><span class="hljs-string">        &quot;summary&quot;: &quot;please check the instance example1&quot;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">]&#x27;</span><br><br>curl -XPOST -d<span class="hljs-string">&quot;<span class="hljs-variable">$alerts1</span>&quot;</span> http://localhost:9093/api/v1/alerts<br>curl -XPOST -d<span class="hljs-string">&quot;<span class="hljs-variable">$alerts1</span>&quot;</span> http://localhost:9094/api/v1/alerts<br>curl -XPOST -d<span class="hljs-string">&quot;<span class="hljs-variable">$alerts1</span>&quot;</span> http://localhost:9095/api/v1/alerts<br></code></pre></td></tr></table></figure><h3 id="十二、prometheus配置"><a href="#十二、prometheus配置" class="headerlink" title="十二、prometheus配置"></a>十二、prometheus配置</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 总的一句话就是：每个prometheus往alertmanager集群的所有机器发送告警</span><br><span class="hljs-comment"># 最大限度保证告警消息不会丢失就好了</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9093</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9094</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:9095</span><br></code></pre></td></tr></table></figure><h3 id="十二、指纹算法"><a href="#十二、指纹算法" class="headerlink" title="十二、指纹算法"></a>十二、指纹算法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// provides a hash-capable representation of a Metric.</span><br>model.Fingerprint <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// Fingerprint returns a Metric&#x27;s Fingerprint.</span><br><span class="hljs-comment">// 生成指纹算法</span><br><span class="hljs-keyword">type</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Metric)</span></span> Fingerprint() Fingerprint<br><br><span class="hljs-comment">// Equal compares the metrics.</span><br><span class="hljs-comment">// 指标比对逻辑</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m Metric)</span></span> Equal(o Metric) <span class="hljs-type">bool</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Alertmanager的高可用架构是：</p><ol><li>多台实例之间启用集群通讯模式；</li><li>prometheus各自向自己宿主机的alertmanager实例发送告警信息；</li><li>使用alertmanager路由将不同的告警（标签区分）发给不同的接受者；</li><li>使用alertmanager分组将告警合并；</li><li>alertmanager自带的Firing有降噪作用；</li></ol><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>alertmanager接收到告警之后处理流程怎么样的</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">1. 某个Alertmanager接收到告警，会等待一段时间（默认为30秒）看其他Alertmanager节点是否接到该告警<br>2. 等待聚合时间结束后，Alertmanager集群仍然没有收到该告警的聚合，则它将发送给接收器（receiver）<br><br>等待时间称为“等待聚合”（wait_for_aggregate）时间，可以在Alertmanager配置文件的route部分进行配置;<br></code></pre></td></tr></table></figure><ul><li>prometheus的alert有多少种状态</li></ul><ol><li>Unfiring：告警规则触发，但没有达到告警阈值，未达到告警状态。</li><li>Firing：告警规则触发，已达到告警阈值，处于告警状态。</li><li>Pending：正在等待确认，已发送告警通知但还未确认。</li><li>Silenced：已被静默，告警规则被设置为不产生告警。</li><li>Inhibited：已被禁止，告警规则被设置为禁用告警。</li></ol><ul><li>Alertmanager的Webhook是什么</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Alertmanager的Webhook是一种机制，可以通过向指定URL发送HTTP、POST请求来将警报发送到外部系统。<br>Webhook可用于将警报通知转发到其他应用程序、服务或系统，或将其集成到自动化工作流程中。<br>使用Webhook，可以将警报发送到任何支持HTTP接口的服务或应用程序。<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;time&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MyHandler <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(am *MyHandler)</span></span> ServeHTTP(w http.ResponseWriter, r *http.Request) &#123;<br>    body, err := ioutil.ReadAll(r.Body)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Printf(<span class="hljs-string">&quot;read body err, %v\n&quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    fmt.Println(time.Now())<br>    fmt.Printf(<span class="hljs-string">&quot;%s\n\n&quot;</span>, <span class="hljs-type">string</span>(body))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    http.Handle(<span class="hljs-string">&quot;/webhook&quot;</span>, &amp;MyHandler&#123;&#125;)<br>    http.ListenAndServe(<span class="hljs-string">&quot;:10000&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>alertmanager如何查看历史告警</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs txt">Alertmanager提供了HTTP API，可以通过该API来查询历史告警。<br><br>具体来讲，可以通过以下API来获取历史告警：<br><br>1. /api/v1/alerts：该API可以用来查询当前和历史告警。<br>默认情况下，该API只查询当前处于pending、firing或者silenced状态的告警。<br>为了查询历史告警，需要在请求参数中添加start和end参数，指定查询的时间范围。<br><br>2. /api/v1/alerts/groups：该API可以用来查询当前和历史告警的分组信息。<br>类似于上面的API，需要在请求参数中添加start和end参数来指定查询的时间范围。<br><br>3. /api/v1/alerts/&lt;alertname&gt;/&lt;instance&gt;：该API可以用来查询指定告警名称和实例的历史告警。<br>类似于上面的API，需要在请求参数中添加start和end参数来指定查询的时间范围。<br><br>需要注意的是，默认情况下，Alertmanager只会保留最近2小时的历史告警。<br>如果要查询更早期的历史告警，需要对Alertmanager进行配置<br>将history配置项设置为一个大于0的值，以指定历史告警的保留时间。<br></code></pre></td></tr></table></figure><ul><li>对于proemtheus的联邦机制而言，是否会因为标签不一致导致重复发送呢</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">取决于备用节点从主节点拉取指标的时候是否保留原有标签(honor_labels:true)<br>更改标签会导致生成的指纹不一致导致重复发送告警<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/alertmanager-high-availability#chuang-jian-alertmanager-ji-qun">Alertmanager高可用</a></p><p><a href="https://github.com/prometheus/alertmanager">https://github.com/prometheus/alertmanager</a></p><p><a href="https://prometheus.io/docs/alerting/latest/configuration/#webhook_config">webhook的数据标准是什么</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alertmanager</tag>
      
      <tag>告警</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看prometheus的占用内存大小</title>
    <link href="/2023/04/12/prometheus/%E6%9F%A5%E7%9C%8Bprometheus%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/"/>
    <url>/2023/04/12/prometheus/%E6%9F%A5%E7%9C%8Bprometheus%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h3 id="一、top的RES"><a href="#一、top的RES" class="headerlink" title="一、top的RES"></a>一、top的RES</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">&quot;top的RES&quot;可能指的是Linux操作系统中&quot;top&quot;命令中的&quot;RES&quot;列，表示进程使用的实际物理内存大小（以KB为单位）<br></code></pre></td></tr></table></figure><h3 id="二、top查看占用内存"><a href="#二、top查看占用内存" class="headerlink" title="二、top查看占用内存"></a>二、top查看占用内存</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取pid</span><br>$ ps -ef | grep prometheus<br><span class="hljs-comment"># 获取pid对应的内存大小</span><br>$ top -p <span class="hljs-variable">$&#123;pid&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">PID USER      PR  NI    VIRT    RES           <br>4590 root      20   0 1205660  83016<br></code></pre></td></tr></table></figure><h3 id="三、metrics端口查看"><a href="#三、metrics端口查看" class="headerlink" title="三、metrics端口查看"></a>三、metrics端口查看</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指标获取</span><br>$ curl localhost:9090/metrics<br><br><span class="hljs-comment"># 查看 (与top的res一致) 单位kb</span><br>process_resident_memory_bytes/1024<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何优雅的依据结构体拼接URL</title>
    <link href="/2023/04/11/golang/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BE%9D%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%8B%BC%E6%8E%A5URL/"/>
    <url>/2023/04/11/golang/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BE%9D%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BD%93%E6%8B%BC%E6%8E%A5URL/</url>
    
    <content type="html"><![CDATA[<h3 id="一、代码"><a href="#一、代码" class="headerlink" title="一、代码"></a>一、代码</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tool<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/url&quot;</span><br><span class="hljs-string">&quot;reflect&quot;</span><br>)<br><br><span class="hljs-comment">// QueryRange 范围查找结构体</span><br><span class="hljs-keyword">type</span> QueryRange <span class="hljs-keyword">struct</span> &#123;<br>Query <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;query&quot;`</span><br>Start <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;start&quot;`</span><br>End   <span class="hljs-type">int64</span>  <span class="hljs-string">`json:&quot;end&quot;`</span><br>Step  <span class="hljs-type">int</span>    <span class="hljs-string">`json:&quot;step&quot;`</span><br>&#125;<br><br><span class="hljs-comment">// GetStructTag 获取结构体标签</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetStructTag</span><span class="hljs-params">(s <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> (<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>getValue := reflect.ValueOf(s)<br><span class="hljs-keyword">if</span> getValue.Kind() != reflect.Struct &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;not struct&quot;</span>)<br>&#125;<br>getType := reflect.TypeOf(s)<br>t := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; getValue.NumField(); i++ &#123;<br>t[getType.Field(i).Name] = getType.Field(i).Tag.Get(<span class="hljs-string">&quot;json&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> t, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// BuildURLByStruct build url</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BuildURLByStruct</span><span class="hljs-params">(path <span class="hljs-type">string</span>, queryRange *QueryRange)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br><span class="hljs-keyword">if</span> queryRange == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, errors.New(<span class="hljs-string">&quot;query range is nil&quot;</span>)<br>&#125;<br>tagMap, err := GetStructTag(*queryRange)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br>getValue := reflect.ValueOf(*queryRange)<br>urlParamMap := url.Values&#123;&#125;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> tagMap &#123;<br>urlParamMap.Set(v, fmt.Sprintf(<span class="hljs-string">&quot;%v&quot;</span>, getValue.FieldByName(k).Interface()))<br>&#125;<br>base, err := url.Parse(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br>base.RawQuery = urlParamMap.Encode()<br><span class="hljs-keyword">return</span> base.String(), <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="二、单元测试"><a href="#二、单元测试" class="headerlink" title="二、单元测试"></a>二、单元测试</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestBuildURLByStruct</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">type</span> args <span class="hljs-keyword">struct</span> &#123;<br>path       <span class="hljs-type">string</span><br>queryRange *QueryRange<br>&#125;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name    <span class="hljs-type">string</span><br>args    args<br>want    <span class="hljs-type">string</span><br>wantErr <span class="hljs-type">bool</span><br>&#125;&#123;<br>&#123;<br>name: <span class="hljs-string">&quot;build url&quot;</span>,<br>args: args&#123;<br>path: <span class="hljs-string">&quot;www.baidu.com&quot;</span>,<br>queryRange: &amp;QueryRange&#123;<br>Query: <span class="hljs-string">&quot;cpu_counter&quot;</span>,<br>Start: <span class="hljs-number">1</span>,<br>End:   <span class="hljs-number">2</span>,<br>Step:  <span class="hljs-number">15</span>,<br>&#125;,<br>&#125;,<br>want:    <span class="hljs-string">&quot;&quot;</span>,<br>wantErr: <span class="hljs-literal">false</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got, err := BuildURLByStruct(tt.args.path, tt.args.queryRange)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>t.Fatal(err)<br>&#125;<br>t.Log(got)<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、输出结果"><a href="#三、输出结果" class="headerlink" title="三、输出结果"></a>三、输出结果</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">config_test.go:74: www.baidu.com?end=2&amp;query=cpu_counter&amp;start=1&amp;step=15<br></code></pre></td></tr></table></figure><h3 id="开源包推荐"><a href="#开源包推荐" class="headerlink" title="开源包推荐"></a>开源包推荐</h3><p><a href="https://github.com/google/go-querystring">github.com&#x2F;google&#x2F;go-querystring</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单的webhook</title>
    <link href="/2023/04/10/prometheus/%E7%AE%80%E5%8D%95%E7%9A%84webhook/"/>
    <url>/2023/04/10/prometheus/%E7%AE%80%E5%8D%95%E7%9A%84webhook/</url>
    
    <content type="html"><![CDATA[<h3 id="一、webhook"><a href="#一、webhook" class="headerlink" title="一、webhook"></a>一、webhook</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;github.com/prometheus/alertmanager/template&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/hook&quot;</span>, ServeHTTP)<br>_ = http.ListenAndServe(<span class="hljs-string">&quot;:7979&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br><span class="hljs-keyword">var</span> alerts template.Data<br>err := json.NewDecoder(r.Body).Decode(&amp;alerts)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, err.Error(), http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>alertsBytes, err := json.Marshal(alerts)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>http.Error(w, err.Error(), http.StatusBadRequest)<br><span class="hljs-keyword">return</span><br>&#125;<br>log.Println(<span class="hljs-type">string</span>(alertsBytes))<br>w.WriteHeader(http.StatusNoContent)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、alertmanager配置"><a href="#二、alertmanager配置" class="headerlink" title="二、alertmanager配置"></a>二、alertmanager配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/alert.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">resolve_timeout:</span> <span class="hljs-string">5s</span><br><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">group_by:</span> [<span class="hljs-string">&#x27;alertname&#x27;</span>] <span class="hljs-comment"># 告警分组</span><br>  <span class="hljs-attr">group_wait:</span> <span class="hljs-string">2s</span><br>  <span class="hljs-attr">group_interval:</span> <span class="hljs-string">2s</span><br>  <span class="hljs-attr">repeat_interval:</span> <span class="hljs-string">2s</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;my_webhook&#x27;</span><br><span class="hljs-attr">receivers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;my_webhook&#x27;</span><br>  <span class="hljs-attr">webhook_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;http://docker.for.mac.host.internal:7979/hook&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="三、启动alertmanager"><a href="#三、启动alertmanager" class="headerlink" title="三、启动alertmanager"></a>三、启动alertmanager</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    --name=hook_alert \<br>    -p 9095:9095 \<br>    -v /Users/xuweiqiang/Desktop/alert.yml:/etc/alertmanager/config.yml \<br>    prom/alertmanager:latest \<br>    --web.listen-address=<span class="hljs-string">&quot;:9095&quot;</span> \<br>    --config.file=/etc/alertmanager/config.yml \<br>    --log.level=debug<br></code></pre></td></tr></table></figure><h3 id="四、发送告警"><a href="#四、发送告警" class="headerlink" title="四、发送告警"></a>四、发送告警</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">alerts1=<span class="hljs-string">&#x27;[</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;labels&quot;: &#123;</span><br><span class="hljs-string">       &quot;alertname&quot;: &quot;DiskRunningFull&quot;,</span><br><span class="hljs-string">       &quot;instance&quot;: &quot;node one&quot;</span><br><span class="hljs-string">     &#125;,</span><br><span class="hljs-string">     &quot;annotations&quot;: &#123;</span><br><span class="hljs-string">        &quot;info&quot;: &quot;disk full&quot;,</span><br><span class="hljs-string">        &quot;summary&quot;: &quot;please check disk&quot;</span><br><span class="hljs-string">      &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">]&#x27;</span><br><br>curl -XPOST -d<span class="hljs-string">&quot;<span class="hljs-variable">$alerts1</span>&quot;</span> http://localhost:9095/api/v1/alerts<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://prometheus.io/docs/alerting/latest/configuration/#webhook_config">官方手册alerting&#x2F;configuration&#x2F;#webhook_config</a><br><a href="https://prometheus.io/docs/operating/integrations/#alertmanager-webhook-receiver">官方推荐webhook实现</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alertmanager</tag>
      
      <tag>告警</tag>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建alertmanager告警服务</title>
    <link href="/2023/04/10/prometheus/%E6%90%AD%E5%BB%BAalertmanager%E5%91%8A%E8%AD%A6%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/04/10/prometheus/%E6%90%AD%E5%BB%BAalertmanager%E5%91%8A%E8%AD%A6%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、启动alert-manager"><a href="#一、启动alert-manager" class="headerlink" title="一、启动alert manager"></a>一、启动alert manager</h3><ol><li>配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Documents/alertmanager/<br>$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Documents/alertmanager/template<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Documents/alertmanager/config.yml<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Documents/alertmanager/template/email.tmpl<br>$ <span class="hljs-built_in">cd</span> /Users/xuweiqiang/Documents/alertmanager<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ vim /Users/xuweiqiang/Documents/alertmanager/alertmanager.yml<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Documents/alertmanager/template/email.tmpl<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># config.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">resolve_timeout:</span> <span class="hljs-string">5m</span><br>  <span class="hljs-attr">smtp_from:</span> <span class="hljs-string">&#x27;435861851@qq.com&#x27;</span> <span class="hljs-comment"># 发件人</span><br>  <span class="hljs-attr">smtp_smarthost:</span> <span class="hljs-string">&#x27;smtp.qq.com:587&#x27;</span> <span class="hljs-comment"># 邮箱服务器的 POP3/SMTP 主机配置 smtp.qq.com 端口为 465 或 587</span><br>  <span class="hljs-attr">smtp_auth_username:</span> <span class="hljs-string">&#x27;435861851@qq.com&#x27;</span> <span class="hljs-comment"># 用户名</span><br>  <span class="hljs-attr">smtp_auth_password:</span> <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment"># 授权码 </span><br>  <span class="hljs-attr">smtp_require_tls:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">smtp_hello:</span> <span class="hljs-string">&#x27;qq.com&#x27;</span><br><span class="hljs-attr">templates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/etc/alertmanager/template/*.tmpl&#x27;</span><br><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">group_by:</span> [<span class="hljs-string">&#x27;alertname&#x27;</span>] <span class="hljs-comment"># 告警分组</span><br>  <span class="hljs-attr">group_wait:</span> <span class="hljs-string">5s</span> <span class="hljs-comment"># 在组内等待所配置的时间，如果同组内，5 秒内出现相同报警，在一个组内出现。</span><br>  <span class="hljs-attr">group_interval:</span> <span class="hljs-string">5m</span> <span class="hljs-comment"># 如果组内内容不变化，合并为一条警报信息，5 分钟后发送。</span><br>  <span class="hljs-attr">repeat_interval:</span> <span class="hljs-string">5m</span> <span class="hljs-comment"># 发送告警间隔时间 s/m/h，如果指定时间内没有修复，则重新发送告警</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;email&#x27;</span> <span class="hljs-comment"># 优先使用 wechat 发送</span><br>  <span class="hljs-attr">routes:</span> <span class="hljs-comment">#子路由，使用 email 发送</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">receiver:</span> <span class="hljs-string">email</span><br>    <span class="hljs-attr">match_re:</span><br>      <span class="hljs-attr">serverity:</span> <span class="hljs-string">email</span><br><span class="hljs-attr">receivers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;email&#x27;</span><br>  <span class="hljs-attr">email_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">&#x27;435861851@qq.com&#x27;</span> <span class="hljs-comment"># 如果想发送多个人就以 &#x27;,&#x27; 做分割</span><br>    <span class="hljs-attr">send_resolved:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; template &quot;email.html&quot; . &#125;&#125;</span>&#x27;</span>   <span class="hljs-comment">#使用自定义的模板发送</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">&#123;&#123; define &quot;email.html&quot; &#125;&#125;<br>&#123;&#123; range $i, $alert :=.Alerts &#125;&#125;<br>========监控报警==========<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警状态：&#123;&#123;   .Status &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警级别：&#123;&#123; $alert.Labels.severity &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警类型：&#123;&#123; $alert.Labels.alertname &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警应用：&#123;&#123; $alert.Annotations.summary &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警主机：&#123;&#123; $alert.Labels.instance &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警详情：&#123;&#123; $alert.Annotations.description &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>触发阀值：&#123;&#123; $alert.Annotations.value &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警时间：&#123;&#123; $alert.StartsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>========end=============<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>&#123;&#123; end &#125;&#125;<br>&#123;&#123; end &#125;&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>启动alertmanager</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    --network p_net \<br>    --network-alias alert \<br>    --name=alertmanager \<br>    -p 9093:9093 \<br>    -v /Users/xuweiqiang/Documents/alertmanager:/etc/alertmanager \<br>    prom/alertmanager:latest<br></code></pre></td></tr></table></figure><h3 id="二、启动prometheus"><a href="#二、启动prometheus" class="headerlink" title="二、启动prometheus"></a>二、启动prometheus</h3><ol><li>配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Documents/alertmanager/prometheus.yml<br>$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Documents/alertmanager/rules<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Documents/alertmanager/rules/one.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># prometheus.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">5s</span> <br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">5s</span> <br><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">alert:9093</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;request_count&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/metrics&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;docker.for.mac.host.internal:6969&quot;</span>]<br>      <br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/etc/prometheus/rules/*.yml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># rules/one.yml</span><br><span class="hljs-attr">groups:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hostStatsAlert</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">hostCpuUsageAlert</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">(1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">avg(irate(node_cpu_seconds_total&#123;mode=&quot;idle&quot;&#125;[5m]))</span> <span class="hljs-string">by</span> <span class="hljs-string">(instance))*100</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">85</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;Instance <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> CPU usage high&quot;</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> CPU usage above 85% (current value: <span class="hljs-template-variable">&#123;&#123; $value &#125;&#125;</span>)&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">hostMemUsageAlert</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">(1</span> <span class="hljs-bullet">-</span> <span class="hljs-string">(node_memory_MemAvailable_bytes&#123;&#125;</span> <span class="hljs-string">/</span> <span class="hljs-string">(node_memory_MemTotal_bytes&#123;&#125;)))*</span> <span class="hljs-number">100</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">70</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;Instance <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usage high&quot;</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> MEM usage above 70% (current value: <span class="hljs-template-variable">&#123;&#123; $value &#125;&#125;</span>)&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">request_counter</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">app_system_request</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;Instance <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> request count too much&quot;</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> request count above 3 (current value: <span class="hljs-template-variable">&#123;&#123; $value &#125;&#125;</span>)&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>启动prometheus</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run \<br>    --name alert_client \<br>    -d \<br>    -p 9090:9090 \<br>    --network p_net \<br>    --network-alias alert_client \<br>    -v /Users/xuweiqiang/Documents/alertmanager:/etc/prometheus/ \<br>    prom/prometheus \<br>    --config.file=/etc/prometheus/prometheus.yml<br></code></pre></td></tr></table></figure><h3 id="三、模拟告警指标"><a href="#三、模拟告警指标" class="headerlink" title="三、模拟告警指标"></a>三、模拟告警指标</h3><p><a href="https://weiqiangxu.github.io/2023/04/10/prometheus/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E6%A0%87exporter/">golang实现简单的指标exporter</a></p><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>告警状态有哪些</li></ul><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">Inactive：这里什么都没有发生。<br>Pending：已触发阈值，但未知足告警持续时间（即<span class="hljs-keyword">rule</span>中的for字段）<br>Firing：已触发阈值且满足告警持续时间。警报发送到Notification Pipeline<br>        通过处理，目的是屡次判断失败才发告警，减小邮件<br></code></pre></td></tr></table></figure><ul><li>prometheus告警机制如何降噪的</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 简要描述：<br>Prometheus会根据rules中的规则，不断的评估是否需要发出告警信息,<br>如果满足规则中的条件，则会向alertmanagers中配置的地址发送告警<br>告警是通过alertmanager配置的地址post告警,比如targets: [node1:8090&#x27;]<br>则会向node1:8090/api/v2/alerts发送告警信息<br><br># 如何验证：<br>自己实现alertmanger程序，来接收Prometheus发送的告警，并将告警打印出来<br><br># 告警间隔 <br>[prometheus.yml] &gt; global.evaluation_interval = 15s (告警周期)<br>[rules.yml] &gt; groups[].rules[].for = 1m (具体某一条告警规则的告警时长)<br><br>1m 15s就是prometheus推送告警信息的间隔<br><br># 如何理解<br>1m 是prometheus拉取指标的间隔 (隔1m拉指标1次)<br>15s是对应的告警设置的持续时间（需要持续15s以上才会告警）<br>所以第一次pull到异常时候，到第二次再次pull到异常才满足了15s持续的条件<br>如果设置为0则立刻告警<br></code></pre></td></tr></table></figure><ul><li>alertmanager处理告警信息有哪些重要机制</li></ul><ol><li>路由: 不同的告警来源发给不同的收件人</li><li>分组: 相同的告警类型合并为一封告警</li></ol><ul><li>什么情况下会有Firing状态值</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">Firing状态值通常在Prometheus规则中定义的触发条件成立时出现。<br>也就是说，当监控指标满足预设的规则条件时，Prometheus会发出告警<br>并将告警状态设置为Firing，以通知用户进行相应的处理。<br>常见的情况包括<span class="hljs-meta">CPU</span>使用率过高、内存使用率超标、网络延迟过高等问题。<br><br>这个状态值的意义在于，当你的机器一直处于<span class="hljs-meta">cpu</span>爆满或其他某一个状态值的时候<br>不会每隔一段时间发送告警，相当于降噪<br></code></pre></td></tr></table></figure><ul><li>告警路由是什么</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">admin-receiver</span><br>  <span class="hljs-attr">routes:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">receiver:</span> <span class="hljs-string">database-receiver</span><br>    <span class="hljs-attr">match:</span> <br>      <span class="hljs-attr">component:</span> <span class="hljs-string">database</span>    <br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">receiver:</span> <span class="hljs-string">memcache-receiver</span><br>    <span class="hljs-attr">macth:</span> <br>      <span class="hljs-attr">componnet:</span> <span class="hljs-string">memcache</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">以上的路由达到的效果是：<br><br>告警的标签匹配 component=database 的发送告警给 database-receiver<br></code></pre></td></tr></table></figure><ul><li>分组是什么</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">admin-receiver</span><br>  <span class="hljs-attr">group_by:</span> [<span class="hljs-string">&quot;instance&quot;</span>]<br>  <span class="hljs-attr">group_wait:</span> <span class="hljs-string">30s</span><br>  <span class="hljs-attr">group_interval:</span> <span class="hljs-string">5m</span><br>  <span class="hljs-attr">repeat_interval:</span> <span class="hljs-string">4h</span><br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">当alertmanager在一分钟内收到6封告警<br>其中3封邮件是instance=A<br>领完3封邮件是instance=B<br>并且group wait为1分钟以上<br>在group wait期间收到的这6封告警<br>会合并为2封告警信息<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">对于告警<br><br>&#123;alertname=&quot;NodeCPU&quot;,instance=&quot;peng01&quot;,...&#125;<br><br>会创建分组<br><br>&#123;instance=&quot;peng01&quot;&#125;<br><br>那么同一个组的告警，将会等待group_wait的时间，alertManager会把这一组告警一次性发给Receiver<br>假设group_interval为5分钟，意思是，同一个组的告警，在发送了告警之后，这个时间间隔内，不会再次发送告警<br>但是超过了这个时间（5min），有同一个组的告警到达，会在等待group_wait时间后立刻发送告警<br></code></pre></td></tr></table></figure><ul><li>主从多台alertmanager之下如何滤重告警</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">Gossip协议下的集群<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/ActionTech/article/details/82421894">csdn.net之Prometheus一条告警是怎么触发的</a><br><a href="https://www.cnblogs.com/zydev/p/16848444.html">cnblogs.com之Prometheus发送告警机制</a><br><a href="https://zhuanlan.zhihu.com/p/371967435">zhuanlan.zhihu.com开箱即用的 Prometheus 告警规则集</a><br><a href="https://cloud.tencent.com/developer/article/2211153">cloud.tencent.com使用Docker部署alertmanager并配置prometheus告警</a><br><a href="https://pshizhsysu.gitbook.io/prometheus/ff08-san-ff09-prometheus-gao-jing-chu-li/gao-jing-de-lu-you-yu-fen-zu">pshizhsysu.gitbook.io告警的路由与分组</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>告警</tag>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang实现简单的指标exporter</title>
    <link href="/2023/04/10/prometheus/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E6%A0%87exporter/"/>
    <url>/2023/04/10/prometheus/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E6%A0%87exporter/</url>
    
    <content type="html"><![CDATA[<h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net/http&quot;</span><br><br><span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span><br><span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/collectors&quot;</span><br><span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> requestCounter = prometheus.NewCounter(prometheus.CounterOpts&#123;<br>Namespace:   <span class="hljs-string">&quot;app&quot;</span>,<br>Subsystem:   <span class="hljs-string">&quot;system&quot;</span>,<br>Name:        <span class="hljs-string">&quot;request&quot;</span>,<br>Help:        <span class="hljs-string">&quot;request counter&quot;</span>,<br>ConstLabels: <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">string</span>&#123;&#125;,<br>&#125;)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>prometheus.DefaultRegisterer.Unregister(collectors.NewGoCollector())<br>prometheus.MustRegister(requestCounter)<br>&#125;<br><br><span class="hljs-comment">// go语言实现 http服务端</span><br><span class="hljs-comment">// http://127.0.0.1:8989/hello</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>http.HandleFunc(<span class="hljs-string">&quot;/hello&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(writer http.ResponseWriter, request *http.Request)</span></span> &#123;<br>requestCounter.Inc()<br>_, _ = writer.Write([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;hello world&quot;</span>))<br>&#125;)<br>http.Handle(<span class="hljs-string">&quot;/metrics&quot;</span>, promhttp.Handler())<br>err := http.ListenAndServe(<span class="hljs-string">&quot;127.0.0.1:6969&quot;</span>, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node_exporter指标解析</title>
    <link href="/2023/04/10/prometheus/node_exporter%E6%8C%87%E6%A0%87%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/10/prometheus/node_exporter%E6%8C%87%E6%A0%87%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、本机运行node-exporter"><a href="#一、本机运行node-exporter" class="headerlink" title="一、本机运行node-exporter"></a>一、本机运行node-exporter</h3><ol><li>启动node exporter</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 常驻进程启动</span><br>$ <span class="hljs-built_in">nohup</span> ./node_exporter &gt; ./node_exporter.log 2&gt;&amp;1 &amp;<br><span class="hljs-comment"># 查看采集到的指标</span><br>$ curl 127.0.0.1:9100/metrics<br></code></pre></td></tr></table></figure><ol start="2"><li>配置prometheus采集node exporter指标</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># prometheus.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br><br><span class="hljs-comment"># Alertmanager configuration</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>          <span class="hljs-comment"># - alertmanager:9093</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&quot;/metrics&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;node_exporter&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&quot;/metrics&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9100&quot;</span>]<br></code></pre></td></tr></table></figure><ol start="3"><li>本地启动prometheus</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">nohup</span> ./prometheus --config.file=prometheus.yml --web.enable-lifecycle &gt; run.log 2&gt;&amp;1 &amp;<br>$ <span class="hljs-built_in">kill</span> -HUP pid<br>$ curl -X POST http://127.0.0.1/-/reload<br></code></pre></td></tr></table></figure><h3 id="二、docker运行node-exporter"><a href="#二、docker运行node-exporter" class="headerlink" title="二、docker运行node-exporter"></a>二、docker运行node-exporter</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># docker内启动一个node-exporter</span><br>docker run -d \<br>  --name node_exporter \<br>  --network p_net \<br>  --network-alias node_exporter \<br>  -p 9100:9100 \<br>  quay.io/prometheus/node-exporter<br></code></pre></td></tr></table></figure><h3 id="三、node-exporter指标解析"><a href="#三、node-exporter指标解析" class="headerlink" title="三、node-exporter指标解析"></a>三、node-exporter指标解析</h3><ol><li>cpu指标查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># node exporter 指标解释</span><br><span class="hljs-comment"># 要对节点进行 CPU 监控，需要用到 node_cpu_seconds_total 这个监控指标</span><br><br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;idle&quot;</span>&#125; 13172.76 <br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;iowait&quot;</span>&#125; 0.25<br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;irq&quot;</span>&#125; 0<br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;nice&quot;</span>&#125; 0.01<br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;softirq&quot;</span>&#125; 87.99<br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;steal&quot;</span>&#125; 0<br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;system&quot;</span>&#125; 309.38<br>node_cpu_seconds_total&#123;cpu=<span class="hljs-string">&quot;0&quot;</span>,mode=<span class="hljs-string">&quot;user&quot;</span>&#125; 79.93<br><br><span class="hljs-comment"># cpu idle cpu空闲</span><br><span class="hljs-comment"># iowait 属于idle的子类 - 1种等待 IO 造成的 idle状态</span><br><span class="hljs-comment"># irq就是Interrupt ReQuest 中断请求 - 硬件接口设备会透过IRQ对CPU送出中断请求讯号请求处理硬件需求</span><br><span class="hljs-comment"># nice 优先级用户态 CPU 时间</span><br><span class="hljs-comment"># softirq 软中断的 CPU 时间</span><br><span class="hljs-comment"># steal 当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间</span><br><span class="hljs-comment"># guest 通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间</span><br><span class="hljs-comment"># guest_nice 低优先级运行虚拟机的时间</span><br><br>CPU 使用率是 CPU 除空闲（idle）状态之外的其他所有 CPU 状态的时间总和除以总的 CPU 时间<br><br><span class="hljs-comment"># 每分钟空闲cpu总数</span><br>increase(node_cpu_seconds_total&#123;mode=<span class="hljs-string">&quot;idle&quot;</span>&#125;[1m])<br><span class="hljs-comment"># 每分钟cpu总数</span><br><span class="hljs-built_in">sum</span>(increase(node_cpu_seconds_total[1m])) by (instance)<br><br><span class="hljs-comment"># 每分钟空闲cpu占比</span><br>(1 - <span class="hljs-built_in">sum</span>(rate(node_cpu_seconds_total&#123;mode=<span class="hljs-string">&quot;idle&quot;</span>&#125;[1m])) by (instance) / <span class="hljs-built_in">sum</span>(rate(node_cpu_seconds_total[1m])) by (instance) ) * 100<br></code></pre></td></tr></table></figure><ol start="2"><li>内存监控</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">available 是从应用程序的角度看到的可用内存<br>available = free + buffer + cache<br><br><span class="hljs-comment"># node_memory_* 相关指标</span><br>node_memory_Buffers_bytes + node_memory_Cached_bytes + node_memory_MemFree_bytes<br><br><span class="hljs-comment"># 可用内存的使用率，和总的内存相除</span><br>(1- (node_memory_Buffers_bytes + node_memory_Cached_bytes + node_memory_MemFree_bytes) / node_memory_MemTotal_bytes) * 100<br><br><span class="hljs-comment"># 查看节点总内存</span><br>node_memory_MemTotal_bytes&#123;instance=<span class="hljs-string">&quot;node2&quot;</span>&#125;/1024/1024/1024<br><br><span class="hljs-comment"># linux查看内存使用使用率 free -m</span><br>其中的free列的值和 node_memory_MemFree_bytes/1024/1024 一致<br>其中的total列的值和 node_memory_MemTotal_bytes/1024/1024 一致<br><br>              total        used        free      shared  buff/cache   available<br>Mem:           1999         153        1063           8         782        1679<br>Swap:          1023           0        1023<br></code></pre></td></tr></table></figure><ol start="3"><li>磁盘空间监控</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">node_filesystem_* 相关的指标<br><br><span class="hljs-comment"># 磁盘空间使用率</span><br><span class="hljs-comment"># fstype 标签过滤关心的磁盘信息，比如 ext4 或者 xfs 格式的磁盘</span><br>(1 - node_filesystem_avail_bytes&#123;fstype=~<span class="hljs-string">&quot;ext4|xfs&quot;</span>&#125; / node_filesystem_size_bytes&#123;fstype=~<span class="hljs-string">&quot;ext4|xfs&quot;</span>&#125;) * 100<br></code></pre></td></tr></table></figure><ol start="4"><li>磁盘的读写监控</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 读 IO 使用 node_disk_reads_completed</span><br><span class="hljs-comment"># 写 IO 使用 node_disk_writes_completed_total</span><br><br><span class="hljs-comment"># 磁盘读IO</span><br><span class="hljs-built_in">sum</span> by (instance) (rate(node_disk_reads_completed_total[5m]))<br><br><span class="hljs-comment"># 磁盘写IO</span><br><span class="hljs-built_in">sum</span> by (instance) (rate(node_disk_writes_completed_total[5m]))<br><br><span class="hljs-comment"># 读写IO</span><br>rate(node_disk_reads_completed_total[5m]) + rate(node_disk_writes_completed_total[5m])<br></code></pre></td></tr></table></figure><ol start="5"><li>网络IO</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 上行带宽需要用到的指标是 node_network_receive_bytes</span><br><span class="hljs-comment"># 计算上行带宽用</span><br><span class="hljs-built_in">sum</span> by(instance) (irate(node_network_receive_bytes_total&#123;device!~<span class="hljs-string">&quot;bond.*?|lo&quot;</span>&#125;[5m]))<br><br><span class="hljs-comment"># 下行带宽 node_network_transmit_bytes</span><br><span class="hljs-built_in">sum</span> by(instance) (irate(node_network_transmit_bytes&#123;device!~<span class="hljs-string">&quot;bond.*?|lo&quot;</span>&#125;[5m]))<br></code></pre></td></tr></table></figure><h3 id="四、docker启动prometheus采集指标"><a href="#四、docker启动prometheus采集指标" class="headerlink" title="四、docker启动prometheus采集指标"></a>四、docker启动prometheus采集指标</h3><ol><li>prometheus配置</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># prometheus.yml 监控容器</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;node_exporter&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&quot;/metrics&quot;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;node_exporter:9100&quot;</span>]<br></code></pre></td></tr></table></figure><ol start="2"><li>启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动prometheus</span><br>$ docker run \<br>    --name node_exporter_prometheus \<br>    -d \<br>    -p 9090:9090 \<br>    --network p_net \<br>    --network-alias master \<br>    -v /Users/xuweiqiang/Desktop/prometheus.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus \<br>    --config.file=/etc/prometheus/prometheus.yml<br></code></pre></td></tr></table></figure><h3 id="五、golang调用接口查询各个指标"><a href="#五、golang调用接口查询各个指标" class="headerlink" title="五、golang调用接口查询各个指标"></a>五、golang调用接口查询各个指标</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> bingo_monitor<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;context&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;github.com/prometheus/client_golang/api&quot;</span><br>v1 <span class="hljs-string">&quot;github.com/prometheus/client_golang/api/prometheus/v1&quot;</span><br><span class="hljs-string">&quot;github.com/prometheus/common/model&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> PrometheusServer = <span class="hljs-string">&quot;http://127.0.0.1:9090&quot;</span><br><span class="hljs-keyword">const</span> RangeQueryPath = <span class="hljs-string">&quot;api/v1/query_range&quot;</span><br><br><span class="hljs-keyword">type</span> QueryRangeType <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// FreeMemory 获取剩余内存大小 单位: MB</span><br>FreeMemory QueryRangeType = <span class="hljs-string">&quot;node_memory_MemFree_bytes/(1024*1024)&quot;</span><br><br><span class="hljs-comment">// TotalMemory 获取总内存大小 单位 MB</span><br>TotalMemory QueryRangeType = <span class="hljs-string">&quot;node_memory_MemTotal_bytes/(1024*1024)&quot;</span><br><br><span class="hljs-comment">// MemoryUsageRate 可用内存剩余（百分比）</span><br>MemoryUsageRate QueryRangeType = <span class="hljs-string">&quot;(1- (node_memory_Buffers_bytes + node_memory_Cached_bytes + node_memory_MemFree_bytes) / node_memory_MemTotal_bytes) * 100&quot;</span><br><br><span class="hljs-comment">// FileSystemUsageRate 磁盘空间使用率(百分比) df -h 验证正确</span><br>FileSystemUsageRate QueryRangeType = <span class="hljs-string">&quot;(1 - node_filesystem_avail_bytes&#123;fstype=~\&quot;ext4|xfs\&quot;&#125; / node_filesystem_size_bytes&#123;fstype=~\&quot;ext4|xfs\&quot;&#125;) * 100&quot;</span><br><br><span class="hljs-comment">// CPUUsageRate cpu消耗占用</span><br>CPUUsageRate QueryRangeType = <span class="hljs-string">&quot;(1 - sum(rate(node_cpu_seconds_total&#123;mode=\&quot;idle\&quot;&#125;[1m])) by (instance) / sum(rate(node_cpu_seconds_total[1m])) by (instance) ) * 100&quot;</span><br><br><span class="hljs-comment">// DiskRate 磁盘读写IO</span><br>DiskRate QueryRangeType = <span class="hljs-string">&quot;rate(node_disk_reads_completed_total[5m]) + rate(node_disk_writes_completed_total[5m])&quot;</span><br><br><span class="hljs-comment">// DownloadNetwork 下行带宽</span><br>DownloadNetwork QueryRangeType = <span class="hljs-string">&quot;sum by(instance) (irate(node_network_transmit_bytes_total&#123;device!~\&quot;bond.*?|lo\&quot;&#125;[5m]))&quot;</span><br><br><span class="hljs-comment">// UPNetwork 上行带宽</span><br>UPNetwork QueryRangeType = <span class="hljs-string">&quot;sum by(instance) (irate(node_network_receive_bytes_total&#123;device!~\&quot;bond.*?|lo\&quot;&#125;[5m]))&quot;</span><br>)<br><br><span class="hljs-comment">// ObtainChangesInIdleMemory 获取空闲内存变化</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ObtainChangesInIdleMemory</span><span class="hljs-params">(queryType QueryRangeType, start time.Time, end time.Time, step time.Duration)</span></span> ([]model.SamplePair, <span class="hljs-type">error</span>) &#123;<br>client, err := api.NewClient(api.Config&#123;<br>Address: PrometheusServer,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>v1api := v1.NewAPI(client)<br>ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">10</span>*time.Second)<br><span class="hljs-keyword">defer</span> cancel()<br>r := v1.Range&#123;<br>Start: start,<br>End:   end,<br>Step:  step,<br>&#125;<br>result, warnings, err := v1api.QueryRange(ctx, <span class="hljs-type">string</span>(queryType), r, v1.WithTimeout(<span class="hljs-number">5</span>*time.Second))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(warnings) &gt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;warning:%v&quot;</span>, warnings)<br>&#125;<br><span class="hljs-keyword">if</span> result.Type() != model.ValMatrix &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, errors.New(<span class="hljs-string">&quot;query result is not ValMatrix&quot;</span>)<br>&#125;<br>z := result.(model.Matrix)<br><span class="hljs-keyword">var</span> metricsDataList []model.SamplePair<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> z &#123;<br>metricsDataList = <span class="hljs-built_in">append</span>(metricsDataList, v.Values...)<br>&#125;<br><span class="hljs-keyword">return</span> metricsDataList, <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>剩余内存转换为MB单位</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># node_memory_free_bytes 空闲内存多少MB</span><br>node_memory_free_bytes/(1024*1024) <br></code></pre></td></tr></table></figure><ul><li>如何通过http接口查看监控数据</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl <span class="hljs-string">&#x27;http://localhost:9090/api/v1/query?query=node_memory_free_bytes/(1024*1024)&#x27;</span><br><br><span class="hljs-comment"># 返回结果</span><br>&#123;<br>    <span class="hljs-string">&quot;status&quot;</span>:<span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;resultType&quot;</span>:<span class="hljs-string">&quot;vector&quot;</span>,<br>        <span class="hljs-string">&quot;result&quot;</span>:[<br>            &#123;<br>                <span class="hljs-string">&quot;metric&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;instance&quot;</span>:<span class="hljs-string">&quot;docker.for.mac.host.internal:9100&quot;</span>,<br>                    <span class="hljs-string">&quot;job&quot;</span>:<span class="hljs-string">&quot;node_exporter&quot;</span><br>                &#125;,<br>                <span class="hljs-string">&quot;value&quot;</span>:[<br>                    1680861573.392, <span class="hljs-comment">#时间戳</span><br>                    <span class="hljs-string">&quot;108.4375&quot;</span> <span class="hljs-comment">#剩余108MB</span><br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如何通过http接口区间数据查询</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查询区间数据 start和end分别表示开始和结束的unix_timestamp、step表示间隔多少秒1条数据 </span><br><span class="hljs-comment"># 1680862582表示2023-04-07 18:16:22 ； 1680862782表示2023-04-07 18:19:42</span><br><span class="hljs-comment"># curl &#x27;http://localhost:9090/api/v1/query_range?query=&amp;start=&amp;end=&amp;step=&#x27;</span><br>$ curl <span class="hljs-string">&#x27;http://localhost:9090/api/v1/query_range?query=node_memory_free_bytes/(1024*1024)&amp;start=1680862582&amp;end=1680862782&amp;step=15&#x27;</span><br><br><span class="hljs-comment">#返回结果 每一个时刻的空闲内存</span><br>&#123;<br>    <span class="hljs-string">&quot;status&quot;</span>:<span class="hljs-string">&quot;success&quot;</span>,<br>    <span class="hljs-string">&quot;data&quot;</span>:&#123;<br>        <span class="hljs-string">&quot;resultType&quot;</span>:<span class="hljs-string">&quot;matrix&quot;</span>,<br>        <span class="hljs-string">&quot;result&quot;</span>:[<br>            &#123;<br>                <span class="hljs-string">&quot;metric&quot;</span>:&#123;<br>                    <span class="hljs-string">&quot;instance&quot;</span>:<span class="hljs-string">&quot;docker.for.mac.host.internal:9100&quot;</span>,<br>                    <span class="hljs-string">&quot;job&quot;</span>:<span class="hljs-string">&quot;node_exporter&quot;</span><br>                &#125;,<br>                <span class="hljs-string">&quot;values&quot;</span>:[<br>                    [<br>                        1680862582, <span class="hljs-comment">#2023-04-07 18:16:22</span><br>                        <span class="hljs-string">&quot;62.59375&quot;</span><br>                    ],<br>                    [<br>                        1680862597, <span class="hljs-comment">#2023-04-07 18:16:37 间隔15s</span><br>                        <span class="hljs-string">&quot;39.875&quot;</span><br>                    ],<br>                    [<br>                        1680862612, <span class="hljs-comment">#2023-04-07 18:16:52 间隔15s</span><br>                        <span class="hljs-string">&quot;54.75&quot;</span><br>                    ],...<br>                ]<br>            &#125;<br>        ]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.west999.com/info/html/caozuoxitong/Linux/20200408/4668695.html">Linux性能之CPU使用率</a><br><a href="https://blog.csdn.net/qq_34556414/article/details/126003112">Prometheus Node Exporter 常用监控指标</a><br><a href="https://prometheus.fuckcloudnative.io/di-san-zhang-prometheus/di-4-jie-cha-xun/api">在 HTTP API 中使用 PromQL</a><br><a href="https://www.jianshu.com/p/e3c9fc929d8a/">容器监控实践—node-exporter</a><br><a href="https://www.runoob.com/w3cnote/linux-view-disk-space.html">Linux 查看磁盘空间</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
      <tag>api</tag>
      
      <tag>监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAP理论</title>
    <link href="/2023/04/08/architecture/CAP/"/>
    <url>/2023/04/08/architecture/CAP/</url>
    
    <content type="html"><![CDATA[<h3 id="分布式和微服务什么意思"><a href="#分布式和微服务什么意思" class="headerlink" title="分布式和微服务什么意思"></a>分布式和微服务什么意思</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">单机系统就是程序部署到一台机器，所有的服务由这一台机器提供<br><br>分布式系统相对而言，是一组为了完成共同任务而协调工作的计算机节点组成,它们通过网络进行通讯的系统；<br><br>分布式系统是多个机器共同提供服务<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">分布式系统拆分模式<br><br>水平切分：水平切分是指将同一个系统部署到多台机器上<br>垂直切分：垂直切分是按照业务的维度进行拆分，将各个业务独立出来，单独开发和维护<br>混合切分：混合切分是将水平切分和垂直切分结合起来的一种切分方法<br><br><br>微服务架构 - 大部分都是采用混合切分<br></code></pre></td></tr></table></figure><blockquote><p>所以说微服务是分布式的一个子集，微服务是将服务拆分，并且分布式部署</p></blockquote><h3 id="分布式系统面临的问题"><a href="#分布式系统面临的问题" class="headerlink" title="分布式系统面临的问题"></a>分布式系统面临的问题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 分布式计算的八大谬论<br><span class="hljs-bullet">2.</span> 通讯异常，网络分区，三态，节点故障<br></code></pre></td></tr></table></figure><h3 id="分布式系统的设计原则"><a href="#分布式系统的设计原则" class="headerlink" title="分布式系统的设计原则"></a>分布式系统的设计原则</h3><ol><li>CAP原则</li><li>BASE理论</li></ol><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ol><li>Consistency 一致性<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">分布式系统每个副本数据，用户读取数据都是最新的值<br></code></pre></td></tr></table></figure></li><li>Aviability 可用性<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">客户端向其中一个服务器发起一个请求且该服务器未崩溃，那么这个服务器最终必须响应客户端的请求<br><br>反过来说，如果为了强一致性，请求一个服务器的时候，延迟3s等副本同步完成才响应，那么是不满足可用性的<br></code></pre></td></tr></table></figure></li><li>分区容错性 Partition tolerance<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">是否容忍消息丢失<br><br>信息丢失或者失败不会影响系统的继续运作<br><br>比如副本之间同步的消息丢失不影响服务正常提供<br></code></pre></td></tr></table></figure></li></ol><h3 id="对于一个分布式系统来说，P-是一个基本要求，CAP-三者中，只能根据系统要求在-C-和-A-两者之间做权衡，并且要想尽办法提升-P"><a href="#对于一个分布式系统来说，P-是一个基本要求，CAP-三者中，只能根据系统要求在-C-和-A-两者之间做权衡，并且要想尽办法提升-P" class="headerlink" title="对于一个分布式系统来说，P 是一个基本要求，CAP 三者中，只能根据系统要求在 C 和 A 两者之间做权衡，并且要想尽办法提升 P"></a>对于一个分布式系统来说，P 是一个基本要求，CAP 三者中，只能根据系统要求在 C 和 A 两者之间做权衡，并且要想尽办法提升 P</h3><h3 id="对于一个分布式系统来说，P-是一个基本要求"><a href="#对于一个分布式系统来说，P-是一个基本要求" class="headerlink" title="对于一个分布式系统来说，P 是一个基本要求"></a>对于一个分布式系统来说，P 是一个基本要求</h3><h3 id="对于一个分布式系统来说，P-是一个基本要求-1"><a href="#对于一个分布式系统来说，P-是一个基本要求-1" class="headerlink" title="对于一个分布式系统来说，P 是一个基本要求"></a>对于一个分布式系统来说，P 是一个基本要求</h3><h3 id="分布式系统的三种模式"><a href="#分布式系统的三种模式" class="headerlink" title="分布式系统的三种模式"></a>分布式系统的三种模式</h3><ol><li><p>AP</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">1.保证服务可用（当某一个副本网络故障不影响）<br>2.某一个信息丢失不影响系统继续运行<br><br>Redis的集群就是这样，多个副本在同一个时刻不保证数据强一致<br></code></pre></td></tr></table></figure></li><li><p>CP</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 强一致性（每个时刻每个副本数据一致）<br><span class="hljs-bullet">2.</span> 消息丢失也正常提供服务<br><br>为什么没办法有Aviability可用性，因为为了满足强一致性，请求服务时候需要阻塞等待副本同步<br></code></pre></td></tr></table></figure></li><li><p>AC </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 可用性<br><span class="hljs-bullet">2.</span> 一致性<br><br>要任何时刻都立刻响应，且数据多个副本一致，就无法达到 Partition tolerance，因为消息丢失就无法提供服务了（数据一致性不可能）<br></code></pre></td></tr></table></figure></li><li><p>Zookeeper 保证的是 CP 也就是强一致性，但是有时候服务会阻塞一下延迟响应</p></li><li><p>Redis集群 是AP，也就是每个时刻都是服务立即可用但是不保证每个副本数据都是最新的</p></li></ol><h3 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h3><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs excel"><span class="hljs-built_in">BASE</span>理论中，一致性分为强一致性和弱一致性<br><br>强一致性：当用户更新数据之后，必须保证后续线程或者节点都能马上访问到最新的值<br><br>弱一致性：当用户更新数据之后，并不能保证后续线程或者节点都能马上访问到最新的值，它只能通过某种方法来保证最后的一致性<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CAP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CDN</title>
    <link href="/2023/04/08/architecture/CDN%E6%8A%80%E6%9C%AF/"/>
    <url>/2023/04/08/architecture/CDN%E6%8A%80%E6%9C%AF/</url>
    
    <content type="html"><![CDATA[<h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol><li><p>CDN是什么</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">内容分发网络（<span class="hljs-attribute">Content</span> Delivery Network，简称CDN）<br><br>克服单机系统输出带宽及并发能力不足的缺点<br><br>全局负载均衡技术将用户的访问指向离用户最近的服务器<br></code></pre></td></tr></table></figure></li><li><p>主要技术手段</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">高速缓存<br><br>镜像服务器<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>Internet的统计表明，超过80%的用户经常访问的是20%的网站的内容</p></blockquote><ol start="3"><li>CDN的工作原理</li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DNS</span>解析 域名到<span class="hljs-built_in">IP</span>地址的转换<br><br><span class="hljs-symbol">CDN</span>加速的域名为www.a.com<br><br>当终端用户（北京）发起HTTP请求时<br><br>域名解析请求发送至阿里云DNS调度系统，并为请求分配最佳节点<span class="hljs-built_in">IP</span>地址<br><br>通过DNS分查找离用户最近的CDN节点（边缘服务器）的<span class="hljs-built_in">IP</span><br><br><span class="hljs-symbol">CDN</span>上并没有缓存资源，则会到源站请求资源，并缓存到CDN节点上<br><br><span class="hljs-symbol">CDN</span>缓存清理，让新的请求直接到OSS，实现缓存一致性<br></code></pre></td></tr></table></figure><blockquote><p>CDN边缘节点会检测用户请求数据的缓存是否过期，如果没有过期，则直接响应用户请求，此时一个完成http请求结束；如果已经过期那么CDN还需要向源站发出回源请求（back to the source request）,来拉取最新的数据</p></blockquote><h3 id="关键术语"><a href="#关键术语" class="headerlink" title="关键术语"></a>关键术语</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">CDN边缘节点<br><br>源站<br><br><br><br>淘宝整个图片的访问链路有三级缓存（客户端本地、CDN L1、CDN L2）<br><br>一致性<span class="hljs-built_in">hash</span><br><br>CDN边缘IP<br></code></pre></td></tr></table></figure><h3 id="OSS"><a href="#OSS" class="headerlink" title="OSS"></a>OSS</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">Operation</span> Support Systems<br><br>操作支持系统<br></code></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/36514327?rf=37353035">知乎 - CDN是什么？使用CDN有什么优势？</a></p>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CDN</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域驱动模型设计简单应用</title>
    <link href="/2023/04/08/architecture/%E8%A7%A3%E6%9E%84%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2023/04/08/architecture/%E8%A7%A3%E6%9E%84%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="专业术语"><a href="#专业术语" class="headerlink" title="专业术语"></a>专业术语</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Domain</span>-Driven Design 领域驱动设计<br>DataAccessobjects DAO 数据存取对象<br>PersistenceObject PO 持久化层对象<br>DataTransferObject DTO 数据传输对象<br>ViewObject VO 视图对象<br>DomainObject <span class="hljs-keyword">DO</span> 领域对象<br><span class="hljs-keyword">view</span> 展现层     <br>service 服务层  <br>po 数据持久化层<br>防腐 领域之间互相访问获取到的其他域的模型需要转换映射到自己域的模型（域之间可能会有相互的依赖，需要注意域之间的防腐，并且依赖注入的方式注入而不是直接<span class="hljs-built_in">New</span>其他域的对象出来使用）<br>界限 域拆分依据业务水平拆分，平行而非上下<br>领域驱动三层架构 API层\<span class="hljs-keyword">Domain</span>层\Repository层<br></code></pre></td></tr></table></figure><h3 id="领域驱动三层架构"><a href="#领域驱动三层架构" class="headerlink" title="领域驱动三层架构"></a>领域驱动三层架构</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">API层\<span class="hljs-keyword">Domain</span>层\Repository层<br>API层负责对外的rpc\http接口<br><span class="hljs-keyword">Domain</span>层领域逻辑层，负责组装数据源代理层 po 返回的数据模型，转换为领域模型<span class="hljs-keyword">Domain</span> <span class="hljs-keyword">Object</span><br><br>Repository层是数据源代理层，比如有一层抽象 interface GetUser 那么这个<span class="hljs-keyword">User</span>内部可能有多<br>个实现有 Elastic\MySQL\MongoDB，也可以是以HTTP或者RPC为数据源<br>而数据源代理层再底层就是持久化层或者RPC依赖等<br><br>有什么用？<br><br>按照数据流向是一个垂直分层的结构<br>PO层可以随时更换比如MySQL更换为MongoDB<br><span class="hljs-keyword">Domain</span>域模型是固定的，逻辑是抽象可更改实现<br>API层负责对外模型与前端或者其他微服务<br><br><span class="hljs-number">1.</span> 单元测试，解耦有利于对每一层测试覆盖<br><span class="hljs-number">2.</span> 可扩展性，解耦有利于各个业务之间剥离比如将两个同属一个微服务的域拆成两个微服务或者独立他们依赖的持久化层<br></code></pre></td></tr></table></figure><h3 id="领域驱动下的项目层级"><a href="#领域驱动下的项目层级" class="headerlink" title="领域驱动下的项目层级"></a>领域驱动下的项目层级</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── application<br>│   ├── admin_service<br>│   │   ├── dto<br>│   │        └── user<span class="hljs-selector-class">.go</span><br>│   │   └── grpc<br>│   │        └── user_rpc<span class="hljs-selector-class">.go</span><br>│   ├── event<br>│        └── user_event<span class="hljs-selector-class">.go</span><br>│   ├── message<br>│        └── user_message<span class="hljs-selector-class">.go</span><br>│   └── front_service<br>│       ├── dtos<br>│       └── http<br>│   └────── init<span class="hljs-selector-class">.go</span> <br>├── config<br>│   └── config<span class="hljs-selector-class">.go</span> <br>├── domain<br>│   ├── common<br>│   │   ├── entity<br>│   │         └──----------- do<span class="hljs-selector-class">.go</span> <br>│   │   └── repository<br>│   │         └──----------- repository<span class="hljs-selector-class">.go</span><br>│   │         └──----------- po<span class="hljs-selector-class">.go</span><br>│   │         └──----------- mysql_po<span class="hljs-selector-class">.go</span><br>│   │         └──----------- elastic_po<span class="hljs-selector-class">.go</span><br>│   │   service<span class="hljs-selector-class">.go</span><br>│   ├── user<br>│   │   ├── entity<br>│   │   └──----------- do<span class="hljs-selector-class">.go</span> <br>│   │   └── repository<br>│   │   └──----------- repository<span class="hljs-selector-class">.go</span><br>│   │   └──----------- po<span class="hljs-selector-class">.go</span><br>│   │   └──----------- mysql_po<span class="hljs-selector-class">.go</span><br>│   │   └──----------- elastic_po<span class="hljs-selector-class">.go</span><br>│   │   service<span class="hljs-selector-class">.go</span><br>├── global<br>│   ├── cache<br>│   ├── enum<br>│   └── router<br>├── cmd<br>│   └── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.go</span><br>└── helper<br>    └── times.go<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs markdown">如上所示<br><br><span class="hljs-bullet">1.</span> domain里有通用域common、业务域user等<br><span class="hljs-bullet">2.</span> application提供对外的API层（http或者rpc形式）同时 application 依赖 domain.user\domain.book等<br><span class="hljs-bullet">3.</span> event 是领域事件，这里没有写入domain而是直接挂一级目录，承载各个定时程序<br><span class="hljs-bullet">4.</span> message 消息处理，这里负责对一些外部消息接收处理比如kafka的messsage.consumer<br><span class="hljs-bullet">5.</span> config 配置依赖处理<br><span class="hljs-bullet">6.</span> cmd 编译入口也是程序执行入口<br><span class="hljs-bullet">7.</span> global 与helper不一样的是这里的都是耦合业务的一些通用的枚举值、缓存key管理、路由等<br><span class="hljs-bullet">8.</span> helper 工具类<br></code></pre></td></tr></table></figure><h3 id="其他的私有Git库依赖"><a href="#其他的私有Git库依赖" class="headerlink" title="其他的私有Git库依赖"></a>其他的私有Git库依赖</h3><ol><li>util  工具库(完全与业务无耦合)</li><li>config 通用配置结构体定义(配置结构体\nacos配置加载\填充团队的默认配置比如kafka的消费心跳、poll数量、mongodb的集群配置样例等)</li><li>proto RPC接口(具体实现的server和调用client在其他微服务)</li><li>logger 日志类库(实现与zap\logrus\log一致的抽象、接入企业微信告警、邮箱告警、Elastic持久化日志(异步主动push形式采集或者打印标准输出宿主机的Filebeat采集))</li><li>common_errors 通用错误定义(错误码\错误提示\国际化等)</li><li>gin-middleware 通用的中间件(prometheus.request.metrics\jwt\encrypt请求解密\敏感字符过滤器等)</li><li>common 微服务中通用基础库(与业务有耦合定义kafka\redis\mysql\elastic的客户端client.Builder)</li></ol><h3 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h3><p><a href="https://www.runoob.com/note/27029">Java DAO 模式</a><br><a href="https://zhuanlan.zhihu.com/p/91525839">DDD实践 知乎专栏</a><br><a href="https://tech.meituan.com/2017/12/22/ddd-in-practice.html">美团DDD实践</a></p>]]></content>
    
    
    <categories>
      
      <category>领域驱动设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>领域驱动模型设计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务 Distributed Transaction</title>
    <link href="/2023/04/08/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/04/08/architecture/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p><a href="http://icyfenix.cn/architect-perspective/general-architecture/transaction/distributed.html">分布式事务</a></p><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><blockquote><p>三个特性最多只能同时满足其中两个</p></blockquote><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">一致性（<span class="hljs-variable">Consistency</span>）<br>可用性（<span class="hljs-variable">Availability</span>）<br>分区容忍性（<span class="hljs-built_in">Partition</span> <span class="hljs-built_in">Tolerance</span>）<br></code></pre></td></tr></table></figure><ol><li>多节点为了数据一致性，数据同步阻塞服务，可用性就会变差；</li><li>多节点为了高可用，但数据同步不及时，一致性变差；</li><li>多节点因为部分节点连接中断，而无法正确提供服务，此为容忍性；</li></ol><h3 id="可靠事件队列"><a href="#可靠事件队列" class="headerlink" title="可靠事件队列"></a>可靠事件队列</h3><blockquote><p>譬如 TCP 协议中未收到 ACK 应答自动重新发包的可靠性保障就属于最大努力交付</p></blockquote><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">可靠事件队列只要第一步业务完成了，后续就没有失败回滚的概念，只许成功，不许失败<br><br>靠着持续重试来保证可靠性的解决方案<br><br>”最大努力交付“（<span class="hljs-keyword">Best-Effort </span>Delivery）<br></code></pre></td></tr></table></figure><h3 id="TCC-事务-Try-Confirm-Cancel"><a href="#TCC-事务-Try-Confirm-Cancel" class="headerlink" title="TCC 事务(Try-Confirm-Cancel)"></a>TCC 事务(Try-Confirm-Cancel)</h3><ol><li>Try：尝试执行阶段</li><li>Confirm：确认执行阶段</li><li>Cancel：取消执行阶段</li></ol><blockquote><p>用户花钱了冻结金额，用户买书了就冻结书籍状态，讲究资源锁定</p></blockquote><blockquote><p>业务侵入性很强</p></blockquote><h3 id="SAGA-事务"><a href="#SAGA-事务" class="headerlink" title="SAGA 事务"></a>SAGA 事务</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm">分布式事务 T 分解为 n 个子事务，命名为 T1，T2，… ， 每一个子事务设计对应的补偿动作，命名为 <span class="hljs-built_in">C1</span>，<span class="hljs-built_in">C2</span>，…<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 子事务必须原子行为<br><span class="hljs-bullet">2.</span> Ti和Ci都具备幂等性<br><span class="hljs-bullet">3.</span> Ti与Ci满足交换律<br><span class="hljs-bullet">4.</span> Ci必须能成功提交<br></code></pre></td></tr></table></figure><ol><li>正向恢复（Forward Recovery） Ti事务提交失败，则一直对 Ti进行重试，直至成功为止</li></ol><blockquote><p>执行模式为：T1，T2，…，Ti（失败），Ti（重试）…，Ti+1，…，Tn</p></blockquote><ol start="2"><li>反向恢复（Backward Recovery）Ti事务提交失败，则一直执行 Ci对 Ti进行补偿，直至成功为止</li></ol><blockquote><p>执行模式：T1，T2，…，Ti（失败），Ci（补偿），…，C2，C1</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s的一些插件安装</title>
    <link href="/2023/04/08/kubernetes/k8s%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2023/04/08/kubernetes/k8s%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="containerd-二进制安装"><a href="#containerd-二进制安装" class="headerlink" title="containerd 二进制安装"></a>containerd 二进制安装</h3><p><a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md">github.com&#x2F;containerd&#x2F;containerd&#x2F;blob&#x2F;main&#x2F;docs&#x2F;getting-started.md</a></p><p><a href="https://github.com/containerd/containerd/releases">github.com&#x2F;containerd&#x2F;containerd&#x2F;releases</a></p><h3 id="二进制包的命名格式"><a href="#二进制包的命名格式" class="headerlink" title="二进制包的命名格式"></a>二进制包的命名格式</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">containerd-&lt;VERSION&gt;-&lt;OS&gt;-&lt;ARCH&gt;.tar.gz<br><br>https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/containerd/</span>containerd<span class="hljs-regexp">/releases/</span>tag/v1.<span class="hljs-number">6.19</span><br>containerd-<span class="hljs-number">1.6</span>.<span class="hljs-number">19</span>-linux-arm64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> Cxzvf /usr/local containerd-<span class="hljs-number">1</span>.<span class="hljs-number">6</span>.<span class="hljs-number">19</span>-linux-arm64.tar.gz<br></code></pre></td></tr></table></figure><h3 id="配置-systemctl"><a href="#配置-systemctl" class="headerlink" title="配置 systemctl"></a>配置 systemctl</h3><p><a href="https://github.com/containerd/containerd/blob/v1.6.19/containerd.service">https://github.com/containerd/containerd/blob/v1.6.19/containerd.service</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>systemd/system<br><br>上述文件下载到 (注意下载对应的版本号的)<br><br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/lib/</span>systemd<span class="hljs-regexp">/system/</span>containerd.service<br><br><span class="hljs-comment"># 重新加载 service 文件</span><br>$ systemctl daemon-reload<br></code></pre></td></tr></table></figure><h3 id="runc安装"><a href="#runc安装" class="headerlink" title="runc安装"></a>runc安装</h3><p><a href="https://github.com/opencontainers/runc/releases">https://github.com/opencontainers/runc/releases</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">安装到 <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/sbin/</span>runc<br><br>cp runc.arm64 <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>runc<br>chmod +x <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>runc<br></code></pre></td></tr></table></figure><h3 id="安装-CNI-插件"><a href="#安装-CNI-插件" class="headerlink" title="安装 CNI 插件"></a>安装 CNI 插件</h3><p><a href="https://github.com/containernetworking/plugins/releases">https://github.com/containernetworking/plugins/releases</a></p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle">mkdir -p <span class="hljs-regexp">/opt/</span>cni/bin<br><br># 解压到目录 <span class="hljs-regexp">/opt/</span>cni/bin<br>tar Cxzvf <span class="hljs-regexp">/opt/</span>cni/bin cni-plugins-linux-amd64-v1.<span class="hljs-number">1.1</span>.tgz<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 启动 containerd 并设置开机启动 </span><br>systemctl <span class="hljs-built_in">enable</span> containerd<br></code></pre></td></tr></table></figure><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">containerd -v</span><br><span class="hljs-attribute">runc -v</span><br></code></pre></td></tr></table></figure><h3 id="配置文件-x2F-etc-x2F-containerd-x2F-config-toml"><a href="#配置文件-x2F-etc-x2F-containerd-x2F-config-toml" class="headerlink" title="配置文件 &#x2F;etc&#x2F;containerd&#x2F;config.toml"></a>配置文件 &#x2F;etc&#x2F;containerd&#x2F;config.toml</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 生成默认配置</span><br>mkdir -p <span class="hljs-string">/etc/containerd/</span><br>containerd config default &gt; <span class="hljs-string">/etc/containerd/config.toml</span><br><br>vi <span class="hljs-string">/etc/containerd/config.toml</span><br><span class="hljs-comment"># [plugins.&quot;io.containerd.grpc.v1.cri&quot;] 下的 sandbox_image</span><br><span class="hljs-comment"># 修改为一个你可以获取到镜像的源地址，例如aliyun的</span><br>sandbox_image=<span class="hljs-string">&quot;registry.aliyuncs.com/google_containers/pause:3.5&quot;</span><br><br><span class="hljs-comment"># 还有需要加上下面</span><br>在[plugins.<span class="hljs-string">&quot;io.containerd.grpc.v1.cri&quot;</span><span class="hljs-string">.containerd.runtimes.runc</span>]中加入<br>  <span class="hljs-string">...</span><br>  [plugins.<span class="hljs-string">&quot;io.containerd.grpc.v1.cri&quot;</span><span class="hljs-string">.containerd.runtimes.runc.options</span>]<br>    SystemdCgroup = <span class="hljs-literal">true</span><br><br><span class="hljs-comment"># 重启 containerd</span><br>sudo systemctl restart containerd<br></code></pre></td></tr></table></figure><h1 id="crictl-安装"><a href="#crictl-安装" class="headerlink" title="crictl 安装"></a>crictl 安装</h1><p><a href="https://github.com/kubernetes-sigs/cri-tools/releases/">https://github.com/kubernetes-sigs/cri-tools/releases/</a></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf crictl-v1.<span class="hljs-number">24</span>.<span class="hljs-number">0</span>-linux-amd64.tar.gz -C /usr/local/bin<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat &gt; <span class="hljs-regexp">/etc/</span>crictl.yaml &lt;&lt;EOF<br>runtime-endpoint: unix:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/containerd/</span>containerd.sock<br>image-endpoint: unix:<span class="hljs-regexp">//</span><span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/containerd/</span>containerd.sock<br>timeout: <span class="hljs-number">10</span><br>debug: false<br>pull-image-on-create: false<br>EOF<br></code></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 重启服务</span><br><span class="hljs-attribute">systemctl</span> daemon-reload<br>sytemctl restart containerd<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">ctr作为 containerd 项目的一部分，是安装 containerd 时默认提供的命令行客户端，具有镜像和容器管理的简单功能<br>crictl是遵循 CRI 接口规范的一个命令行工具，通常用它来检查和管理 kubernetes 节点上的容器运行时和镜像<br>nerdctl是一个相对较新的containerd命令行客户端。与ctr不同，nerdctl的目标是对用户友好并且和 docker兼容<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/qq_25874461/article/details/128358829">参考文档</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>runc</tag>
      
      <tag>containerd</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubectl一些常用的命令</title>
    <link href="/2023/04/08/kubernetes/kubectl_command/"/>
    <url>/2023/04/08/kubernetes/kubectl_command/</url>
    
    <content type="html"><![CDATA[<h3 id="命令式对象管理"><a href="#命令式对象管理" class="headerlink" title="命令式对象管理"></a>命令式对象管理</h3><ol><li>查看所有的pod</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pods<br></code></pre></td></tr></table></figure><ol start="2"><li>查看某个pod，以yaml格式展示结果</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pod pod_name -o yaml<br></code></pre></td></tr></table></figure><ol start="3"><li>kubernetes中所有的内容都抽象为资源，可以通过下面的命令进行查看</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl api-resources<br></code></pre></td></tr></table></figure><ol start="4"><li>创建一个namespace</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl create namespace dev<br></code></pre></td></tr></table></figure><ol start="5"><li>获取namespace</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get namespace<br></code></pre></td></tr></table></figure><ol start="6"><li>获取namespace</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get namespace<br>$ kubectl get ns<br></code></pre></td></tr></table></figure><ol start="7"><li>在刚才创建的namespace下创建并运行一个Nginx的Pod</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl run nginx --image=nginx:1.17.1 -n dev<br></code></pre></td></tr></table></figure><ol start="8"><li>查看名为dev的namespace下的所有Pod，如果不加-n，默认就是default的namespace</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pods [-n 命名空间的名称]<br>$ kubectl get pods -n dev<br></code></pre></td></tr></table></figure><ol start="9"><li>删除指定namespace下的指定Pod</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl delete pod nginx -n dev<br></code></pre></td></tr></table></figure><ol start="10"><li>删除指定的namespace</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl delete namespace dev<br></code></pre></td></tr></table></figure><ol start="11"><li>创建一个nginxpod.yaml，内容如下</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Namespace</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginxpod</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-containers</span><br>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br></code></pre></td></tr></table></figure><ol start="12"><li>执行create命令，创建资源</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl create -f nginxpod.yaml<br></code></pre></td></tr></table></figure><ol start="13"><li>执行get命令，查看资源：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get -f nginxpod.yaml<br></code></pre></td></tr></table></figure><ol start="14"><li>执行delete命令，删除资源：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl delete -f nginxpod.yaml<br></code></pre></td></tr></table></figure><h3 id="资源管理方式总结"><a href="#资源管理方式总结" class="headerlink" title="资源管理方式总结"></a>资源管理方式总结</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">a. 命令式对象管理：直接使用命令去操作kubernetes的资源。<br>b. 命令式对象配置：通过命令配置和配置文件去操作kubernetes的资源。<br>c. 声明式对象配置：通过<span class="hljs-built_in">apply</span>命令和配置文件去操作kubernetes的资源<br><br>创建和更新资源使用声明式对象配置：kubectl <span class="hljs-built_in">apply</span> -f xxx.yaml。<br>删除资源使用命令式对象配置：kubectl <span class="hljs-built_in">delete</span> -f xxx.yaml。<br>查询资源使用命令式对象管理：kubectl <span class="hljs-built_in">get</span>(<span class="hljs-built_in">describe</span>) 资源名称。<br></code></pre></td></tr></table></figure><ol><li>查看Pod的详细信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl describe pod pod的名称 [-n 命名空间名称]<br>$ kubectl describe pod nginx -n dev<br></code></pre></td></tr></table></figure><ol start="2"><li>Pod的访问</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 获取Pod的IP</span><br>$ kubectl get pods [-n dev] -o wide<br><br><span class="hljs-comment"># 获取nginx的访问信息</span><br>$ kubectl get pods -n dev -o wide<br><br><span class="hljs-comment"># 通过curl访问</span><br>$ curl ip:端口<br><br><br><span class="hljs-comment"># 删除指定的Pod</span><br>$ kubectl delete pod pod的名称 [-n 命名空间]<br>$ kubectl delete pod nginx -n dev<br></code></pre></td></tr></table></figure><ol start="3"><li>新建pod-nginx.yaml：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><ol start="4"><li>执行创建和删除命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl create -f pod-nginx.yaml<br>$ kubectl delete -f pod-nginx.yaml<br></code></pre></td></tr></table></figure><p>Label是kubernetes的一个重要概念。它的作用就是在资源上添加标识，用来对它们进行区分和选择<br>key&#x2F;value键值对的形式\一个资源对象可以定义任意数量的Label</p><p>示例 pod-nginx.yaml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.0&quot;</span><br>    <span class="hljs-attr">env:</span> <span class="hljs-string">&quot;test&quot;</span>        <br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>    <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">IfNotPresent</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">pod</span><br>    <span class="hljs-attr">ports:</span> <br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-port</span><br>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行创建和删除命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl create -f pod-nginx.yaml<br>$ kubectl delete -f pod-nginx.yaml<br></code></pre></td></tr></table></figure><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><ol><li>创建指定名称的deployement</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl create deployment xxx [-n 命名空间]<br>$ kubectl create deploy xxx [-n 命名空间]<br><span class="hljs-comment"># 示例: 在名称为test的命名空间下创建名为nginx的deployment</span><br>$ kubectl create deployment nginx --image=nginx:1.17.1 -n <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="2"><li>根据指定的deplyment创建Pod</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl scale deployment xxx [--replicas=正整数] [-n 命名空间]<br><span class="hljs-comment"># 在名称为test的命名空间下根据名为nginx的deployment创建4个Pod</span><br>$ kubectl scale deployment nginx --replicas=4 -n dev<br></code></pre></td></tr></table></figure><ol start="3"><li>创建一个deploy-nginx.yaml</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.1</span><br>        <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span><br>        <span class="hljs-attr">ports:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><br>          <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br></code></pre></td></tr></table></figure><ol start="4"><li>执行创建和删除命令：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl create -f deploy-nginx.yaml<br>$ kubectl delete -f deploy-nginx.yaml<br></code></pre></td></tr></table></figure><ol start="5"><li>查看创建的Pod</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get pods [-n 命名空间]<br><span class="hljs-comment"># 查看名称为dev的namespace下通过deployment创建的3个Pod</span><br>$ kubectl get pods -n dev<br></code></pre></td></tr></table></figure><ol start="6"><li>查看deployment的信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get deployment [-n 命名空间]<br>$ kubectl get deploy [-n 命名空间]<br><span class="hljs-comment"># 示例: 查看名称为dev的namespace下的deployment</span><br>$ kubectl get deployment -n dev<br></code></pre></td></tr></table></figure><ol start="7"><li>查看deployment的详细信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl describe deployment xxx [-n 命名空间]<br>$ kubectl describe deploy xxx [-n 命名空间]<br><span class="hljs-comment"># 示例:查看名为dev的namespace下的名为nginx的deployment的详细信息</span><br>$ kubectl describe deployment nginx -n dev<br></code></pre></td></tr></table></figure><ol start="8"><li>删除deployment</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl delete deployment xxx [-n 命名空间]<br>$ kubectl delete deploy xxx [-n 命名空间]<br><span class="hljs-comment"># 示例：删除名为dev的namespace下的名为nginx的deployment</span><br>$ kubectl delete deployment nginx -n dev<br></code></pre></td></tr></table></figure><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Pod的IP会随着Pod的重建产生变化<br>Pod的IP仅仅是集群内部可见的虚拟的IP，外部无法访问。<br>Service可以看做是一组同类的Pod对外的访问接口，借助Service，应用可以方便的实现服务发现和负载均衡</p><h3 id="创建集群内部可访问的Service"><a href="#创建集群内部可访问的Service" class="headerlink" title="创建集群内部可访问的Service"></a>创建集群内部可访问的Service</h3><ol><li>暴露Service</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">### 会产生一个CLUSTER-IP，这个就是service的IP，在Service的生命周期内，这个地址是不会变化的<br>kubectl expose deployment xxx --name=服务名 --type=ClusterIP --port=暴露的端口 --target-port=指向集群中的Pod的端口 [-n 命名空间]<br>示例：暴露名为test的namespace下的名为nginx的deployment，并设置服务名为svc-nginx1<br>kubectl expose deployment nginx --name=svc-nginx1 --type=ClusterIP --port=80 --target-port=80 -n test<br></code></pre></td></tr></table></figure><ol start="2"><li>查看Service</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get service [-n 命名空间] [-o wide]<br><span class="hljs-comment"># 示例：查看名为test的命名空间的所有Service</span><br>$ kubectl get service -n <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h3 id="创建集群外部可访问的Service"><a href="#创建集群外部可访问的Service" class="headerlink" title="创建集群外部可访问的Service"></a>创建集群外部可访问的Service</h3><ol><li>暴露Service</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 会产生一个外部也可以访问的Service</span><br>$ kubectl expose deployment xxx --name=服务名 --<span class="hljs-built_in">type</span>=NodePort --port=暴露的端口 --target-port=指向集群中的Pod的端口 [-n 命名空间]<br><span class="hljs-comment"># 示例：暴露名为test的namespace下的名为nginx的deployment，并设置服务名为svc-nginx2</span><br>$ kubectl expose deploy nginx --name=svc-nginx2 --<span class="hljs-built_in">type</span>=NodePort --port=80 --target-port=80 -n <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="2"><li>查看Service</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get service [-n 命名空间] [-o wide]<br><span class="hljs-comment"># 示例：查看名为test的命名空间的所有Service</span><br>$ kubectl get service -n <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="3"><li>删除服务</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl delete service xxx [-n 命名空间]<br><span class="hljs-comment"># 示例：删除服务</span><br>$ kubectl delete service svc-nginx1 -n <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><ol start="4"><li>对象配置方式，新建svc-nginx.yaml,内容如下</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">svc-nginx</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">dev</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.109</span><span class="hljs-number">.179</span><span class="hljs-number">.231</span><br>  <span class="hljs-attr">ports:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">run:</span> <span class="hljs-string">nginx</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">ClusterIP</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行创建和删除命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl  create  -f  svc-nginx.yaml<br>$ kubectl  delete  -f  svc-nginx.yaml<br></code></pre></td></tr></table></figure><ol start="6"><li>获取pod IP<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ kubectl get po -o wide -n github<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubectl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>telepresence基本使用</title>
    <link href="/2023/04/08/kubernetes/tool_telepresence/"/>
    <url>/2023/04/08/kubernetes/tool_telepresence/</url>
    
    <content type="html"><![CDATA[<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">telepresence <span class="hljs-keyword">version</span><br>telepresence <span class="hljs-keyword">connect</span><br></code></pre></td></tr></table></figure><h3 id="集群连接"><a href="#集群连接" class="headerlink" title="集群连接"></a>集群连接</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ telepresence connect<br></code></pre></td></tr></table></figure><h3 id="开发和调试现有的服务"><a href="#开发和调试现有的服务" class="headerlink" title="开发和调试现有的服务"></a>开发和调试现有的服务</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-comment"># 远程流量发送到本地服务</span><br><br><span class="hljs-comment"># $SERVICE_NAME 是本地服务名称</span><br><span class="hljs-comment"># $LOCAL_PORT 是服务在本地工作站上运行的端口</span><br><span class="hljs-comment"># $REMOTE_PORT 是服务在集群中侦听的端口</span><br><br>telepresence intercept <span class="hljs-variable">$SERVICE_NAME</span> --port <span class="hljs-variable">$LOCAL_PORT</span><span class="hljs-symbol">:REMOTE_PORT</span><br></code></pre></td></tr></table></figure><h3 id="验证集群是否连接成功"><a href="#验证集群是否连接成功" class="headerlink" title="验证集群是否连接成功"></a>验证集群是否连接成功</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ping <span class="hljs-selector-attr">[$service_name]</span>.<span class="hljs-selector-attr">[$namespace]</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span><span class="hljs-selector-class">.local</span><br><br>ping login<span class="hljs-selector-class">.user</span><span class="hljs-selector-class">.svc</span><span class="hljs-selector-class">.cluster</span>.local<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://github.com/telepresenceio/telepresence">github telepresence</a><br><a href="https://kubernetes.io/zh-cn/docs/tasks/debug/debug-cluster/local-debugging/">本机连接到远程 Kubernetes 集群</a></p>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>telepresence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prometheus配置解析</title>
    <link href="/2023/04/08/prometheus/prometheus%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/04/08/prometheus/prometheus%E9%85%8D%E7%BD%AE%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="一、默认配置"><a href="#一、默认配置" class="headerlink" title="一、默认配置"></a>一、默认配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># 将刮擦间隔设置为每15秒。默认为1分钟一次</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># 每15秒评估一次规则。默认为1分钟。</span><br>  <span class="hljs-comment"># Scrape_timeout被设置为全局默认值(10秒)。</span><br><br><span class="hljs-comment"># 告警配置</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>          <span class="hljs-comment"># - alertmanager:9093</span><br><br><span class="hljs-comment"># 加载规则一次，并定期根据全局的“evaluation_interval”计算它们</span><br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-comment"># - &quot;first_rules.yml&quot;</span><br>  <span class="hljs-comment"># - &quot;second_rules.yml&quot;</span><br><br><span class="hljs-comment"># 一个抓取配置，只包含一个要抓取的端点:这里是Prometheus本身</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-comment"># 作业名称作为标签&#x27; job=&lt;job_name&gt; &#x27;添加到从此配置中提取的任何时间序列中</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;prometheus&quot;</span><br><br>    <span class="hljs-comment"># Metrics_path默认为“/metrics”</span><br>    <span class="hljs-comment"># scheme defaults to &#x27;http&#x27;.</span><br><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;localhost:9090&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="二、配置分类"><a href="#二、配置分类" class="headerlink" title="二、配置分类"></a>二、配置分类</h3><p>– 全局配置 global<br>– 告警配置 alerting<br>– 规则文件配置 rule_files<br>– 拉取配置 scrape_configs<br>– 远程读写配置 remote_read、remote_write</p><h3 id="三、源码配置结构"><a href="#三、源码配置结构" class="headerlink" title="三、源码配置结构"></a>三、源码配置结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// /prometheus/config/config.go</span><br><span class="hljs-comment">// Config is the top-level configuration for Prometheus&#x27;s config files.</span><br><span class="hljs-keyword">type</span> Config <span class="hljs-keyword">struct</span> &#123;<br>GlobalConfig   GlobalConfig    <span class="hljs-string">`yaml:&quot;global&quot;`</span><br>AlertingConfig AlertingConfig  <span class="hljs-string">`yaml:&quot;alerting,omitempty&quot;`</span><br>  ...<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://prometheus.io/docs/prometheus/latest/configuration/configuration/">prometheus.io&#x2F;docs 官网配置解析</a><br><a href="https://www.cnblogs.com/wangguishe/p/15598120.html">cnblogs.com Prometheus之配置详解</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>prometheus高可用方案预研</title>
    <link href="/2023/04/08/prometheus/prometheus%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E9%A2%84%E7%A0%94/"/>
    <url>/2023/04/08/prometheus/prometheus%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E9%A2%84%E7%A0%94/</url>
    
    <content type="html"><![CDATA[<h3 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">HCI超融合的监控，我们的应用程序将会和主机一起打包销售，给到客户的时候启动主机，这个主机有可能是<span class="hljs-number">1</span>台也有可能是<span class="hljs-number">3</span>台。<br>那么主机启动之后，监控服务随之启动<span class="hljs-comment">;</span><br>业务会暴露指标给prometheus采集<br>这里的prometheus如果有<span class="hljs-number">1</span>台主机那么就只有<span class="hljs-number">1</span>个监控服务，如果有<span class="hljs-number">3</span>台主机那么就会有<span class="hljs-number">3</span>个监控服务，<br>这<span class="hljs-number">3</span>台机器上面的<span class="hljs-number">3</span>个prometheus的实例各自的存储是独立的。<br></code></pre></td></tr></table></figure><h3 id="二、需求"><a href="#二、需求" class="headerlink" title="二、需求"></a>二、需求</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> prometheus任何一台宕机，监控情况正常；<br><span class="hljs-bullet">2.</span> prometheus独立于业务之外，监控不会影响业务，也就是在内存、磁盘等占用不会影响业务正常运行；<br></code></pre></td></tr></table></figure><h3 id="三、目标"><a href="#三、目标" class="headerlink" title="三、目标"></a>三、目标</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> prometheus的高可用方案（数据同步、配置热重载、主从选举）；<br><span class="hljs-bullet">2.</span> 限制prometheus的资源消耗；<br></code></pre></td></tr></table></figure><h3 id="四、数据同步方案"><a href="#四、数据同步方案" class="headerlink" title="四、数据同步方案"></a>四、数据同步方案</h3><ol><li>多个Prometheus采集完全一样的数据，外边挂负载均衡用于查询监控数据</li></ol><p><img src="/images/%E7%AE%80%E5%8D%95%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%A8%A1%E5%BC%8F.jpg" alt="简单的集群模式"></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">优点：<br>1.配置简单<br><br>缺点：<br>1.数据一致性取决于数据拉取频率，频率不高情况下，数据一致性较差；<br>2.数据拉取频率高的情况下，对于业务的指标采集接口增加了网络IO压力，并且随着主机增多，压力加大；<br>3.单机存储不适用于海量数据<br></code></pre></td></tr></table></figure><ol start="2"><li>多个prometheus将数据写入远程</li></ol><p><img src="/images/%E8%BF%9C%E7%A8%8B%E5%86%99%E6%A8%A1%E5%BC%8F%E4%B8%BB%E4%BB%8E.png" alt="远程写模式主从"></p><p>Prometheus的远程存储接口可以支持多种实现比如 Elasticsearch或者prometheus自身也提供了write接口；Prometheus 的 remote write 当 Prometheus 从目标上 pull 数据时，它会立即将这些数据写入本地存储，然后再将这些数据发送到远程写入端点。如果在此过程中发生错误，远程写入可能会失败，但不会导致数据丢失，因为数据已经写入了本地存储。 如果远程写入失败，会自动重试多次（次数可以配置）发送数据；</p><ul><li>优点：a.如果外挂存储引擎可以解决单机数据存储局限的问题；b.配置简单；</li><li>缺点：a.如果使用外部存储殷勤，需要额外部署一个远端数据存储服务；b.通过remote write失败会进行重试，这个重试次数和间隔不太好确定，不同的负载、业务需求都会不一样；</li></ul><ol start="3"><li>基于prometheus的federation联邦机制同步数据，做一主多从</li></ol><p>prometheus的端点/federate可以用于指标数据拉取，但是仅支持即时查询 Instant Query 返回的内容叫做即时向量 Instant Vector；同步时候仅仅可以获取当前某一个指标的最近的值；当新纳入一个节点时候，从prometheus从主prometheus拉取指标时候，只能拉取最新的指标，历史的指标不能拉取；所以新纳入一个节点，启动之前需要将主节点的prometheus的data数据目录同步过来，比如本地数据存储默认是 /data 目录。纳入新节点，开始同步文件到同步完成，最后启动从节点，这一段时间，主节点是仍然在工作的，这一段时间的指标，在从节点是不会被拉取的，会丢失。<p><p><img src="/images/%E8%81%94%E9%82%A6%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%BB%E4%BB%8E.png" alt="联邦模式的主从"></p><ul><li>优点：a.官方现有方案，配置相对简单；b.数据丢失范围相对可控，数据拉取间隔也是最大可能数据丢失间隔，比如从节点每隔10s拉一次cpu指标数据，那么从节点最大可能丢失10s的cpu指标数据；</li><li>缺点：a.无法拉取历史数据；b.一致性问题，主从同步延迟，查询从节点的监控数据会存在延迟；c.一主多从时候，对主节点的网络IO压力加大，但压缩传输消耗很小，很难达到瓶颈。</li></ul><h3 id="五、选主和配置热重载"><a href="#五、选主和配置热重载" class="headerlink" title="五、选主和配置热重载"></a>五、选主和配置热重载</h3><ol><li>基于etcd的分布式锁选主</li></ol><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">3台prometheus的选主逻辑:</span><br>主节点获得etcd的分布式锁，间隔30s租约续租方式保活，超过30s不续租，则会触发重新选主。<br>支持手动选主，手动选主的方式是，在主节点续租的时候判定是否存在手动设置的主节点<br>并且在选主的时候判定是否存在手动设置的主节点。<br></code></pre></td></tr></table></figure><p><img src="/images/%E5%9F%BA%E4%BA%8Eetcd%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%AE%9E%E7%8E%B0.png" alt="基于etcd的主从选举"></p><ol start="2"><li>配置热重载</li></ol><p>a.官方支持的 curl -X POST <a href="http://ip/-/reload%EF%BC%8C%E6%88%96%E8%80%85kill">http://IP/-/reload，或者kill</a> -HUP pid，会自动重新读取配置文件prometheus.yml；</p><p>优点：不用改造源码，方便后续prometheus升级；<br>缺点：需要程序操作生成yml配置文件并访问节点触发配置更新；</p><p>b.改造源码prometheus.Config.reloadConfig，实现基于ETCD的配置热重载，比如watch ETCD key并获取配置热重载。</p><p>优点：不需要admin程序直接访问prometheus节点，通过etcd解耦配置加载和写入；<br>缺点：改造源码后对后续升级不太友好，并且需要较多开发和测试成本投入；</p><h3 id="六、相关疑问"><a href="#六、相关疑问" class="headerlink" title="六、相关疑问"></a>六、相关疑问</h3><ol><li>磁盘限制</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">Prometheus中存储的每一个样本大概占用1-2字节大小<br>磁盘大小 = 保留时间 * 每秒获取样本数 * 样本大小<br>2byte * 1 * (3600*24*15) = 2.5GB<br>假设每秒钟采集cpu占用指标，并且保存数据1个月，消耗的磁盘是2.5GB<br><br>storage.tsdb.path 存储数据的目录，默认为data/<br>storage.tsdb.retention.time 数据过期清理时间，默认保存15天<br><br>单节点存储的限制，无法持久化海量的metrics数据，数据持久化的问题，默认保存15天<br>原生的TSDB对于大数据量的保存及查询支持不太友好 <br>所以并不适用于保存长期的大量数据（只能使用其他远程存储解决）一般Prometheus推荐只保留几周或者几个月的数据;<br></code></pre></td></tr></table></figure><ol start="2"><li>单机prometheus采集指标数量大了会影响性能吗</li></ol><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">一主的情况下，如果大量的target需要采集，prometheus pull的数据太多会带来以下几个问题</span><span class="hljs-punctuation">:</span><br><span class="hljs-attribute">1.带宽占用</span><br><span class="hljs-attribute">2.内存</span><br><span class="hljs-attribute">3.CPU</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">官方推荐的是做分片，比如ABC三台prometheus分别采集不同业务的Metrics</span><br><span class="hljs-attribute">最后有一个C prometheus通过联邦机制汇总所有监控数据用于查询</span><br><span class="hljs-attribute"></span><br><span class="hljs-attribute">但是关于带宽，prometheus的1个指标大概就 10bytes 例如</span><span class="hljs-punctuation">:</span><br><span class="hljs-punctuation"></span><br><span class="hljs-comment"># TYPE app_system_request counter</span><br>app_system_request 0<br></code></pre></td></tr></table></figure><ol start="3"><li>federate机制主从最大可能丢失的数据范围是多大</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">取决于拉取数据的间隔，间隔15s的话，如果主节点宕机，那么会丢失主节点15s以内的监控数据。<br></code></pre></td></tr></table></figure><ol start="4"><li>federate的拉取间隔会如何影响指标数据展示</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">假设federate的更新时间点是10s一次，而job=cpu的监控要求是2s一次<br>意味着从节点监控数据查询的话没办法实现高频率 (2s) 更新cpu指标监测<br>但可以针对不同的指标设置不同的采集频率，或将所有的查询请求打到主节点<br></code></pre></td></tr></table></figure><ol start="5"><li>单机的prometheus数据存储是多久</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">Prometheus TSDB (Time Series DataBase) 以时间线分块存储监控数据。<br>Prometheus的本地存储默认保留15天的数据，之后就会删除旧数据，间隔可以通过修改配置文件中的参数进行自定义。<br></code></pre></td></tr></table></figure><ol start="6"><li>主节点离线后再次接入监控集群，注册节点到选主再到切主成功大概需要多久</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">主节点离线，租约10s续约一次，假设主节点刚刚续约完就宕机了，那么在10s租约内，无法切主；<br>过了10s之后，从节点获得分布式锁，选主成功，之后触发配置更新和热重载。<br></code></pre></td></tr></table></figure><ol start="7"><li>etcd宕机了，prometheus的运行情况是什么样的</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">如果是主节点正常的情况下，从节点和主节点工作正常；<br>如果主节点不正常的情况下，从节点无法从主节点拉取数据，同时无法依赖etcd重新选主，从节点无法拉取指标；<br></code></pre></td></tr></table></figure><ol start="8"><li>采集指标带宽占用如何计算</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">看exporter数量，1个exportner采集目标一个http请求，一个指标大概就2kb<br><br>1个指标内容示例如下：<br># HELP app_system_request request counter<br># TYPE app_system_request counter<br>app_system_request 1<br></code></pre></td></tr></table></figure><ol start="9"><li>federate会同步历史数据吗</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">不会，联邦机制同步的是即使向量，走的是即使查询，历史的无法同步，需要手动同步文件系统通常是/data目录<br></code></pre></td></tr></table></figure><ol start="10"><li>prometheus的内存消耗如何计算</li></ol><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs fortran">首先存储结构来看，prometheus将数据按照时间段分块存储<br>每一块数据单位为<span class="hljs-keyword">Block</span>（<span class="hljs-keyword">Block</span>里面的单位是chunk1、chuck2...和<span class="hljs-built_in">index</span>、meta.json）；<br><br>内存消耗：<br><span class="hljs-number">1.</span>因为每隔<span class="hljs-number">2</span>小时有一个<span class="hljs-keyword">block</span>数据落盘，落盘之前所有数据都在内存里面（限制<span class="hljs-keyword">block</span>大小、缩短落盘间隔）;<br><span class="hljs-number">2.</span>数据查询时，是从磁盘到内存的，查询范围越大，内存越大;<br><br>内存消耗大小计算：<br>假设采集的指标只有<span class="hljs-number">1</span>个cpu的，cpu&#123;node=xxx&#125; 只有<span class="hljs-number">3</span>个node，每<span class="hljs-number">15</span>s采集一次，那么内存占用是<span class="hljs-number">2</span>mb；<br><br>如何降低内存消耗:<br><span class="hljs-number">1.</span>优化数据查询不要查询过大的时间范围的数据；<br><span class="hljs-number">2.</span>调整query timeout（查询超时时间）对于不合理的查询超时后及时回收资源；<br><span class="hljs-number">3.</span>--storage.tsdb.<span class="hljs-built_in">max</span>-<span class="hljs-keyword">block</span>-duration：该参数用于设置存储周期的最大时间范围，单位为小时。<br>    默认值为 <span class="hljs-number">2</span> 小时。可以根据需要适当调整该值，以减少存储需求和内存占用；<br><span class="hljs-number">4.</span>--storage.tsdb.<span class="hljs-built_in">max</span>-<span class="hljs-keyword">block</span>-<span class="hljs-built_in">size</span>：该参数用于设置每个块的最大大小，单位为字节。<br>    默认值为 <span class="hljs-number">512</span>MB。可以根据需要适当调整该值，以减少内存占用；<br><span class="hljs-number">5.</span>Linux 中可以使用 ulimit 命令限制prometheus内存占用；<br></code></pre></td></tr></table></figure><ol start="11"><li>如何手动干预选主</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">干预抢ETCD锁和续约过程就可以实现手动选主；<br></code></pre></td></tr></table></figure><ol start="12"><li>如何防止prometheus的内存爆满</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs txt">1. 配置合理的 retention time（数据保存周期）和 storage size（数据保存大小）。<br>  这样可以避免 Prometheus 存储过多无用的数据。<br>2. 使用短周期的数据抽样。通过将采样间隔降低到几秒钟，可以大大减少时间序列数据的数量。<br>3. 调整 query timeout（查询超时时间）。如果查询超时，则查询将被取消，从而避免资源的浪费。<br>4. 避免使用复杂的 PromQL 查询语句。复杂查询语句需要更多的计算资源，占用更多的内存。<br>5. 使用 Prometheus 的 remote write 功能，将数据推送到外部存储中，释放的内存压力。<br>6. 将 Prometheus 部署在资源较为充足的机器上，并尽可能提高机器的硬件配置。<br></code></pre></td></tr></table></figure><ol start="13"><li>如何控制prometheus运行内存占用大小</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs stylus">在 Prometheus 配置文件中，可以使用以下参数来设置最大内存占用：<br><br><span class="hljs-attr">--storage</span><span class="hljs-selector-class">.tsdb</span>.max-block-duration：该参数用于设置存储周期的最大时间范围，单位为小时。<br>  默认值为 <span class="hljs-number">2</span> 小时。可以根据需要适当调整该值，以减少存储需求和内存占用。<br><span class="hljs-attr">--storage</span><span class="hljs-selector-class">.tsdb</span>.retention：该参数用于设置每个使用者的数据保留时间。默认值为 <span class="hljs-number">15</span> 天。<br>  可以根据需要适当调整该值，以减少存储需求和内存占用。<br><span class="hljs-attr">--storage</span><span class="hljs-selector-class">.tsdb</span>.<span class="hljs-attribute">max-block-size</span>：该参数用于设置每个块的最大大小，单位为字节。<br>  默认值为 <span class="hljs-number">512</span>MB。可以根据需要适当调整该值，以减少内存占用。<br><br>另外，还可以通过以下参数来配置 Prometheus 进程的最大内存占用：<br><br><span class="hljs-attr">--storage</span><span class="hljs-selector-class">.tsdb</span>.no-lockfile：该参数用于禁用锁定文件，以减少磁盘 I/O。<br>  在高负载环境中使用该参数可能会导致内存占用增加，但可以提高性能。<br><span class="hljs-attr">--storage</span><span class="hljs-selector-class">.tsdb</span>.wal-compression：该参数用于启用 WAL 压缩，以减少磁盘 I/O 和内存占用。<br>  默认情况下，WAL 压缩是禁用的。可以根据需要启用该功能。<br><br>最后，还可以使用操作系统的资源限制功能来限制 Prometheus 进程的最大内存占用。<br>例如，在 Linux 中可以使用 ulimit 命令来设置进程的最大虚拟内存或物理内存限制。<br></code></pre></td></tr></table></figure><ol start="14"><li>prometheus版本升级和编译</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go build ./cmd/prometheus<br></code></pre></td></tr></table></figure><ol start="15"><li>storage.local.memory-chunks作用</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs txt">Prometheus的storage.local.memory-chunks是一个配置参数，<br>用于调整Prometheus本地存储的内存占用量，控制Prometheus在内存中保留的时间序列数据点数量。<br><br>具体来说，memory-chunks参数指定了Prometheus在内存中保留的时间序列数据块的数量。<br>每个数据块包含一组时间序列数据点，这些数据点按照时间排序，并按照其标记（labels）进行索引。<br>为了支持快速查询和聚合操作，Prometheus需要将一些时间序列数据点保留在内存中。<br>memory-chunks参数的值越高，Prometheus在内存中保留的时间序列数据点就越多，但同时也会占用更多的内存资源。<br><br>通过调整memory-chunks参数，用户可以平衡Prometheus在内存占用和查询性能之间的权衡。<br>如果Prometheus需要处理大量的时间序列数据点，可以增加memory-chunks的值，以提高查询性能。<br>但同时也需要确保Prometheus有足够的内存资源来存储这些数据点。<br></code></pre></td></tr></table></figure><ol start="16"><li>prometheus federation 和 remote write有哪些缺点</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Prometheus Federation 缺点：<br><br><span class="hljs-bullet">-</span> 需要手动配置和管理，对于大规模集群可能会增加管理成本。<br><span class="hljs-bullet">-</span> Federation 中的实例依赖于网络性能，如果网络延迟较高，则可能导致数据同步不及时。<br><span class="hljs-bullet">-</span> 不支持查询跨越多个 Federation 实例的聚合查询。<br><br>虽然也是即时向量查询 - 但是这个查询回溯间隔可以设置大一点比如设置query.lookback-delta=5m<br>那么可以查到倒计时5min内最后的指标<br>cpu&#123;node=xxx&#125;@1232134324 56<br><br><span class="hljs-bullet">2.</span> Remote Write 缺点：<br><br><span class="hljs-bullet">-</span> 需要对写入的数据进行格式化和编码，使其适用于远程写入的目标存储系统。<br><span class="hljs-bullet">-</span> 如果目标存储系统宕机或出现故障，数据可能会丢失或无法恢复。<br><span class="hljs-bullet">-</span> Remote Write 操作需要进行网络传输，可能存在网络延迟等问题，可能导致数据同步不及时。<br><br>丢数据相对概率大<br></code></pre></td></tr></table></figure><ol start="17"><li>是否可以remote write prometheus</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">感觉这个特点很多人不知道<br>以为 remote read\remote write 必须配置第三方存储如 m3db 等，<br>其实目标也可以prometheus实例<br>只不过需要开启 --enable-feature=remote-write-receiver<br></code></pre></td></tr></table></figure><ol start="18"><li>query.lookback-delta参数作用</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt">即时查询（Instant Query） 返回的内容叫做即时向量（ Instant Vector）<br><br>因为是即时，如果当时没有数据，它会往前追溯，找到一个时间点。<br>这个往回追溯的参数的值由 Prometheus 的启动参数 --query.lookback-delta 控制<br>这个参数默认是  5 分钟。从监控的角度来看，建议调短一些<br>比如改成 1 分钟 --query.lookback-delta=1m<br></code></pre></td></tr></table></figure><ol start="19"><li>范围查询（Range Query）写法</li></ol><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">范围查询（<span class="hljs-built_in">Range</span> <span class="hljs-built_in">Query</span>），返回的内容叫做 <span class="hljs-built_in">Range</span> <span class="hljs-variable">Vector</span><br><span class="hljs-punctuation">&#123;</span><span class="hljs-type">__name</span><span class="hljs-type">__</span><span class="hljs-operator">=~</span><span class="hljs-string">&quot;node_load.*&quot;</span><span class="hljs-operator">,</span> <span class="hljs-variable">zone</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;sh&quot;</span><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">[</span><span class="hljs-number">1</span><span class="hljs-variable">m</span><span class="hljs-punctuation">]</span><br>这个范围就是<span class="hljs-number">1</span>分钟，采集的多少个点都会返回<br></code></pre></td></tr></table></figure><ol start="20"><li>本地启动如何指定存储路径</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 数据存储在目录 /Users/Documents/data</span><br>$ ./prometheus --storage.tsdb.path=/Users/Documents/data \<br>    --config.file=/Users/Documents/prometheus.yml \<br>    --web.listen-address=:8989<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.kancloud.cn/pshizhsysu/prometheus/1803792">prometheus的时间序列指的是什么</a><br><a href="https://www.cnblogs.com/alchemystar/p/14462052.html">Prometheus时序数据库-磁盘中的存储结构</a><br><a href="https://www.robustperception.io/how-much-ram-does-prometheus-2-x-need-for-cardinality-and-ingestion/">根据指标数量和采集频率计算prometheus最大内存占用计算器</a><br><a href="https://github.com/ywanbing/golearning/tree/master/etcd_confd_prometheus">etcd + confd + prometheus 自动发现</a><br><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/sd/service-discovery-with-file">prometheus自带的基于文件的服务发现</a><br><a href="https://prometheus.io/blog/2015/08/17/service-discovery-with-etcd/">etcd 服务发现</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于docker搭建联邦机制主从同步</title>
    <link href="/2023/04/08/prometheus/%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BA%E8%81%94%E9%82%A6%E6%9C%BA%E5%88%B6%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/04/08/prometheus/%E5%9F%BA%E4%BA%8Edocker%E6%90%AD%E5%BB%BA%E8%81%94%E9%82%A6%E6%9C%BA%E5%88%B6%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="一、配置热重载"><a href="#一、配置热重载" class="headerlink" title="一、配置热重载"></a>一、配置热重载</h3><ol><li>main.main函数启动时候更改 config.LoadFile(cfg.configFile 为 config.LoadConfigFromEtcd(cfg.configFile,</li><li>在 &lt;-hub (chan os.Signal) 监听的select之中添加 &lt;-etcd.Listen() 监听，有配置更改时候调用 reladConfig 函数</li></ol><h3 id="二、federation"><a href="#二、federation" class="headerlink" title="二、federation"></a>二、federation</h3><ol><li>docker install两个prometheus</li><li>本地mac启动一个exporter暴露系统指标</li><li>指定一个prometheus采集指标</li><li>federation机制让另一个prometheus也采集到一样的指标</li></ol><h3 id="三、mac的本机器指标"><a href="#三、mac的本机器指标" class="headerlink" title="三、mac的本机器指标"></a>三、mac的本机器指标</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># https://prometheus.io/download/</span><br><span class="hljs-comment"># http://localhost:9100/metrics</span><br>$ ./node_exporter<br></code></pre></td></tr></table></figure><h3 id="四、主节点prometheus"><a href="#四、主节点prometheus" class="headerlink" title="四、主节点prometheus"></a>四、主节点prometheus</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network create p_net<br><br>$ docker run \<br>    --name master \<br>    -d \<br>    -p 9090:9090 \<br>    --network p_net \<br>    --network-alias master \<br>    -v /Users/master.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus \<br>    --query.lookback-delta=15d \<br>    --config.file=/etc/prometheus/prometheus.yml<br><br>$ ./prometheus --query.lookback-delta=15d \<br>--config.file=/prometheus/config.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># master.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;request_count&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/metrics&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;docker.for.mac.host.internal:6969&quot;</span>]<br></code></pre></td></tr></table></figure><h3 id="五、从节点prometheus"><a href="#五、从节点prometheus" class="headerlink" title="五、从节点prometheus"></a>五、从节点prometheus</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run \<br>    --name slave \<br>    -d \<br>    -p 8989:9090 \<br>    --network p_net \<br>    --network-alias slave \<br>    -v /home/prometheus.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># slave.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;federate&#x27;</span><br>    <span class="hljs-attr">scrape_timeout:</span> <span class="hljs-string">15s</span> <span class="hljs-comment"># timeout limit small than scrape_interval</span><br>    <span class="hljs-attr">body_size_limit:</span> <span class="hljs-number">0</span> <span class="hljs-comment"># no limit size</span><br>    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>    <span class="hljs-attr">honor_labels:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 保留原有metrics的标签</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/federate&#x27;</span><br>    <span class="hljs-attr">params:</span><br>      <span class="hljs-string">&#x27;match[]&#x27;</span><span class="hljs-string">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;&#123;__name__=~&quot;.+&quot;&#125;&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;master:9090&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="相关疑问"><a href="#相关疑问" class="headerlink" title="相关疑问"></a>相关疑问</h3><ul><li>如何解决docker exec容器报错su: must be suid to work properly</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -ti --user root 容器<span class="hljs-built_in">id</span> /bin/sh<br></code></pre></td></tr></table></figure><ul><li>在容器中如何访问宿主机服务</li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">ifconfig docker0 网卡IP<br>daemon.json 中定义的虚拟网桥来与宿主机进行通讯<br>域名 docker.for.mac.host.internal<br></code></pre></td></tr></table></figure><ul><li>如何配置pfederate拉取所有指标</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># slave</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span> <br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span> <br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;federate&#x27;</span><br>    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>    <span class="hljs-attr">honor_labels:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 保留原有metrics的标签</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/federate&#x27;</span><br>    <span class="hljs-attr">params:</span><br>      <span class="hljs-string">&#x27;match[]&#x27;</span><span class="hljs-string">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;&#123;__name__=~&quot;.+&quot;&#125;&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;master:9090&#x27;</span><br>    <span class="hljs-comment"># Endpoint的标签</span><br>    <span class="hljs-attr">relabel_configs:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">target_label:</span> <span class="hljs-string">&#x27;instance&#x27;</span><br>       <span class="hljs-attr">replacement:</span> <span class="hljs-string">&#x27;docker.for.mac.host.internal:6969&#x27;</span><br></code></pre></td></tr></table></figure><ul><li>健康检查接口</li></ul><p><a href="http://localhost:8989/-/healthy">http://localhost:8989/-/healthy</a></p><ul><li>基于ETCD选主3台prometheus实现高可用</li></ul><ol><li>主节点配置 scrape_configs 直接从exporter_node拉取数据</li><li>从节点配置 scrape_configs 从主节点通过 federate机制同步数据</li><li>每台prometheus守护进程中有一个定时器从 etcd 获取主节点的IP，通过&#x2F;-&#x2F;health判定主节点的存活状态</li><li>如果主节点挂了，选主，将新的主IP同步至etcd，并且更改各个节点的 prometheus配置</li><li>如果主节点挂了，发送告警</li><li>主节点拉取数据，从节点继续从主节点同步数据</li></ol><ul><li>基于ETCD的集群选主设计方案设计</li></ul><ol><li>master节点直接从http接口拉取数据</li><li>node节点从master&#x2F;federate端口拉取数据</li><li>master节点存活信息存储在etcd(etcd有一个TTL key)，master节点每隔30s发送一次心跳，重新设置TTL key否则任务master节点已经挂了</li><li>master节点挂了以后，剩下的节点竞选 - master节点出来以后，更新master节点的配置和更新node节点的配置，主要是实现主从</li></ol><ul><li>如何进入容器内部执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker <span class="hljs-built_in">exec</span> -it --user root <span class="hljs-variable">$&#123;容器id&#125;</span> /bin/sh<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://prometheus.io/docs/prometheus/latest/federation/">https://prometheus.io/docs/prometheus/latest/federation/</a><br><a href="http://flashcat.cloud/docs/content/flashcat-monitor/prometheus/ha/local-storage/">快猫监控P高可用</a><br><a href="https://blog.csdn.net/m0_60244783/article/details/127641195">本地存储配置</a><br><a href="https://www.ifsvc.cn/posts/156">https://www.ifsvc.cn/posts/156</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于远程写同步数据prometheus集群</title>
    <link href="/2023/04/08/prometheus/%E5%9F%BA%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%86%99%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AEprometheus%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/04/08/prometheus/%E5%9F%BA%E4%BA%8E%E8%BF%9C%E7%A8%8B%E5%86%99%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AEprometheus%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="一、从库搭建"><a href="#一、从库搭建" class="headerlink" title="一、从库搭建"></a>一、从库搭建</h3><ol><li>创建写主机配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> /Users/prometheus/slave.yml<br></code></pre></td></tr></table></figure><ol start="2"><li>写主机配置内容</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># write config</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br></code></pre></td></tr></table></figure><ol start="3"><li>启动写主机</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run \<br>    --name slave \<br>    -d \<br>    -p 7979:9090 \<br>    --network p_net \<br>    --network-alias slave \<br>    -v /Users/prometheus/write.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus \<br>    --web.enable-remote-write-receiver \<br>    --config.file=/etc/prometheus/prometheus.yml <br></code></pre></td></tr></table></figure><h3 id="二、主库搭建"><a href="#二、主库搭建" class="headerlink" title="二、主库搭建"></a>二、主库搭建</h3><ol><li>创建配置文件</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> /Users/prometheus/master.yml<br></code></pre></td></tr></table></figure><ol start="2"><li>文件配置内容</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># remote write</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">15s</span><br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">15s</span><br><span class="hljs-attr">remote_write:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&quot;http://slave:9090/api/v1/write&quot;</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;request_count&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/metrics&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;docker.for.mac.host.internal:6969&quot;</span>] <span class="hljs-comment"># 宿主机IP ifconfig获取 en0 的IP</span><br></code></pre></td></tr></table></figure><ol start="3"><li>启动数据采集节点</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run \<br>    --name master \<br>    -d \<br>    -p 8989:9090 \<br>    --network p_net \<br>    --network-alias master \<br>    -v /Users/prometheus/master.yml:/etc/prometheus/prometheus.yml \<br>    prom/prometheus<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/prometheus-remote-storage">远程存储</a></p><p><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/readmd/prometheus-and-high-availability">高可用方案选型</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地启动prometheus服务</title>
    <link href="/2023/04/08/prometheus/%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8prometheus%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/04/08/prometheus/%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8prometheus%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ /Users/xuweiqiang/Documents/data<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./prometheus --storage.tsdb.path=/Users/xuweiqiang/Documents/data \<br>--config.file=/Users/xuweiqiang/Documents/prometheus.yml \<br>--web.listen-address=:8989<br></code></pre></td></tr></table></figure><h3 id="自定义标签"><a href="#自定义标签" class="headerlink" title="自定义标签"></a>自定义标签</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">scrape_configs:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;my_job&#x27;</span><br>   <span class="hljs-attr">static_configs:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;my_target&#x27;</span>]<br>       <span class="hljs-attr">labels:</span><br>         <span class="hljs-attr">my_label:</span> <span class="hljs-string">&#x27;my_value&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><p>动态地添加标签或从其他源配置目标，请考虑使用服务发现或Relabeling等更高级的配置选项</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>module冲突</title>
    <link href="/2023/03/12/golang/module%E5%86%B2%E7%AA%81/"/>
    <url>/2023/03/12/golang/module%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<h3 id="一、由于依赖包k8s-io-x2F-apimachinery-latest不兼容company-x2F-client-go-x2F-cache导致的冲突"><a href="#一、由于依赖包k8s-io-x2F-apimachinery-latest不兼容company-x2F-client-go-x2F-cache导致的冲突" class="headerlink" title="一、由于依赖包k8s.io&#x2F;apimachinery@latest不兼容company&#x2F;client-go&#x2F;cache导致的冲突"></a>一、由于依赖包k8s.io&#x2F;apimachinery@latest不兼容company&#x2F;client-go&#x2F;cache导致的冲突</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><br><span class="hljs-comment"># 包company/client-go/cache与k8s.io/apimachinery@latest不兼容</span><br><span class="hljs-comment"># 需要指定k8s.io/apimachinery的版本为旧版 (默认会指向最新版)</span><br><span class="hljs-comment"># 并且k8s.io/api@latest也依赖了k8s.io/apimachinery@latest</span><br><span class="hljs-comment"># 所以k8s.io也需要指定旧版</span><br><br>company-nvs/internal/vnetstore imports<br>company/client-go/cache imports<br>k8s.io/apimachinery/pkg/util/clock: <br>module k8s.io/apimachinery@latest found (v0.27.3),<br>but does not contain package k8s.io/apimachinery/pkg/util/clock<br></code></pre></td></tr></table></figure><p><img src="/images/conflict-package.png" alt="go module冲突"></p><blockquote><p>解决问题的关键在于指定k8s.io&#x2F;apimachinery和k8s.io&#x2F;api的版本，但是很难找出k8s.io&#x2F;api的版本问题</p></blockquote><h3 id="二、解决包冲突的方式"><a href="#二、解决包冲突的方式" class="headerlink" title="二、解决包冲突的方式"></a>二、解决包冲突的方式</h3><h5 id="1-指定包apimachinery版本，看k8s-io-client-go和company-client-go都兼容"><a href="#1-指定包apimachinery版本，看k8s-io-client-go和company-client-go都兼容" class="headerlink" title="1.指定包apimachinery版本，看k8s.io/client-go和company/client-go都兼容"></a>1.指定包<code>apimachinery</code>版本，看<code>k8s.io/client-go</code>和<code>company/client-go</code>都兼容</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手动指定版本依赖</span><br>$ go mod edit -require k8s.io/apimachinery@v0.22.4<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">module</span> <span class="hljs-string">new_kube</span><br><br><span class="hljs-string">go</span> <span class="hljs-number">1.20</span><br><br><span class="hljs-string">require</span> <span class="hljs-string">(</span><br><span class="hljs-string">gitlab.company.net/company/client-go</span> <span class="hljs-string">v0.22.21</span><br>    <span class="hljs-string">//</span> <span class="hljs-string">手动指定的版本</span><br><span class="hljs-string">k8s.io/apimachinery</span> <span class="hljs-string">v0.22.4</span><br><span class="hljs-string">k8s.io</span> <span class="hljs-string">v0.22.4</span><br><span class="hljs-string">)</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">go</span> <span class="hljs-string">mod</span> <span class="hljs-string">tidy自动整理的依赖</span><br><span class="hljs-string">require</span> <span class="hljs-string">(</span><br><span class="hljs-string">github.com/davecgh/go-spew</span> <span class="hljs-string">v1.1.1</span> <span class="hljs-string">//</span> <span class="hljs-string">indirect</span><br><span class="hljs-string">github.com/go-logr/logr</span> <span class="hljs-string">v1.2.0</span> <span class="hljs-string">//</span> <span class="hljs-string">indirect</span><br><span class="hljs-string">github.com/gogo/protobuf</span> <span class="hljs-string">v1.3.2</span> <span class="hljs-string">//</span> <span class="hljs-string">indirect</span><br><span class="hljs-string">)</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看依赖关系</span><br>go mod graph | grep apimachinery<br>go <span class="hljs-built_in">help</span> mod<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清理已下载的模块缓存</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令会删除 `<span class="hljs-variable">$GOPATH</span>/pkg/mod/cache` 目录下的所有缓存文件</span><br>go clean -modcache<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清理未使用的模块缓存</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">该命令会检查项目中的依赖，并清理掉没有使用的模块缓存</span><br>go mod tidy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 `&lt;module&gt;` 替换为具体的模块路径，该命令会删除指定模块的缓存</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Go mod 的缓存是全局的，清理缓存可能会导致其他项目的构建时间增长</span><br>go clean -modcache -i &lt;module&gt;<br></code></pre></td></tr></table></figure><h5 id="2-更新company-client-go依赖的apimachinery版本"><a href="#2-更新company-client-go依赖的apimachinery版本" class="headerlink" title="2.更新company/client-go依赖的apimachinery版本"></a>2.更新<code>company/client-go</code>依赖的<code>apimachinery</code>版本</h5><p>就是更改<code>company/client-go</code>的代码，让其兼容<code>apimachinery@latest</code>;</p><h5 id="3-有时候无论怎么指定版本都无法生效"><a href="#3-有时候无论怎么指定版本都无法生效" class="headerlink" title="3.有时候无论怎么指定版本都无法生效"></a>3.有时候无论怎么指定版本都无法生效</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 比如明明指定版本 k8s.io/apimachinery v0.22.4</span><br><span class="hljs-comment"># 但是 go mod tidy时候却是 k8s.io/apimachinery v0.27.4</span><br><span class="hljs-comment"># 这是因为有其他包依赖了 @v0.27.4</span><br><br><br><span class="hljs-comment"># 查看依赖关系</span><br>$ go mod graph &gt; a.txt<br><br><span class="hljs-comment"># 有下面一行</span><br><span class="hljs-comment"># 是因为api版本27.4依赖了apimachinery@v0.27.4</span><br>k8s.io/api@v0.27.4 k8s.io/apimachinery@v0.27.4<br><br><span class="hljs-comment"># 所以指定使用才可以解决问题</span><br>k8s.io/api@v0.22.4<br></code></pre></td></tr></table></figure><h4 id="三、一些经验"><a href="#三、一些经验" class="headerlink" title="三、一些经验"></a>三、一些经验</h4><ol><li>直接依赖和间接依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 没有 indirect 的是直接依赖，可以直接后面的version指定版本</span><br><span class="hljs-comment"># 也可以通过 replace 指定版本</span><br><span class="hljs-comment"># indirect 是间接依赖会跟随着直接依赖的包升级而升级间接依赖</span><br>require (<br>github.com/bytedance/sonic v1.9.1 // indirect<br>)<br></code></pre></td></tr></table></figure><ol start="2"><li>如何找出直接依赖的包的位置</li></ol><blockquote><p>项目代码直接全局走索</p></blockquote><ol start="3"><li>如何找出间接依赖的包的引用位置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">go mod why go.uber.org/multierr<br>go mod graph<br></code></pre></td></tr></table></figure><h3 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h3><ul><li><a href="https://budougumi0617.github.io/2019/09/20/fix-go-mod-tidy-does-not-contain-package/">go mod tidy module x found, but does not contain package x</a></li><li><a href="https://www.jishuchi.com/books/gin-practice">Gin实践</a></li><li><a href="https://wu-sheng.gitbooks.io/opentracing-io/content/pages/quick-start.html">open-tracing中文版</a></li><li><a href="https://mp.weixin.qq.com/s/28UBEsLOAHDv530ePilKQA">Jaeger 链路追踪</a></li><li><a href="https://mp.weixin.qq.com/s/Ea28475_UTNaM9RNfgPqJA">路由中间件 - Jaeger 链路追踪</a></li><li><a href="https://www.jishuchi.com/read/gin-practice/3886">grpc实践</a></li><li><a href="https://www.jishuchi.com/read/gin-practice/3831">GC角度看内存损耗</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置traefik的ingress服务</title>
    <link href="/2023/01/19/cni/traefik%E9%85%8D%E7%BD%AEingress%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/01/19/cni/traefik%E9%85%8D%E7%BD%AEingress%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="一、docker配置traefik访问Nginx服务"><a href="#一、docker配置traefik访问Nginx服务" class="headerlink" title="一、docker配置traefik访问Nginx服务"></a>一、docker配置traefik访问Nginx服务</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">reverse-proxy:</span><br>    <span class="hljs-comment"># The official v2 Traefik docker image</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:v2.10</span><br>    <span class="hljs-comment"># Enables the web UI and tells Traefik to listen to docker</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">--api.insecure=true</span> <span class="hljs-string">--providers.docker</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-comment"># The HTTP port</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>      <span class="hljs-comment"># The Web UI (enabled by --api.insecure=true)</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:8080&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-comment"># So that Traefik can listen to the Docker events</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span><br>  <span class="hljs-attr">nginx:</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>   <span class="hljs-attr">labels:</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.http.routers.nginx.rule=Host(`yourdomain.com`)&quot;</span><br>     <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.http.services.nginx.loadbalancer.server.port=80&quot;</span><br>   <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker-compose up -d nginx<br><br>$ docker-compose up -d reverse-proxy<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 127.0.0.1 yourdomain.com</span><br>$ vim /etc/hosts<br></code></pre></td></tr></table></figure><ul><li><p><a href="yourdomain.com">访问Nginx服务yourdomain.com</a></p></li><li><p><a href="http://127.0.0.1:8080/dashboard/#/">访问traefik可视化界面</a></p></li></ul><h3 id="二、kubernetes配置traefik访问内部服务"><a href="#二、kubernetes配置traefik访问内部服务" class="headerlink" title="二、kubernetes配置traefik访问内部服务"></a>二、kubernetes配置traefik访问内部服务</h3><p><a href="https://doc.traefik.io/traefik/getting-started/quick-start-with-kubernetes/">https://doc.traefik.io/traefik/getting-started/quick-start-with-kubernetes/</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">[root@VM-8-4-centos ~]<span class="hljs-comment"># ls -l</span><br>00-account.yml             <span class="hljs-comment"># 创建账号</span><br>00-role.yml                <span class="hljs-comment"># 创建角色</span><br>01-role-binding.yml        <span class="hljs-comment"># 绑定账号角色</span><br>02-traefik-services.yml    <span class="hljs-comment"># 创建traefik服务</span><br>02-traefik.yml             <span class="hljs-comment"># traefik</span><br>03-whoami-services.yml     <span class="hljs-comment"># 创建测试用的服务</span><br>03-whoami.yml              <span class="hljs-comment"># 创建测试用的后端</span><br>04-whoami-ingress.yml      <span class="hljs-comment"># 给service绑定ingress</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安装nginx-ingress访问pod-nginx服务</title>
    <link href="/2023/01/19/cni/%E5%AE%89%E8%A3%85nginx-ingress%E8%AE%BF%E9%97%AEpod-nginx%E6%9C%8D%E5%8A%A1/"/>
    <url>/2023/01/19/cni/%E5%AE%89%E8%A3%85nginx-ingress%E8%AE%BF%E9%97%AEpod-nginx%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-nginx-pod"><a href="#1-nginx-pod" class="headerlink" title="1. nginx pod"></a>1. nginx pod</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-pod</span><br> <span class="hljs-attr">labels:</span><br>   <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">containers:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-container</span><br>   <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:latest</span><br><br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br><span class="hljs-attr">spec:</span><br> <span class="hljs-attr">selector:</span><br>   <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span><br> <span class="hljs-attr">ports:</span><br> <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>   <span class="hljs-attr">port:</span> <span class="hljs-number">80</span><br>   <span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><br>   <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30089</span><br> <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br></code></pre></td></tr></table></figure><h3 id="2-ingress-nginx"><a href="#2-ingress-nginx" class="headerlink" title="2. ingress-nginx"></a>2. ingress-nginx</h3><p><a href="https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.8.2/deploy/static/provider/cloud/deploy.yaml">install-ingress-nginx.yaml</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ helm upgrade --install ingress-nginx ingress-nginx \<br>  --repo https://kubernetes.github.io/ingress-nginx \<br>  --namespace ingress-nginx --create-namespace<br><br><br><span class="hljs-comment"># 更改镜像地址</span><br><span class="hljs-comment"># image: k8s.gcr.io/ingress-nginx/controller:v1.1.1@sha256:0bc88eb15f9e7f84e8e56c14fa5735aaa488b840983f87bd79b1054190e660de</span><br><span class="hljs-comment"># 变成</span><br><span class="hljs-comment"># image: registry.cn-hangzhou.aliyuncs.com/google_containers/nginx-ingress-controller:v1.1.1</span><br><br><span class="hljs-comment"># image: k8s.gcr.io/ingress-nginx/kube-webhook-certgen:v1.1.1@sha256:64d8c73dca984af206adf9d6d7e46aa550362b1d7a01f3a0a91b20cc67868660</span><br><span class="hljs-comment"># 变成</span><br><span class="hljs-comment"># image: registry.cn-hangzhou.aliyuncs.com/google_containers/kube-webhook-certgen:v1.1.1</span><br><br>$ kubectl apply -f install-ingress-nginx.yaml<br></code></pre></td></tr></table></figure><h3 id="3-创建ingress-yaml"><a href="#3-创建ingress-yaml" class="headerlink" title="3. 创建ingress yaml"></a>3. 创建ingress yaml</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">networking.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Ingress</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">minimal-ingress</span><br>  <span class="hljs-attr">annotations:</span><br>    <span class="hljs-attr">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="hljs-string">/</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">defaultBackend:</span><br>    <span class="hljs-attr">service:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br>      <span class="hljs-attr">port:</span><br>        <span class="hljs-attr">number:</span> <span class="hljs-number">8989</span><br>  <span class="hljs-attr">ingressClassName:</span> <span class="hljs-string">nginx-example</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">host:</span> <span class="hljs-string">myapp.com</span><br>    <span class="hljs-attr">http:</span><br>      <span class="hljs-attr">paths:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">/</span><br>        <span class="hljs-attr">pathType:</span> <span class="hljs-string">Prefix</span><br>        <span class="hljs-attr">backend:</span><br>          <span class="hljs-attr">service:</span><br>            <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-service</span><br>            <span class="hljs-attr">port:</span><br>              <span class="hljs-attr">number:</span> <span class="hljs-number">8989</span><br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash：q">$ kubectl get service -n ingress-nginx<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetes基础问题</title>
    <link href="/2023/01/19/cni/kubernetes%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/"/>
    <url>/2023/01/19/cni/kubernetes%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<ol><li><p>集群的cluser ip 可以直接访问吗</p></li><li><p>network policy</p></li><li><p>describe svc的时候endpoint可以直接访问吗</p></li><li><p>host network模式</p></li><li><p>cluster级别和namespace级别</p></li><li><p>pod的ip和service的cluster ip关系</p></li><li><p>cluster ip 可以访问吗 pod的ip可以访问吗</p></li><li><p>metadata\selector\label\annotations分别是干嘛的他们之间的关系是什么</p></li><li><p>k8s的cert-manager下的pod是干嘛的（证书的更新、颁发、管理）</p></li><li><p>k8s运行起来需要哪些组件（Mater组件、Node组件）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs s">要在Kubernetes上成功运行应用程序，需要部署以下组件：<br>1. Kubernetes Master组件：<br>  - kube-apiserver：提供Kubernetes API，并处理集群管理的核心功能。<br>  - kube-controller-manager：负责运行控制器，监控集群状态并处理集群级别的任务。<br>  - kube-scheduler：负责为Pod选择合适的节点进行调度。<br><br>2. Kubernetes Node组件：<br>  - kubelet：在每个节点上运行，负责管理和执行Pod的生命周期。<br>  - kube-proxy：负责实现Kubernetes服务的网络代理和负载均衡功能。<br>  - 容器运行时：如Docker、containerd等，负责在节点上启动和管理容器。<br><br>3. etcd：分布式键值存储系统，用于保存Kubernetes集群的状态和配置。<br><br>4. Kubernetes网络插件：用于实现Pod之间和Pod与外部网络的通信，常见的插件有Calico、Flannel、Weave等。<br><br>5. 可选组件：<br>  - kube-dns/coredns：为集群中的服务提供DNS解析。<br>  - Kubernetes Dashboard：提供Web界面用于管理和监控集群。<br>  - Ingress Controller：用于处理集群中的入口流量，并将流量路由到相应的服务。<br><br>除了以上核心组件，还可以根据需要添加其他组件和功能，如日志收集器、监控系统等。总之，以上组件是构成一个基本的Kubernetes集群所必需的组件，它们共同协作来实现容器编排和应用程序管理。<br></code></pre></td></tr></table></figure></li><li><p>k8s的权限管理是怎么样的</p></li><li><p>kube-proxy是干嘛的</p></li><li><p>kube-proxy的源码我应该怎么读，分哪几块理解，kube-proxy的设计是怎么样的</p></li><li><p>k8s初始运行多少个pod</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">cert-manager<br>kube-system\csi-cephfsplugin  存储标准<br>kube-system\elastic-autoscaler-manager<br>kube-systeme\etcd<br>kube-system\kube-apiserver<br>kube-system\kube-controller-manager<br>kube-system\kube-flannel<br>kube-system\traefik<br>kube-system\web-kubectl<br>kube-system\resourcequota-webhook-manage<br></code></pre></td></tr></table></figure></li><li><p>运行一个k8s，需要安装在宿主机的软件有哪些，比如cni插件二进制脚本需要安装在宿主机上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">在宿主机上安装和运行Kubernetes（k8s）集群，需要以下软件和工具：<br><br>1. 容器运行时（Container Runtime）：Kubernetes支持多个容器运行时，如Docker、containerd、CRI-O等。你需要在宿主机上安装所选容器运行时，并确保其能与Kubernetes集成。<br><br>2. kubeadm：这是一个用于部署和管理Kubernetes集群的命令行工具，需要在宿主机上进行安装。<br><br>3. kubelet：这是Kubernetes集群中每个节点上的主要组件，负责管理容器的生命周期和运行状态。kubeadm会自动安装和配置kubelet。<br><br>4. kubectl：这是Kubernetes的命令行工具，用于与集群进行交互、管理和监控。你需要在宿主机上安装kubectl。<br><br>5. CNI插件：CNI（Container Network Interface）是Kubernetes网络模型的一部分，它定义了容器网络如何与宿主机和其他容器进行通信。你需要选择一个CNI插件，如Flannel、Calico、Weave等，并将其二进制脚本安装在宿主机上。每个节点上的CNI插件负责为容器提供网络连接。<br><br>此外，如果你使用的是容器运行时Docker，那么你还需要在宿主机上安装Docker Engine。注意，Docker Engine与Docker CLI是两个不同的组件，你只需要安装Docker Engine。<br></code></pre></td></tr></table></figure></li><li><p>k8s的kubelet是一个常驻进程吗，它会和集群的哪些组件通讯，通讯的方式有哪些</p></li><li><p>k8s之中除了<code>/etc/kubernetes</code>文件夹还有哪些关于k8s的配置文件</p></li><li><p>宿主机上k8s相关的配置文件有哪些，比如&#x2F;etc&#x2F;kubernetes</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Kubernetes的配置文件在宿主机上主要包括以下几个目录和文件：<br>1. `/etc/kubernetes`：这个目录包含了Kubernetes主要的配置文件，其中一些重要的文件包括：<br>  - `/etc/kubernetes/kubelet.conf`：kubelet的配置文件，用于指定kubelet与Kubernetes API Server通信的参数和证书信息。<br>  - `/etc/kubernetes/admin.conf`和`/etc/kubernetes/kubeconfig`：Kubernetes管理员用户的配置文件，用于和Kubernetes API Server进行认证和授权。<br>  - `/etc/kubernetes/bootstrap-kubelet.conf`：kubelet在启动时使用的配置文件，用于节点加入集群时的认证和授权。<br>  - `/etc/kubernetes/pki`：存放集群的证书和密钥文件，用于内部通信的加密和身份验证。<br><br>2. `/etc/cni/net.d`：此目录包含了容器网络接口（CNI）插件的配置文件，用于设置容器的网络连接和路由。<br><br>3. `/etc/containerd`：这个目录包含了containerd的配置文件，containerd是Kubernetes默认的容器运行时。<br><br>4. `/etc/docker/daemon.json`：如果使用Docker作为容器运行时，这个文件是Docker Daemon的配置文件，可以包含Docker相关的配置参数。<br><br>上述目录中的配置文件对于Kubernetes的正常运行和配置非常重要。在配置Kubernetes集群时，这些文件需要正确配置和管理，以确保集群的稳定性和功能的正常实现。<br></code></pre></td></tr></table></figure></li><li><p>k8s的权限管理是怎么样的,和cluster级别namespace级别是什么关系</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Kubernetes (k8s) 的权限管理是通过访问控制模型来实现的，主要涉及以下两个层级的权限控制：<br><br>1. Cluster 级别：在 k8s 中，集群级别的权限是指对整个集群资源的访问权限。这包括对节点、命名空间、存储卷等集群级别对象的管理权限。集群管理员负责分配和管理这些权限，并可以使用 Role-Based Access Control (RBAC) 来定义集群级别的角色和角色绑定，以控制用户或服务账号对集群资源的访问权限。<br><br>2. Namespace 级别：命名空间是 k8s 中用于隔离不同工作负载和资源的逻辑分区。Namespace 级别的权限是指对特定命名空间内资源的访问权限。每个命名空间都可以有自己的角色和角色绑定，并且可以使用 RBAC 来定义和管理这些权限。命名空间管理员可以控制用户或服务账号的访问权限，并限制它们只能在特定命名空间内进行操作。<br><br>总结来说，Cluster 级别的权限控制集中管理对整个集群资源的访问权限，而 Namespace 级别的权限控制更加细粒度，可以根据特定命名空间的需求对资源的访问进行限制。实际上，Cluster 级别的权限是作为一个基础权限，而命名空间级别的权限则是在基础权限之上进行的补充和限制。<br></code></pre></td></tr></table></figure></li><li><p>如何查看k8s的资源cluster级别还是namespace级别</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">要查看 Kubernetes 中资源的级别，可以使用 kubectl 命令行工具，并结合资源的 API 对象来查询。<br><br>1. 查看 Cluster 级别资源：<br>  - 查看集群中的所有节点：`kubectl get nodes`<br>  - 查看集群中的所有命名空间：`kubectl get namespaces`<br>  - 查看集群中的所有存储卷：`kubectl get pv`<br>  - 查看集群中的所有角色：`kubectl get roles --all-namespaces`<br>  - 查看集群中的所有角色绑定：`kubectl get rolebindings --all-namespaces`<br><br>2. 查看 Namespace 级别资源：<br>  - 查看指定命名空间中的所有资源：`kubectl get all -n &lt;namespace&gt;`（例如 `kubectl get pods -n default`）<br>  - 查看指定命名空间中的所有角色：`kubectl get roles -n &lt;namespace&gt;`<br>  - 查看指定命名空间中的所有角色绑定：`kubectl get rolebindings -n &lt;namespace&gt;`<br><br>运行以上命令后，将根据资源的级别和命名空间的范围返回相应的结果。如果查询结果为空，则表示该级别或命名空间中没有对应的资源。****<br></code></pre></td></tr></table></figure></li><li><p>k8s之中node  namespace是集群级别资源，pod是namespace级别资源是吗</p></li><li><p>crd如何定义集群级别资源</p></li><li><p>k8s之中cluster级别的资源是不是无法为其分配在某一个namespace下面</p></li><li><p>ClusterRole、ClusterRoleBinding是什么，和k8s的权限有什么关系</p></li><li><p>解释一下<code>kubectl get ClusterRole</code>的结果是什么</p></li><li><p>ClusterRole指的是角色是吗，ClusterRoleBinding表示哪些对象拥有哪些角色是吗</p></li><li><p>如何更改CluserRole更改角色权限</p></li><li><p>ClusterRole指的是角色是吗，ClusterRoleBinding表示哪些对象拥有哪些角色是吗</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">ClusterRole（集群角色）指的是一组权限，用于定义在整个集群中可以执行的操作.<br>ClusterRoleBinding（集群角色绑定）则用于将角色绑定给特定的用户、服务账号或组，并指定它们具有的权限.<br></code></pre></td></tr></table></figure></li><li><p>k8s的kube-proxy是常驻的吗，是必须的吗</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">kube-proxy是Kubernetes中的一个核心组件，它负责处理集群内部的网络通信。kube-proxy通过实现服务发现和负载均衡来将请求转发到集群中的正确Pod。<br><br>kube-proxy通常是作为一个常驻进程运行在每个节点上的。<br><br>它通过监视Kubernetes API服务器中的Service和Endpoints对象的变化情况，并相应地更新本地的iptables规则或IPVS规则来实现负载均衡。<br>因此，kube-proxy运行的状态对于集群的正常运行是必要的。<br><br>总结：kube-proxy是常驻的，并且是Kubernetes集群正常运行所必需的。<br></code></pre></td></tr></table></figure></li><li><p>kube-proxy是以pod的形式运行还是在宿主机上常驻进程的形式运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">简单来说kube-proxy是监听svc和endpoint的变更，维护相关ipvs或者iptables的规则<br><br>kube-proxy可以以pod的形式运行，也可以在宿主机上作为常驻进程运行。<br><br>在较早的Kubernetes版本中，kube-proxy是以常驻进程的形式运行在宿主机上的。它监视Kubernetes集群中的服务和端口，并将流量转发到正确的目标。这种方式需要在每个节点上单独启动和管理kube-proxy进程。<br><br>从Kubernetes v1.14版本开始，kube-proxy可以以pod的形式运行。这个pod通常与kubelet一起运行在每个节点上，作为DaemonSet的一部分。以pod的形式运行kube-proxy可以更好地与Kubernetes的整体架构和生命周期管理集成，而且可以由Kubernetes自动进行调度和管理。<br></code></pre></td></tr></table></figure></li><li><p>k8s的coredns如何安装使用，是必须的吗，如何可以将baidu.com指向某一个特定的ip</p></li><li><p>ingress controller是干嘛的如何使用，跟Traefik什么关系 和<a href="https://kubernetes.github.io/ingress-nginx/deploy/">ingress-nginx</a>有什么关系</p></li><li><p>k8s的selector只认pod的metadata.labels是吗</p></li><li><p>k8s 的高可用如何实现的<br>   Master 节点的高可用：包括 Kubernetes API Server、etcd 存储、Controller Manager 和 Scheduler.<br>   Node 节点的高可用：多个节点上运行相同的工作负载来实现冗余<br>   容器的高可用：副本集 (ReplicaSet) 和水平自动扩缩容 (Horizontal Pod Autoscaling) 来确保容器的高可用性</p></li><li><p>k8s的集群的Master节点高可用是如何实现的</p></li><li><p>k8s的有状态应用有哪些，有状态指的是哪些状态<br>K8s（Kubernetes）的有状态应用指的是可以存储和维护数据状态的应用。与无状态应用不同，有状态应用需要保存一些持久化的数据，例如数据库中的数据、文件系统中的文件等。K8s中常见的有状态应用包括：<br>1. 数据库：如MySQL、PostgreSQL、MongoDB等。<br>2. 缓存系统：如Redis、Memcached等。<br>3. 文件存储系统：如Ceph、GlusterFS等。<br>4. 消息队列：如Kafka、RabbitMQ等。<br>5. 日志系统：如ELK（Elasticsearch、Logstash、Kibana）等。<br>6. 分布式文件系统：如HDFS（Hadoop Distributed File System）等。<br><br>这些有状态应用需要在容器中持久化存储数据，以便在容器重启或迁移时能够保留数据状态。K8s提供了一些机制来支持有状态应用的持久化存储需求，例如通过持久卷（Persistent Volume）和持久卷声明（Persistent Volume Claim）来实现数据的持久化存储和动态分配。</p></li><li><p>k8s的Controller Manager 和 Scheduler分别是干嘛的，底层逻辑是什么<br>Kubernetes (k8s)的Controller Manager和Scheduler是Kubernetes的两个核心组件，负责集群的自动化管理和任务调度。<br><br>- Controller Manager（控制器管理器）：Kubernetes的Controller Manager负责运行各种控制器来监控集群的状态，并确保集群中期望的状态与实际状态保持一致。控制器包括Replication Controller、Deployment Controller、StatefulSet Controller、DaemonSet Controller等。Controller Manager通过定期与API服务器进行通信来获取集群状态，并根据需要创建、更新或删除相应的资源对象。<br><br>- Scheduler（调度器）：Kubernetes的Scheduler负责将新的Pod（容器组）分配到集群中的节点上。调度器基于一组配置策略以及集群资源的可用性信息，选择最合适的节点来运行新的Pod。调度器将Pod绑定到目标节点，并将任务分配给相关的工作节点上的Kubelet进行处理。Scheduler会考虑节点资源利用率、节点亲和性、Pod的资源需求等因素来进行调度决策。<br><br>底层逻辑如下：<br>- Controller Manager的底层逻辑通过监听API服务器上的事件，根据事件触发的规则，在集群中创建、更新或删除相应的资源对象，以确保集群状态保持一致。它还通过与API服务器进行定期通信来获取集群状态，并监控资源对象的健康状态。<br>- Scheduler的底层逻辑基于一组预先定义的策略，通过与API服务器进行通信获取集群状态以及每个节点的资源信息。Scheduler会评估Pod的资源需求和节点的可用资源情况，根据策略选择最合适的节点，并将Pod绑定到目标节点上。<br><br>总之，Controller Manager和Scheduler是Kubernetes核心组件，负责集群的自动化管理和任务调度，保证集群状态一致性和高效资源利用。</p></li><li><p>k8s node的状态no-ready的时候如何解决问题，如何快速刷新这个node状态</p></li><li><p>k8s的节点异常出现NodeHasSufficientMemory怎么解决</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>alertmanager的历史告警</title>
    <link href="/2022/07/28/prometheus/alertmanager%E7%9A%84%E5%8E%86%E5%8F%B2%E5%91%8A%E8%AD%A6/"/>
    <url>/2022/07/28/prometheus/alertmanager%E7%9A%84%E5%8E%86%E5%8F%B2%E5%91%8A%E8%AD%A6/</url>
    
    <content type="html"><![CDATA[<h3 id="一、历史告警存档方案"><a href="#一、历史告警存档方案" class="headerlink" title="一、历史告警存档方案"></a>一、历史告警存档方案</h3><p><a href="https://prometheus.io/docs/operating/integrations/#alertmanager-webhook-receiver">官方webhook集成的方法</a></p><ol><li>alertsnitch + MySQL</li><li>alertmanager-webhook-logger</li></ol><h3 id="二、Alertmanager的本地存储"><a href="#二、Alertmanager的本地存储" class="headerlink" title="二、Alertmanager的本地存储"></a>二、Alertmanager的本地存储</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 本地存储格式和查看方式</span><br>alertmanager没有本地存储（持久化通过webhook适配）<br></code></pre></td></tr></table></figure><h3 id="三、服务搭建"><a href="#三、服务搭建" class="headerlink" title="三、服务搭建"></a>三、服务搭建</h3><h4 id="a-启动prometheus"><a href="#a-启动prometheus" class="headerlink" title="a.启动prometheus"></a>a.启动prometheus</h4><ol><li>prometheus配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Desktop/alert<br>$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Desktop/alert/rules<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/alert/prometheus.yml<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/alert/rules/one.yml<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># prometheus.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">5s</span> <br>  <span class="hljs-attr">evaluation_interval:</span> <span class="hljs-string">5s</span> <br><br><span class="hljs-comment"># Alertmanager configuration</span><br><span class="hljs-attr">alerting:</span><br>  <span class="hljs-attr">alertmanagers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">static_configs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">alert:9093</span><br><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&quot;request_count&quot;</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">&#x27;/metrics&#x27;</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&quot;docker.for.mac.host.internal:6969&quot;</span>] <span class="hljs-comment"># 宿主机IP ifconfig获取 en0 的IP</span><br><span class="hljs-comment"># Load rules once and periodically evaluate them according to the global &#x27;evaluation_interval&#x27;.</span><br><span class="hljs-attr">rule_files:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/etc/prometheus/rules/*.yml&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># one.yml</span><br><span class="hljs-attr">groups:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hostStatsAlert</span><br>  <span class="hljs-attr">rules:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">request_counter</span><br>    <span class="hljs-attr">expr:</span> <span class="hljs-string">app_system_request</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">3</span><br>    <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>    <span class="hljs-attr">annotations:</span><br>      <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;Instance <span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> request count too much&quot;</span><br>      <span class="hljs-attr">description:</span> <span class="hljs-string">&quot;<span class="hljs-template-variable">&#123;&#123; $labels.instance &#125;&#125;</span> request count above 3 (current value: <span class="hljs-template-variable">&#123;&#123; $value &#125;&#125;</span>)&quot;</span><br></code></pre></td></tr></table></figure><ol start="2"><li><p>启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run \<br>    --name alert_client \<br>    -d \<br>    -p 9090:9090 \<br>    --network p_net \<br>    --network-alias alert_client \<br>    -v /Users/xuweiqiang/Desktop/alert:/etc/prometheus/ \<br>    prom/prometheus \<br>    --config.file=/etc/prometheus/prometheus.yml<br></code></pre></td></tr></table></figure></li><li><p>模拟一个指标就是在本机启动一个request_counter指标</p></li></ol><p><a href="https://weiqiangxu.github.io/2023/04/10/prometheus/golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E6%8C%87%E6%A0%87exporter/">golang实现简单的指标exporter</a></p><h4 id="b-启动alertmanager"><a href="#b-启动alertmanager" class="headerlink" title="b.启动alertmanager"></a>b.启动alertmanager</h4><ol><li>创建配置</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Desktop/manager<br>$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Desktop/manager/data<br>$ <span class="hljs-built_in">mkdir</span> -p /Users/xuweiqiang/Desktop/manager/template<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/manager/alertmanager.yml<br>$ <span class="hljs-built_in">touch</span> /Users/xuweiqiang/Desktop/manager/template/email.tmpl<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># alertmanager.yml</span><br><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">resolve_timeout:</span> <span class="hljs-string">5m</span><br>  <span class="hljs-attr">smtp_from:</span> <span class="hljs-string">&#x27;435861851@qq.com&#x27;</span> <span class="hljs-comment"># 发件人</span><br>  <span class="hljs-attr">smtp_smarthost:</span> <span class="hljs-string">&#x27;smtp.qq.com:587&#x27;</span> <span class="hljs-comment"># 邮箱服务器的 POP3/SMTP 主机配置 smtp.qq.com 端口为 465 或 587</span><br>  <span class="hljs-attr">smtp_auth_username:</span> <span class="hljs-string">&#x27;435861851@qq.com&#x27;</span> <span class="hljs-comment"># 用户名</span><br>  <span class="hljs-attr">smtp_auth_password:</span> <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment"># 授权码 </span><br>  <span class="hljs-attr">smtp_require_tls:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">smtp_hello:</span> <span class="hljs-string">&#x27;qq.com&#x27;</span><br><span class="hljs-attr">templates:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&#x27;/etc/alertmanager/template/*.tmpl&#x27;</span><br><span class="hljs-attr">route:</span><br>  <span class="hljs-attr">group_by:</span> [<span class="hljs-string">&#x27;alertname&#x27;</span>] <span class="hljs-comment"># 告警分组</span><br>  <span class="hljs-attr">group_wait:</span> <span class="hljs-string">5s</span> <span class="hljs-comment"># 在组内等待所配置的时间，如果同组内，5 秒内出现相同报警，在一个组内出现。</span><br>  <span class="hljs-attr">group_interval:</span> <span class="hljs-string">5m</span> <span class="hljs-comment"># 如果组内内容不变化，合并为一条警报信息，5 分钟后发送。</span><br>  <span class="hljs-attr">repeat_interval:</span> <span class="hljs-string">5m</span> <span class="hljs-comment"># 发送告警间隔时间 s/m/h，如果指定时间内没有修复，则重新发送告警</span><br>  <span class="hljs-attr">receiver:</span> <span class="hljs-string">&#x27;email&#x27;</span> <span class="hljs-comment"># 优先使用 wechat 发送</span><br>  <span class="hljs-attr">routes:</span> <span class="hljs-comment">#子路由，使用 email 发送</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">receiver:</span> <span class="hljs-string">email</span><br>    <span class="hljs-attr">match_re:</span><br>      <span class="hljs-attr">serverity:</span> <span class="hljs-string">email</span><br><span class="hljs-attr">receivers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;email&#x27;</span><br>  <span class="hljs-attr">email_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">to:</span> <span class="hljs-string">&#x27;435861851@qq.com&#x27;</span> <span class="hljs-comment"># 如果想发送多个人就以 &#x27;,&#x27; 做分割</span><br>    <span class="hljs-attr">send_resolved:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">html:</span> <span class="hljs-string">&#x27;<span class="hljs-template-variable">&#123;&#123; template &quot;email.html&quot; . &#125;&#125;</span>&#x27;</span>   <span class="hljs-comment">#使用自定义的模板发送</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;web.hook&#x27;</span><br>  <span class="hljs-comment"># webhook URL</span><br>  <span class="hljs-attr">webhook_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;http://127.0.0.1:7979/webhook&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- email.tmpl --&gt;</span><br>&#123;&#123; define &quot;email.html&quot; &#125;&#125;<br>&#123;&#123; range $i, $alert :=.Alerts &#125;&#125;<br>========监控报警==========<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警状态：&#123;&#123;   .Status &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警级别：&#123;&#123; $alert.Labels.severity &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警类型：&#123;&#123; $alert.Labels.alertname &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警应用：&#123;&#123; $alert.Annotations.summary &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警主机：&#123;&#123; $alert.Labels.instance &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警详情：&#123;&#123; $alert.Annotations.description &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>触发阀值：&#123;&#123; $alert.Annotations.value &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>告警时间：&#123;&#123; $alert.StartsAt.Format &quot;2006-01-02 15:04:05&quot; &#125;&#125;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>========end=============<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>&#123;&#123; end &#125;&#125;<br>&#123;&#123; end &#125;&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>启动</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker run -d \<br>    --network p_net \<br>    --network-alias alert \<br>    --name=alertmanager \<br>    -p 9093:9093 \<br>    -v /Users/xuweiqiang/Desktop/manager:/etc/alertmanager \<br>    prom/alertmanager:latest \<br>    --config.file=/etc/alertmanager/alertmanager.yml<br></code></pre></td></tr></table></figure><h3 id="四、alertmanager提供的http-api"><a href="#四、alertmanager提供的http-api" class="headerlink" title="四、alertmanager提供的http api"></a>四、alertmanager提供的http api</h3><p><a href="https://pshizhsysu.gitbook.io/prometheus/ff08-san-ff09-prometheus-gao-jing-chu-li/kuo-zhan-yue-du/alertmanagerde-api">alertmanager 的http api接口</a><br><a href="https://github.com/prometheus/alertmanager/blob/main/api/v2/openapi.yaml">alertmanager 的http api接口描述文档</a><br><a href="http://localhost:9093/api/v2/alerts">http://localhost:9093/api/v2/alerts</a></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs json"># alerts获取告警信息返回内容<br># 源代码地址 /code/alertmanager/api/v1/api.go<br># 依赖的api对象仅仅存储内存之中重启就丢失了这些告警信息了<br><br><span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;annotations&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;description&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;localhost:6969 request count above 3 (current value: 9)&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;summary&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Instance localhost:6969 request count too much&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;endsAt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2023-04-13T03:12:23.643Z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;fingerprint&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;33beb4a34b645d5c&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;receivers&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br>            <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;email&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;startsAt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2023-04-13T03:08:23.643Z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;inhibitedBy&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;silencedBy&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">[</span><br><br>            <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;state&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;active&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;updatedAt&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;2023-04-13T03:08:26.484Z&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;generatorURL&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;http://xxx.tab=1&quot;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;labels&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;alertname&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;request_counter&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;instance&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;docker.for.mac.host.internal:6969&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;job&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;request_count&quot;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;severity&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;critical&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">receivers:</span><br><span class="hljs-comment"># webhook配置</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&#x27;web.hook&#x27;</span><br>  <span class="hljs-comment"># webhook URL</span><br>  <span class="hljs-attr">webhook_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">url:</span> <span class="hljs-string">&#x27;http://127.0.0.1:9111/alertmanager/hook&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="五、prometheus-的-http-api"><a href="#五、prometheus-的-http-api" class="headerlink" title="五、prometheus 的 http api"></a>五、prometheus 的 http api</h3><p><a href="https://prometheus.io/docs/prometheus/latest/querying/api/">官方手册 querying&#x2F;api</a></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET <span class="hljs-regexp">/api/</span>v1/query<br>POST <span class="hljs-regexp">/api/</span>v1/query<br>GET <span class="hljs-regexp">/api/</span>v1/query_range<br>POST <span class="hljs-regexp">/api/</span>v1/query_range<br></code></pre></td></tr></table></figure><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/agonie201218/article/details/126243110">Alertmanager告警全方位讲解</a><br><a href="https://zhuanlan.zhihu.com/p/598739724">基于Alertmanager设计告警降噪系统-转转</a><br><a href="https://pshizhsysu.gitbook.io/prometheus/ff08-san-ff09-prometheus-gao-jing-chu-li/kuo-zhan-yue-du/shi-jian-ff1a-alertmanager#fu-lu">webhook-receiver.go</a><br><a href="https://prometheus.io/docs/operating/integrations/#alertmanager-webhook-receiver">官方webhook reveiver集成写法</a><br><a href="https://github.com/tomtom-international/alertmanager-webhook-logger">查看webhook标准写法</a><br><a href="https://gitlab.com/yakshaving.art/alertsnitch">Alertsnitch: saves alerts to a MySQL database</a><br><a href="https://pshizhsysu.gitbook.io/prometheus/prometheus/promql/nei-zhi-han-shu/rate">rate 和 irate 函数解析</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>alertmanager</tag>
      
      <tag>告警</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mybatis监控指标</title>
    <link href="/2022/07/26/prometheus/mybatis%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/"/>
    <url>/2022/07/26/prometheus/mybatis%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h3 id="一、定义各个prometheus指标"><a href="#一、定义各个prometheus指标" class="headerlink" title="一、定义各个prometheus指标"></a>一、定义各个prometheus指标</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisMetrics</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] labelNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;class&quot;</span>, <span class="hljs-string">&quot;command&quot;</span>, <span class="hljs-string">&quot;status&quot;</span> &#125;;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Counter</span> <span class="hljs-variable">QUERY_COUNT</span> <span class="hljs-operator">=</span> Counter.build()<br>            .name(<span class="hljs-string">&quot;mybatis_requests_total&quot;</span>).help(<span class="hljs-string">&quot;total sql command.&quot;</span>)<br>            .labelNames(labelNames).register();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Gauge</span> <span class="hljs-variable">QUERY_MAX</span> <span class="hljs-operator">=</span> Gauge.build()<br>            .name(<span class="hljs-string">&quot;mybatis_requests_max&quot;</span>).help(<span class="hljs-string">&quot;run sql command latency in seconds.&quot;</span>)<br>            .labelNames(labelNames).register();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Summary</span> <span class="hljs-variable">QUERY_SUMMARY</span> <span class="hljs-operator">=</span> Summary.build()<br>            .name(<span class="hljs-string">&quot;mybatis_latency_seconds&quot;</span>).help(<span class="hljs-string">&quot;Request latency in seconds.&quot;</span>).labelNames(labelNames)<br>            .register();<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、将指标注册到prometheus收集器"><a href="#二、将指标注册到prometheus收集器" class="headerlink" title="二、将指标注册到prometheus收集器"></a>二、将指标注册到prometheus收集器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PrometheusConfigation</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> CollectorRegistry collectorRegistry;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 自定义指标</span><br><span class="hljs-comment">         */</span><br>        MybatisMetrics.QUERY_COUNT.register(collectorRegistry);<br>        MybatisMetrics.QUERY_MAX.register(collectorRegistry);<br>        MybatisMetrics.QUERY_SUMMARY.register(collectorRegistry);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、定义mybatis的拦截器收集SQL-COMMAND信息"><a href="#三、定义mybatis的拦截器收集SQL-COMMAND信息" class="headerlink" title="三、定义mybatis的拦截器收集SQL COMMAND信息"></a>三、定义mybatis的拦截器收集SQL COMMAND信息</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;&#125;)</span><br><span class="hljs-meta">@Intercepts(</span><br><span class="hljs-meta">    &#123;</span><br><span class="hljs-meta">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123; MappedStatement.class, Object.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="hljs-meta">    &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Interceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">final</span> Object[] args = invocation.getArgs();<br>        <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span> &amp;&amp; args.length &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">MappedStatement</span> <span class="hljs-variable">mappedStatement</span> <span class="hljs-operator">=</span> (MappedStatement) args[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (mappedStatement != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> mappedStatement.getId();<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> mappedStatement.getSqlCommandType().name();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>                <span class="hljs-comment">//以类名和方法名为标签</span><br>                String[] labelValues = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">3</span>];<br>                labelValues[<span class="hljs-number">0</span>] = className;<br>                labelValues[<span class="hljs-number">1</span>] = command;<br>                labelValues[<span class="hljs-number">2</span>] = status;<br>                <span class="hljs-type">SimpleTimer</span> <span class="hljs-variable">startTimer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleTimer</span>();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    status = MybatisMetricsStatusEnum.success.getCode();<br>                    <span class="hljs-keyword">return</span> invocation.proceed();<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>                    status = MybatisMetricsStatusEnum.fail.getCode();<br>                    <span class="hljs-keyword">throw</span> throwable;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    labelValues[<span class="hljs-number">2</span>] = status;<br>                    MybatisMetrics.QUERY_MAX.labels(labelValues).set(startTimer.elapsedSeconds());<br>                    MybatisMetrics.QUERY_SUMMARY.labels(labelValues).observe(startTimer.elapsedSeconds());<br>                    MybatisMetrics.QUERY_COUNT.labels(labelValues).inc();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> invocation.proceed();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">plugin</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Executor || target <span class="hljs-keyword">instanceof</span> StatementHandler) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-built_in">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setProperties</span><span class="hljs-params">(Properties properties)</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="四、注册拦截器到Mybatis"><a href="#四、注册拦截器到Mybatis" class="headerlink" title="四、注册拦截器到Mybatis"></a>四、注册拦截器到Mybatis</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatisConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ConfigurationCustomizer <span class="hljs-title function_">mybatisConfigurationCustomizer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> configuration -&gt; configuration.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBatisInterceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="五、查看收集到的指标"><a href="#五、查看收集到的指标" class="headerlink" title="五、查看收集到的指标"></a>五、查看收集到的指标</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 请求次数和总时长<br># HELP mybatis_latency_seconds Request latency in seconds.<br># TYPE mybatis_latency_seconds summary<br>mybatis_latency_seconds_count&#123;class=&quot;com.example.one&quot;,command=&quot;SELECT&quot;,status=&quot;fail&quot;,&#125; 1.0<br>mybatis_latency_seconds_count&#123;class=&quot;com.example.one&quot;,command=&quot;SELECT&quot;,status=&quot;success&quot;,&#125; 4.0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
      <tag>prometheus</tag>
      
      <tag>java</tag>
      
      <tag>mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot的mongodb指标</title>
    <link href="/2022/07/26/prometheus/springboot%E7%9A%84mongodb%E6%8C%87%E6%A0%87/"/>
    <url>/2022/07/26/prometheus/springboot%E7%9A%84mongodb%E6%8C%87%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<h3 id="一、定义mongo监听器指标采集"><a href="#一、定义mongo监听器指标采集" class="headerlink" title="一、定义mongo监听器指标采集"></a>一、定义mongo监听器指标采集</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.mongodb.event.*;<br><span class="hljs-keyword">import</span> io.micrometer.core.annotation.Incubating;<br><span class="hljs-keyword">import</span> io.micrometer.core.instrument.MeterRegistry;<br><span class="hljs-keyword">import</span> io.micrometer.core.instrument.Timer;<br><span class="hljs-keyword">import</span> io.micrometer.core.lang.NonNullApi;<br><span class="hljs-keyword">import</span> io.micrometer.core.lang.NonNullFields;<br><br><span class="hljs-keyword">import</span> java.time.Duration;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * todo &#123;这里必须加注释&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> xuweiqiang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 2.0.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/7/25 9:50</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@NonNullApi</span><br><span class="hljs-meta">@NonNullFields</span><br><span class="hljs-meta">@Incubating(since = &quot;1.2.0&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyMongoMetricsCommandListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandListener</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String database;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Timer.<span class="hljs-type">Builder</span> <span class="hljs-variable">timerBuilder</span> <span class="hljs-operator">=</span> Timer.builder(<span class="hljs-string">&quot;mongo.operations.duration&quot;</span>)<br>            .description(<span class="hljs-string">&quot;Timer of mongodb commands&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MeterRegistry registry;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyMongoMetricsCommandListener</span><span class="hljs-params">(MeterRegistry registry,String database)</span> &#123;<br>        <span class="hljs-built_in">this</span>.registry = registry;<br>        <span class="hljs-built_in">this</span>.database = database;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commandStarted</span><span class="hljs-params">(CommandStartedEvent commandStartedEvent)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> commandStartedEvent.getDatabaseName();<br>        MongoRequestIdShareHolder.set(String.valueOf(commandStartedEvent.getRequestId()),d);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commandSucceeded</span><span class="hljs-params">(CommandSucceededEvent event)</span> &#123;<br>        timeCommand(event, <span class="hljs-string">&quot;SUCCESS&quot;</span>, event.getElapsedTime(TimeUnit.NANOSECONDS));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commandFailed</span><span class="hljs-params">(CommandFailedEvent event)</span> &#123;<br>        timeCommand(event, <span class="hljs-string">&quot;FAILED&quot;</span>, event.getElapsedTime(TimeUnit.NANOSECONDS));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">timeCommand</span><span class="hljs-params">(CommandEvent event, String status, <span class="hljs-type">long</span> elapsedTimeInNanoseconds)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> CommandSucceededEvent || event <span class="hljs-keyword">instanceof</span> CommandFailedEvent)&#123;<br>            d = MongoRequestIdShareHolder.get(String.valueOf(event.getRequestId()));<br>            MongoRequestIdShareHolder.remove(String.valueOf(event.getRequestId()));<br>        &#125;<br>        timerBuilder<br>                .publishPercentileHistogram()<br>                .minimumExpectedValue(Duration.ofSeconds(<span class="hljs-number">10</span>))<br>                .maximumExpectedValue(Duration.ofSeconds(<span class="hljs-number">10</span>))<br>                .serviceLevelObjectives(<br>                        Duration.ofMillis(<span class="hljs-number">100</span>),<br>                        Duration.ofMillis(<span class="hljs-number">500</span>),<br>                        Duration.ofMillis(<span class="hljs-number">1000</span>),<br>                        Duration.ofMillis(<span class="hljs-number">1500</span>),<br>                        Duration.ofSeconds(<span class="hljs-number">3</span>),<br>                        Duration.ofSeconds(<span class="hljs-number">5</span>)<br>                )<br>                .tag(<span class="hljs-string">&quot;database&quot;</span>,d)<br>                .tag(<span class="hljs-string">&quot;request_id&quot;</span>, String.valueOf(event.getRequestId()))<br>                .tag(<span class="hljs-string">&quot;command&quot;</span>, event.getCommandName())<br>                <span class="hljs-comment">//.tag(&quot;cluster.id&quot;, event.getConnectionDescription().getConnectionId().getServerId().getClusterId().getValue())</span><br>                .tag(<span class="hljs-string">&quot;server.address&quot;</span>, event.getConnectionDescription().getServerAddress().toString())<br>                .tag(<span class="hljs-string">&quot;status&quot;</span>, status)<br>                .register(registry)<br>                .record(elapsedTimeInNanoseconds, TimeUnit.NANOSECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、注册监听器"><a href="#二、注册监听器" class="headerlink" title="二、注册监听器"></a>二、注册监听器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.json.JSONUtil;<br><span class="hljs-keyword">import</span> com.example.one.listener.MyMongoMetricsCommandListener;<br><span class="hljs-keyword">import</span> com.mongodb.Block;<br><span class="hljs-keyword">import</span> com.mongodb.ConnectionString;<br><span class="hljs-keyword">import</span> com.mongodb.MongoClientSettings;<br><span class="hljs-keyword">import</span> com.mongodb.ServerAddress;<br><span class="hljs-keyword">import</span> com.mongodb.client.MongoClient;<br><span class="hljs-keyword">import</span> com.mongodb.connection.ConnectionPoolSettings;<br><span class="hljs-keyword">import</span> io.micrometer.core.instrument.MeterRegistry;<br><span class="hljs-keyword">import</span> io.micrometer.core.instrument.binder.mongodb.MongoMetricsCommandListener;<br><span class="hljs-keyword">import</span> io.micrometer.core.instrument.binder.mongodb.MongoMetricsConnectionPoolListener;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.mongo.MongoClientFactory;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.mongo.MongoClientSettingsBuilderCustomizer;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.mongo.MongoProperties;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.core.env.Environment;<br><span class="hljs-keyword">import</span> org.springframework.data.mongodb.core.MongoClientFactoryBean;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MongoConfiguration</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * register</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> meterRegistry me</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> https://stackoverflow.com/questions/60991985/spring-boot-micrometer-metrics-for-mongodb</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> MongoClientSettingsBuilderCustomizer <span class="hljs-title function_">mongoClientSettingsBuilderCustomizer</span><span class="hljs-params">(MeterRegistry meterRegistry)</span> &#123;<br>        Block&lt;ConnectionPoolSettings.Builder&gt; z = b -&gt; b.addConnectionPoolListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MongoMetricsConnectionPoolListener</span>(meterRegistry));<br>        <span class="hljs-keyword">return</span> builder -&gt; builder.applyToConnectionPoolSettings(z).addCommandListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMongoMetricsCommandListener</span>(meterRegistry,<span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、查看采集到的指标"><a href="#三、查看采集到的指标" class="headerlink" title="三、查看采集到的指标"></a>三、查看采集到的指标</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt"># HELP mongodb_driver_commands_seconds_max Timer of mongodb commands<br># TYPE mongodb_driver_commands_seconds_max gauge<br>mongodb_driver_commands_seconds_max&#123;application=&quot;one&quot;,cluster_id=&quot;xxx&quot;&#125; 0.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
      <tag>prometheus</tag>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mongodb的指标采集</title>
    <link href="/2022/04/12/prometheus/mongodb%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/"/>
    <url>/2022/04/12/prometheus/mongodb%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="一、定义prometheus指标"><a href="#一、定义prometheus指标" class="headerlink" title="一、定义prometheus指标"></a>一、定义prometheus指标</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> tool<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span><br>)<br><br><span class="hljs-keyword">const</span> Application = <span class="hljs-string">&quot;application&quot;</span><br><span class="hljs-keyword">const</span> Command = <span class="hljs-string">&quot;command&quot;</span><br><span class="hljs-keyword">const</span> Database = <span class="hljs-string">&quot;database&quot;</span><br><span class="hljs-keyword">const</span> RequestID = <span class="hljs-string">&quot;request_id&quot;</span><br><span class="hljs-keyword">const</span> Status = <span class="hljs-string">&quot;status&quot;</span><br><br><span class="hljs-keyword">type</span> MongoStatusEnum <span class="hljs-type">string</span><br><br><span class="hljs-keyword">const</span> (<br>    Success MongoStatusEnum = <span class="hljs-string">&quot;success&quot;</span><br>    Fail    MongoStatusEnum = <span class="hljs-string">&quot;fail&quot;</span><br>    Start   MongoStatusEnum = <span class="hljs-string">&quot;start&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> (<br>    mongoHistogram = prometheus.NewHistogramVec(prometheus.HistogramOpts&#123;<br>        Name:    <span class="hljs-string">&quot;mongodb_operations_duration_seconds&quot;</span>,<br>        Help:    <span class="hljs-string">&quot;mongodb command record&quot;</span>,<br>        Buckets: []<span class="hljs-type">float64</span>&#123;<span class="hljs-number">0.1</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">1.5</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">10.0</span>&#125;,<br>    &#125;, []<span class="hljs-type">string</span>&#123;Application, Command, Database, RequestID, Status&#125;)<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    prometheus.MustRegister(mongoHistogram)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">AddMetrics</span><span class="hljs-params">(labels prometheus.Labels, speed <span class="hljs-type">float64</span>)</span></span> &#123;<br>    mongoHistogram.With(labels).Observe(speed)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、注册mongo监听器收集指标"><a href="#二、注册mongo监听器收集指标" class="headerlink" title="二、注册mongo监听器收集指标"></a>二、注册mongo监听器收集指标</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;context&quot;</span><br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;github.com/gogf/gf/util/gconv&quot;</span><br>    <span class="hljs-string">&quot;github.com/pkg/errors&quot;</span><br>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus&quot;</span><br>    <span class="hljs-string">&quot;strconv&quot;</span><br>    <span class="hljs-string">&quot;sync&quot;</span><br><br>    <span class="hljs-string">&quot;go.mongodb.org/mongo-driver/bson&quot;</span><br>    <span class="hljs-string">&quot;go.mongodb.org/mongo-driver/event&quot;</span><br>    <span class="hljs-string">&quot;go.mongodb.org/mongo-driver/mongo&quot;</span><br>    <span class="hljs-string">&quot;go.mongodb.org/mongo-driver/mongo/options&quot;</span><br>    <span class="hljs-string">&quot;go.mongodb.org/mongo-driver/mongo/readpref&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> RequestIDDatabaseNameMap sync.Map<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Client</span><span class="hljs-params">()</span></span> *mongo.Client &#123;<br>    ctx, cancel := context.WithTimeout(context.Background(), <span class="hljs-number">10</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    opt := <span class="hljs-built_in">new</span>(options.ClientOptions)<br>    opt.ApplyURI(<span class="hljs-string">&quot;mongodb://admin:123456@127.0.0.1:27017/?authSource=admin&quot;</span>)<br>    m := <span class="hljs-built_in">new</span>(event.CommandMonitor)<br>    m.Started = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, startedEvent *event.CommandStartedEvent)</span></span> &#123;<br>        RequestIDDatabaseNameMap.Store(strconv.FormatInt(startedEvent.RequestID, <span class="hljs-number">10</span>), startedEvent.DatabaseName)<br>    &#125;<br>    m.Succeeded = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, succeededEvent *event.CommandSucceededEvent)</span></span> &#123;<br>        l := prometheus.Labels&#123;&#125;<br>        l[Application] = <span class="hljs-string">&quot;one&quot;</span><br>        l[Command] = succeededEvent.CommandName<br>        databaseName := <span class="hljs-string">&quot;&quot;</span><br>        tmp, exist := RequestIDDatabaseNameMap.LoadAndDelete(strconv.FormatInt(succeededEvent.RequestID, <span class="hljs-number">10</span>))<br>        <span class="hljs-keyword">if</span> exist &#123;<br>            databaseName = gconv.String(tmp)<br>        &#125;<br>        l[Database] = databaseName<br>        l[Status] = gconv.String(Success)<br>        l[RequestID] = strconv.FormatInt(succeededEvent.RequestID, <span class="hljs-number">10</span>)<br>        t, e := time.ParseDuration(fmt.Sprintf(<span class="hljs-string">&quot;%sns&quot;</span>, gconv.String(succeededEvent.DurationNanos)))<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(e)<br>        &#125;<br>        AddMetrics(l, t.Seconds())<br>    &#125;<br>    m.Failed = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, failedEvent *event.CommandFailedEvent)</span></span> &#123;<br>        l := prometheus.Labels&#123;&#125;<br>        l[Application] = <span class="hljs-string">&quot;one&quot;</span><br>        l[Command] = failedEvent.CommandName<br>        databaseName := <span class="hljs-string">&quot;&quot;</span><br>        tmp, exist := RequestIDDatabaseNameMap.LoadAndDelete(strconv.FormatInt(failedEvent.RequestID, <span class="hljs-number">10</span>))<br>        <span class="hljs-keyword">if</span> exist &#123;<br>            databaseName = gconv.String(tmp)<br>        &#125;<br>        l[Database] = databaseName<br>        l[Status] = gconv.String(Fail)<br>        l[RequestID] = strconv.FormatInt(failedEvent.RequestID, <span class="hljs-number">10</span>)<br>        t, e := time.ParseDuration(fmt.Sprintf(<span class="hljs-string">&quot;%sns&quot;</span>, gconv.String(failedEvent.DurationNanos)))<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-built_in">panic</span>(e)<br>        &#125;<br>        AddMetrics(l, t.Seconds())<br>    &#125;<br>    opt.Monitor = m<br>    client, err := mongo.NewClient(opt)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(err)<br>    &#125;<br>    err = client.Connect(ctx)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(errors.Wrap(err, <span class="hljs-string">&quot;connect mongo error&quot;</span>))<br>    &#125;<br>    ctx, cancel = context.WithTimeout(context.Background(), <span class="hljs-number">2</span>*time.Second)<br>    <span class="hljs-keyword">defer</span> cancel()<br>    err = client.Ping(ctx, readpref.Primary())<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(errors.Wrap(err, <span class="hljs-string">&quot;ping mongo error&quot;</span>))<br>    &#125;<br>    <span class="hljs-keyword">return</span> client<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">find</span><span class="hljs-params">(c *mongo.Client)</span></span> <span class="hljs-type">string</span> &#123;<br>    _, ee := c.ListDatabases(context.Background(), bson.D&#123;&#125;)<br>    <span class="hljs-keyword">if</span> ee != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;list database %s&quot;</span>, ee.Error())<br>    &#125;<br>    log.Printf(<span class="hljs-string">&quot;database is %s&quot;</span>, c.Database(<span class="hljs-string">&quot;user&quot;</span>).Name())<br>    ff, _ := c.Database(<span class="hljs-string">&quot;user&quot;</span>).ListCollectionNames(context.Background(), bson.D&#123;&#125;)<br>    dd, _ := json.Marshal(ff)<br>    fmt.Println(<span class="hljs-type">string</span>(dd))<br>    collection := c.Database(<span class="hljs-string">&quot;user&quot;</span>).Collection(<span class="hljs-string">&quot;t_incident&quot;</span>)<br>    <span class="hljs-keyword">var</span> result bson.M<br>    e := collection.FindOne(context.Background(), bson.D&#123;&#125;).Decode(&amp;result)<br>    <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;find one %s&quot;</span>, e.Error())<br>    &#125;<br>    s, _ := json.Marshal(result)<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(s)<br>&#125;<br><br><span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Handler)</span></span> ServeHTTP(r http.ResponseWriter, q *http.Request) &#123;<br>    s := find(Client())<br>    result := []<span class="hljs-type">byte</span>(s)<br>    _, e := r.Write(result)<br>    <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatal(e)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="三、启动服务查看指标"><a href="#三、启动服务查看指标" class="headerlink" title="三、启动服务查看指标"></a>三、启动服务查看指标</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;github.com/prometheus/client_golang/prometheus/promhttp&quot;</span><br>    <span class="hljs-string">&quot;net/http&quot;</span><br>    <span class="hljs-string">&quot;sangfor.com/tool&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">//提供 /metrics HTTP 端点</span><br>    http.Handle(<span class="hljs-string">&quot;/metrics&quot;</span>, promhttp.Handler())<br>    http.Handle(<span class="hljs-string">&quot;/get&quot;</span>, <span class="hljs-built_in">new</span>(tool.Handler))<br>    <span class="hljs-comment">//端口号</span><br>    http.ListenAndServe(<span class="hljs-string">&quot;:2112&quot;</span>, <span class="hljs-literal">nil</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://github.com/prometheus/client_golang">https://github.com/prometheus/client_golang</a></p>]]></content>
    
    
    <categories>
      
      <category>prometheus</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>mongodb</tag>
      
      <tag>prometheus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何命令行执行单元测试</title>
    <link href="/2021/06/05/golang/%E5%A6%82%E4%BD%95%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/06/05/golang/%E5%A6%82%E4%BD%95%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="一、项目"><a href="#一、项目" class="headerlink" title="一、项目"></a>一、项目</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── go.mod<br>└── tool<br>    ├── net.go<br>    └── net_test.go<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">module github.com/ovn-org/libovsdb<br><br>go 1.20<br></code></pre></td></tr></table></figure><h3 id="二、执行"><a href="#二、执行" class="headerlink" title="二、执行"></a>二、执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> /home/libovsdb<br><br><br>$ go <span class="hljs-built_in">help</span> <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 执行包内部所有单元测试</span><br><span class="hljs-comment"># 其中 /tool 是 module github.com/ovn-org/libovsdb 的包路径</span><br><span class="hljs-comment"># golang 会自动找到该路径下的package</span><br>$ go <span class="hljs-built_in">test</span> github.com/ovn-org/libovsdb/tool<br><br><span class="hljs-comment"># 查看执行结果 -v</span><br><span class="hljs-comment"># 执行部分函数 -run &lt;unit_test_func_name&gt;</span><br>$ go <span class="hljs-built_in">test</span> -run TestGetUser -v github.com/ovn-org/libovsdb/tool<br></code></pre></td></tr></table></figure><h3 id="编译单元测试程序放到其他环境执行"><a href="#编译单元测试程序放到其他环境执行" class="headerlink" title="编译单元测试程序放到其他环境执行"></a>编译单元测试程序放到其他环境执行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># -c 表示生成二进制程序到pkg.test并且不运行</span><br><span class="hljs-comment"># 通过-o可以更改二进制程序名称</span><br><span class="hljs-comment"># 本地将生成 tester 二进制程序</span><br>$ go <span class="hljs-built_in">test</span> -c -o tester github.com/ovn-org/libovsdb/tool<br><br><span class="hljs-comment"># 本地将生成 tool.test 程序</span><br>$ go <span class="hljs-built_in">test</span> -c github.com/ovn-org/libovsdb/tool<br><br><span class="hljs-comment"># 相对路径 测试所有包</span><br>$ go <span class="hljs-built_in">test</span> -c ./...<br><br><span class="hljs-comment"># 测试单个</span><br>$ go <span class="hljs-built_in">test</span> -c ./internal/vnetstore<br><br><br><span class="hljs-comment"># 执行二进制程序</span><br>$ /home/tool.test --<span class="hljs-built_in">help</span><br>$ /home/tool.test -test.v -test.run FuncName<br></code></pre></td></tr></table></figure><p><a href="https://geektutu.com/post/high-performance-go.html">GO语言高性能编程</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>单元测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何配置go私有库</title>
    <link href="/2021/06/05/golang/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgo%E7%A7%81%E6%9C%89%E5%BA%93/"/>
    <url>/2021/06/05/golang/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgo%E7%A7%81%E6%9C%89%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="一、配置golang环境"><a href="#一、配置golang环境" class="headerlink" title="一、配置golang环境"></a>一、配置golang环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ go <span class="hljs-built_in">env</span> -w GOINSECURE=<span class="hljs-string">&quot;gitlab.company.net&quot;</span> <span class="hljs-comment"># 在 Go 1.13 版本中 没有 GOINSECURE 环境变量</span><br>$ go <span class="hljs-built_in">env</span> -w GONOPROXY=<span class="hljs-string">&quot;gitlab.company.net&quot;</span><br>$ go <span class="hljs-built_in">env</span> -w GOPRIVATE=<span class="hljs-string">&quot;gitlab.company.net&quot;</span><br>$ go <span class="hljs-built_in">env</span> -w GONOSUMDB=<span class="hljs-string">&quot;gitlab.company.net&quot;</span><br>$ go <span class="hljs-built_in">env</span> -w GOPROXY=<span class="hljs-string">&quot;https://goproxy.io,direct&quot;</span><br>$ go <span class="hljs-built_in">env</span> -w GO111MODULE=on<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 对于有些版本比如 go 1.13 没有GOINSECURE环境变量会出现 SSL x509 certificate signed by unknown authority</span><br><span class="hljs-comment"># 执行以下的可以绕过SSL验证问题</span><br>$ <span class="hljs-built_in">export</span> GOSUMDB=off GONOSUMDB=*<br><br><span class="hljs-comment"># 删除环境变量</span><br>$ <span class="hljs-built_in">unset</span> GOSUMDB<br>$ <span class="hljs-built_in">unset</span> GONOSUMDB<br></code></pre></td></tr></table></figure><h3 id="二、配置git环境"><a href="#二、配置git环境" class="headerlink" title="二、配置git环境"></a>二、配置git环境</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更改git#&lt;url&gt;替换为https://&lt;url&gt;</span><br><span class="hljs-comment"># git config --global url.git@&lt;IP addr&gt;:.insteadOf https://&lt;IP addr&gt;/ --replace-all</span><br>$ git config --global url.git@gitlab.company.net:.insteadOf https://gitlab.company.net/<br>$ git config --global --<span class="hljs-built_in">help</span><br><br><span class="hljs-comment"># 编辑配置</span><br>$ git config --global --edit<br><br><span class="hljs-comment"># 配置SSH证书登陆gitlab</span><br><span class="hljs-built_in">mkdir</span> ~/.ssh<br>ssh -T git@gitlab.company.net<br></code></pre></td></tr></table></figure><h3 id="三、验证"><a href="#三、验证" class="headerlink" title="三、验证"></a>三、验证</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手动绕过SSL </span><br><span class="hljs-comment"># go get -insecure gitlab.company.net/client-go@v0.22.21</span><br>go get gitlab.company.net/client-go@v0.22.21<br></code></pre></td></tr></table></figure><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><h5 id="1-go-get-404-not-found"><a href="#1-go-get-404-not-found" class="headerlink" title="1. go get 404 not found"></a>1. go get 404 not found</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 异常信息</span><br>reading https://mirrors.aliyun.com/goproxy/github.com/weiqiangxu/batchjob/@v/list: 404 Not Found<br><br><span class="hljs-comment"># 1.私有库未设置，默认会去`https://pkg.go.dev`</span><br><span class="hljs-comment"># 就是`go env | grep GOPROXY`查找</span><br><span class="hljs-comment"># GOPRIVATE设为一个以逗号分隔的模式列表时</span><br><span class="hljs-comment"># 避免从公共仓库下载私有模块</span><br><span class="hljs-comment"># 假设GOPRIVATE的值设置为&quot;example.com/private-project&quot;，那么当执行go get example.com/private-project时</span><br><span class="hljs-comment"># Go命令将会从私有仓库或者本地文件系统中查找并下载该模块，而不是从公共仓库中获取</span><br>go <span class="hljs-built_in">env</span> -w GOPRIVATE=gitlab.mycompany.net<br><br><span class="hljs-comment"># 2.设置insecure</span><br><span class="hljs-comment"># 控制Go语言的不安全操作，当设置为&quot;1&quot;时，Go语言将允许一些不安全的操作</span><br>go <span class="hljs-built_in">env</span> -w GOINSECURE=private.repo.com<br><br><span class="hljs-comment"># 3.手动指定</span><br>go get -inscure github.com/weiqiangxu/batchjob<br></code></pre></td></tr></table></figure><p><a href="https://geektutu.com/post/high-performance-go.html">GO语言高性能编程</a></p>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用range必懂的点</title>
    <link href="/2021/04/11/golang/%E4%BD%BF%E7%94%A8range%E5%BF%85%E6%87%82%E7%9A%84%E7%82%B9/"/>
    <url>/2021/04/11/golang/%E4%BD%BF%E7%94%A8range%E5%BF%85%E6%87%82%E7%9A%84%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<ol><li>code</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetUser</span><span class="hljs-params">()</span></span> ([]*User, []User) &#123;<br><span class="hljs-keyword">var</span> list []User<br>list = <span class="hljs-built_in">append</span>(list, User&#123;<br>Name: <span class="hljs-string">&quot;1&quot;</span>,<br>&#125;)<br>list = <span class="hljs-built_in">append</span>(list, User&#123;<br>Name: <span class="hljs-string">&quot;2&quot;</span>,<br>&#125;)<br>list = <span class="hljs-built_in">append</span>(list, User&#123;<br>Name: <span class="hljs-string">&quot;3&quot;</span>,<br>&#125;)<br><span class="hljs-keyword">var</span> z []*User<br><span class="hljs-keyword">var</span> y []User<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> list &#123;<br><span class="hljs-keyword">if</span> v.Name == <span class="hljs-string">&quot;1&quot;</span> &#123;<br>z = <span class="hljs-built_in">append</span>(z, &amp;v) <span class="hljs-comment">// $v 的地址在一次 range 之中唯一不变的</span><br>y = <span class="hljs-built_in">append</span>(y, v)<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> z, y<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>unit test</li></ol><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetUser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>tests := []<span class="hljs-keyword">struct</span> &#123;<br>name  <span class="hljs-type">string</span><br>want  []*User<br>want1 []User<br>&#125;&#123;<br>&#123;<br>name:  <span class="hljs-string">&quot;&quot;</span>,<br>want:  <span class="hljs-literal">nil</span>,<br>want1: <span class="hljs-literal">nil</span>,<br>&#125;,<br>&#125;<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> tests &#123;<br>t.Run(tt.name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>got, got1 := GetUser()<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> got &#123;<br>t.Logf(<span class="hljs-string">&quot;got=%+v&quot;</span>, v)<br>&#125;<br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> got1 &#123;<br>t.Logf(<span class="hljs-string">&quot;got1=%+v&quot;</span>, v)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openvswitch实验环境</title>
    <link href="/2021/03/14/cni/openvswitch%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/03/14/cni/openvswitch%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<ol><li>准备linux环境</li></ol><ul><li><a href="https://weiqiangxu.github.io/2023/06/02/cni/openvswitch%E5%AE%89%E8%A3%85/">openvswitch如何安装</a></li><li><a href="https://weiqiangxu.github.io/2023/04/18/%E8%AF%AD%E9%9B%80k8s%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/docker%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85/">docker离线安装</a>也可以直接使用yum等包管理工具在线安装</li></ul><ol start="2"><li>准备镜像</li></ol><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># alpine-ovs</span><br><span class="hljs-keyword">FROM</span> alpine:<span class="hljs-number">3.16</span>.<span class="hljs-number">0</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> sed -i <span class="hljs-string">&#x27;s/dl-cdn.alpinelinux.org/mirrors.tuna.tsinghua.edu.cn/g&#x27;</span> /etc/apk/repositories &amp;&amp; \</span><br><span class="language-bash">apk add vim tcpdump iperf iproute2</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker build -t alpine-ovs .<br></code></pre></td></tr></table></figure><ol start="2"><li>创建容器</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network  create --subnet=192.168.101.0/24 ovs-net<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -d --net ovs-net --ip 192.168.101.2 --name ns2 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns2在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns2_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns2_default_if&#125;</span> name veth1-ns2 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns2 up<br><br>docker run -it -d --net ovs-net --ip 192.168.101.3 --name ns3 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns3在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns3_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns3_default_if&#125;</span> name veth1-ns3 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns3 up<br><br>docker run -it -d --net ovs-net --ip 192.168.101.4 --name ns4 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns4在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns4_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns4_default_if&#125;</span> name veth1-ns4 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns4 up<br><br>docker run -it -d --net ovs-net --ip 192.168.101.5 --name ns5 alpine-ovs sh<br><span class="hljs-comment"># 查看容器ns5在宿主机网卡的pair端口</span><br>ifconfig | grep veth<br><span class="hljs-comment"># 更改网卡端口名称</span><br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> down <span class="hljs-variable">$&#123;ns5_default_if&#125;</span> &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> <span class="hljs-variable">$&#123;ns5_default_if&#125;</span> name veth1-ns5 &amp;&amp; ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span>  veth1-ns5 up<br></code></pre></td></tr></table></figure><ol start="3"><li>ovs建桥承接docker容器流量</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看网桥</span><br><span class="hljs-comment"># 会发现网桥后面有3个网络插口</span><br>brctl show<br><br><span class="hljs-comment"># 现在我们把这3个网卡从docker创建的网桥拔出来</span><br><span class="hljs-comment"># brctl delif $&#123;bridge_name&#125; veth1-ns2 veth1-ns3 veth1-ns4 veth1-ns5</span><br>brctl delif br-a644ca66224e veth1-ns2 veth1-ns3 veth1-ns4 veth1-ns5<br><br><span class="hljs-comment"># 使用 ovs 创建的网桥</span><br>ovs-vsctl add-br ovs-br1<br><br><span class="hljs-comment"># 将3个容器的对端网卡插入到 ovs网桥</span><br>ovs-vsctl add-port ovs-br1 veth1-ns2<br>ovs-vsctl add-port ovs-br1 veth1-ns3<br>ovs-vsctl add-port ovs-br1 veth1-ns4<br>ovs-vsctl add-port ovs-br1 veth1-ns5<br></code></pre></td></tr></table></figure><ol start="4"><li>查看当前ovs桥网络</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看ovs的桥配置</span><br>$ ovs-vsctl show<br><br>2645a736-d14f-4284-9418-9aed1a914dd2<br>    Bridge ovs-br1<br>        Port veth1-ns3<br>            Interface veth1-ns3<br>        Port veth1-ns4<br>            Interface veth1-ns4<br>        Port veth1-ns5<br>            Interface veth1-ns5<br>        Port veth1-ns2<br>            Interface veth1-ns2<br>        Port ovs-br1<br>            Interface ovs-br1<br>                <span class="hljs-built_in">type</span>: internal<br>    ovs_version: <span class="hljs-string">&quot;2.17.6&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看ovs桥端口配置</span><br>$ ovs-ofctl show ovs-br1<br><br>OFPT_FEATURES_REPLY (xid=0x2): dpid:00000a79f12bb540<br>n_tables:254, n_buffers:0<br>capabilities: FLOW_STATS TABLE_STATS PORT_STATS QUEUE_STATS ARP_MATCH_IP<br>actions: output enqueue set_vlan_vid set_vlan_pcp strip_vlan mod_dl_src mod_dl_dst mod_nw_src mod_nw_dst mod_nw_tos mod_tp_src mod_tp_dst<br> 1(veth1-ns2): addr:3a:0c:fe:17:69:ac<br>     config:     0<br>     state:      0<br>     current:    10GB-FD COPPER<br>     speed: 10000 Mbps now, 0 Mbps max<br> 2(veth1-ns3): addr:9a:a2:fd:<span class="hljs-built_in">dd</span>:4b:a8<br>     config:     0<br>     state:      0<br>     current:    10GB-FD COPPER<br>     speed: 10000 Mbps now, 0 Mbps max<br> 3(veth1-ns4): addr:22:40:eb:a6:8b:16<br>     config:     0<br>     state:      0<br>     current:    10GB-FD COPPER<br>     speed: 10000 Mbps now, 0 Mbps max<br> 4(veth1-ns5): addr:4e:ee:72:dc:77:69<br>     config:     0<br>     state:      0<br>     current:    10GB-FD COPPER<br>     speed: 10000 Mbps now, 0 Mbps max<br> LOCAL(ovs-br1): addr:0a:79:f1:2b:b5:40<br>     config:     0<br>     state:      0<br>     speed: 0 Mbps now, 0 Mbps max<br>OFPT_GET_CONFIG_REPLY (xid=0x4): frags=normal miss_send_len=0<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看流表</span><br>ovs-ofctl dump-flows ovs-br1<br> cookie=0x0, duration=1628.095s, table=0, n_packets=10, n_bytes=756, priority=0 actions=NORMAL<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>openvswitch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>openvswitch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>golang静态扫描和格式检查</title>
    <link href="/2020/08/20/golang/golang%E9%9D%99%E6%80%81%E6%89%AB%E6%8F%8F%E5%92%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/"/>
    <url>/2020/08/20/golang/golang%E9%9D%99%E6%80%81%E6%89%AB%E6%8F%8F%E5%92%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="一、makefile-code"><a href="#一、makefile-code" class="headerlink" title="一、makefile code"></a>一、makefile code</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">touch</span> Makefile<br></code></pre></td></tr></table></figure><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">fmt:</span><br>　　command -v gofumpt || (WORK=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span> &amp;&amp; cd /tmp &amp;&amp; GO111MODULE=on go install mvdan.cc/gofumpt@latest &amp;&amp; cd <span class="hljs-variable">$(WORK)</span>)<br>　　gofumpt -w -d .<br><br><span class="hljs-section">lint:</span><br>　　command -v golangci-lint || (WORK=<span class="hljs-variable">$(<span class="hljs-built_in">shell</span> pwd)</span> &amp;&amp; cd /tmp &amp;&amp; GO111MODULE=on go install github.com/golangci/golangci-lint/cmd/golangci-lint@v1.49.0 &amp;&amp; cd <span class="hljs-variable">$(WORK)</span>)<br>　　golangci-lint run  -v<br><br><span class="hljs-section">ci/lint: export GOPATH=/go</span><br><span class="hljs-section">ci/lint: export GO111MODULE=on</span><br><span class="hljs-section">ci/lint: export GOPROXY=https://goproxy.cn</span><br><span class="hljs-section">ci/lint: export GOPRIVATE=code.my.net</span><br><span class="hljs-section">ci/lint: export GOOS=linux</span><br><span class="hljs-section">ci/lint: export CGO_ENABLED=1</span><br><span class="hljs-section">ci/lint: lint</span><br></code></pre></td></tr></table></figure><h3 id="二、执行静态扫描和格式检查"><a href="#二、执行静态扫描和格式检查" class="headerlink" title="二、执行静态扫描和格式检查"></a>二、执行静态扫描和格式检查</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make <span class="hljs-built_in">fmt</span> &amp;&amp; make lint<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>golang</tag>
      
      <tag>golangci-lint</tag>
      
      <tag>fmt</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
