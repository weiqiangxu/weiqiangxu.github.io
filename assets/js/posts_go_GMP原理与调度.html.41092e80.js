"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2257],{6262:(e,i)=>{i.A=(e,i)=>{const n=e.__vccOpts||e;for(const[e,a]of i)n[e]=a;return n}},3658:(e,i,n)=>{n.r(i),n.d(i,{comp:()=>r,data:()=>s});var a=n(641);const l={},r=(0,n(6262).A)(l,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h1 id="gmp-原理与调度" tabindex="-1"><a class="header-anchor" href="#gmp-原理与调度"><span>GMP 原理与调度</span></a></h1><p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" target="_blank" rel="noopener noreferrer">GMP 原理与调度</a></p><ol><li>M (thread) G (goroutine) P (Processor)</li><li>P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量）</li><li>每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量）</li></ol><h3 id="m和p的数量没有绝对关系-启动以后p是固定的而m是动态的" tabindex="-1"><a class="header-anchor" href="#m和p的数量没有绝对关系-启动以后p是固定的而m是动态的"><span>M和P的数量没有绝对关系，启动以后P是固定的而M是动态的</span></a></h3><blockquote><p>M被阻塞的时候，P会创建或者切换到另一个M</p></blockquote><h3 id="一些简单的问题-work-stealing-hand-off" tabindex="-1"><a class="header-anchor" href="#一些简单的问题-work-stealing-hand-off"><span>一些简单的问题 work stealing &amp;&amp; hand off</span></a></h3><ol><li>M关联的P无G消费的时候，是不是就会一直空闲在那里 （全局队列G和其他P的G都会被偷取）</li><li>G阻塞的时候，P会转移给其他空闲的M</li></ol><h3 id="在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度" tabindex="-1"><a class="header-anchor" href="#在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度"><span>在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死 - 抢占式调度</span></a></h3><h3 id="调度器的生命周期" tabindex="-1"><a class="header-anchor" href="#调度器的生命周期"><span>调度器的生命周期</span></a></h3><ol><li>创建P\\G\\M</li><li>运行M</li><li>M和P绑定</li><li>M通过P获取到G进行消费 （M肯定通过P呀、P是M的本地队列呀）</li><li>M获取不到G的时候休眠</li><li>P绑定M的时候唤醒</li></ol><p>main.main &gt; runtime.main -&gt; runtime.exit or runtime.main finish</p><h3 id="可视化gmp编程" tabindex="-1"><a class="header-anchor" href="#可视化gmp编程"><span>可视化GMP编程</span></a></h3><ol><li>go tool trace</li><li>debug trace</li></ol><h3 id="线程自旋-系统中最多有-gomaxprocs-个自旋的线程" tabindex="-1"><a class="header-anchor" href="#线程自旋-系统中最多有-gomaxprocs-个自旋的线程"><span>线程自旋：系统中最多有 GOMAXPROCS 个自旋的线程</span></a></h3><h3 id="goroutine的状态有多少个" tabindex="-1"><a class="header-anchor" href="#goroutine的状态有多少个"><span>goroutine的状态有多少个</span></a></h3><h3 id="gmp相关调优" tabindex="-1"><a class="header-anchor" href="#gmp相关调优"><span>GMP相关调优</span></a></h3><ol><li>GOMAXPROCS配置 决定P的数量也就是 能够并行执行的goroutine的最大数量</li></ol><h3 id="已经被废弃的gm-和-最新的gpm-的对比" tabindex="-1"><a class="header-anchor" href="#已经被废弃的gm-和-最新的gpm-的对比"><span>已经被废弃的GM 和 最新的GPM 的对比</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>本质上就是增加了 &quot;M 的本地队列&quot;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>如果M获取每一个G都要去全局队列获取，和其他M抢夺G，就需要大量的加锁解锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列" tabindex="-1"><a class="header-anchor" href="#本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列"><span>本质上就是增加了 M 的本地队列 、 本质上就是增加了 M 的本地队列、本质上就是增加了 M 的本地队列</span></a></h3><h3 id="m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的" tabindex="-1"><a class="header-anchor" href="#m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的"><span>M 的 P 里面的G可以是 全局队列拿的，也可以是其他 P 的本地队列拿的</span></a></h3><blockquote><p>每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</p></blockquote><h3 id="关于数量" tabindex="-1"><a class="header-anchor" href="#关于数量"><span>关于数量</span></a></h3><ol><li>M是动态的不够用的时候就会创建 （随时创建） 只能限定最大数量</li><li>P是固定数量的 GOMAXPROCS配置 （启动时候就创建）</li></ol><h3 id="gmp-hello的执行过程" tabindex="-1"><a class="header-anchor" href="#gmp-hello的执行过程"><span>GMP-hello的执行过程</span></a></h3><h3 id="关键术语" tabindex="-1"><a class="header-anchor" href="#关键术语"><span>关键术语</span></a></h3><ol><li>进程虚拟地址空间中的代码段</li><li>程序执行入口 runtime.main 创建 main.goroutine （call main.main）</li><li>协程对应的数据结构是runtime.g，工作线程对应的数据结构是runtime.m，处理器P对应的数据结构是 runtime.p (本地runq)</li><li>全局runq 存储在 全局变量 sched （调度器，对应的数据结构是 runtime.schedt）</li><li>P程序初始化过程之中进行调度器初始化，初始化固定数量的 P (GOMAXPROCS)</li><li>start函数开启调度循环schedule()函数</li><li>time.sleep 调用 gopark函数</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>协程的状态从 _Grunning修改为_Gwaiting </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>(main.goroutine就不会因为执行完成回到P之中而是timer之中等待) </span></span>\n<span class="line"><span>然后使用 schedule() 调度执行其他的goroutine</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>时间到了以后 _Grunnable 状态然后G被访问P的runq之中，main.main结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>M 可以去 P 获取 G，所以不用再去全局队列和其他M争抢G了 全局变量 sched 调度器记录所有空闲的m 和空闲的p 等 以及全局 runq M 优先从关联的 P 获取 G，没有的话去全局变量 sched 调度器的全局runq领取 G ， 如果调度器也没有那么从别的 P 的runq 获取G</p></blockquote><h3 id="抢占式调度" tabindex="-1"><a class="header-anchor" href="#抢占式调度"><span>抢占式调度</span></a></h3><ol><li>time.sleep后 _Grunning 和 _Gwaiting，timer之中的回调函数将g变成Grunnable状态放回runq</li><li>以上谁负责执行timer之中的回调函数呢 (schedule()-&gt;checkTimers)</li><li>监控线程（重复执行某一个任务） - 不依赖GMP、main.goroutine创建 ， 监控timer可以创建线程执行</li><li>IO时间监听队列 - 主动轮询netpoll</li></ol><p><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">Golang合集</a></p><h3 id="gmp的让出创建恢复" tabindex="-1"><a class="header-anchor" href="#gmp的让出创建恢复"><span>GMP的让出创建恢复</span></a></h3><ol><li>newproc函数</li></ol><h3 id="协程状态" tabindex="-1"><a class="header-anchor" href="#协程状态"><span>协程状态</span></a></h3><ol><li>running</li><li>runable</li><li>waiting</li><li>syscall</li><li>dead</li></ol><h3 id="备注" tabindex="-1"><a class="header-anchor" href="#备注"><span>备注</span></a></h3><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> OS系统调用前，先调用runtime·entersyscall函数将自己的状态置为Gsyscall</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">Golang合集</a></p><h3 id="协程创建后会加入-p-的本地队列runq之中" tabindex="-1"><a class="header-anchor" href="#协程创建后会加入-p-的本地队列runq之中"><span>协程创建后会加入 P 的本地队列runq之中</span></a></h3><h3 id="main-main运行结束以后runtime-main会调用exit函数结束进程" tabindex="-1"><a class="header-anchor" href="#main-main运行结束以后runtime-main会调用exit函数结束进程"><span>main.main运行结束以后runtime.main会调用exit函数结束进程</span></a></h3><ul><li><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">Golang合集</a></li></ul><h3 id="m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p" tabindex="-1"><a class="header-anchor" href="#m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p"><span>M 执行 G 的时候发生阻塞，那么 M 会失去原有的 P（摘除），然后创建新的 M 服务这个 P</span></a></h3><ul><li><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></li><li><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" target="_blank" rel="noopener noreferrer">GMP 原理与调度 - 简单易懂</a></li><li><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></li></ul>',44)]))}]]),s=JSON.parse('{"path":"/posts/go/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html","title":"GMP 原理与调度","lang":"zh-CN","frontmatter":{"hide":true,"description":"GMP 原理与调度 GMP 原理与调度 M (thread) G (goroutine) P (Processor) P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量） 每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量） M和P的数...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"GMP 原理与调度"}],["meta",{"property":"og:description","content":"GMP 原理与调度 GMP 原理与调度 M (thread) G (goroutine) P (Processor) P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量） 每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量） M和P的数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP 原理与调度\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"M和P的数量没有绝对关系，启动以后P是固定的而M是动态的","slug":"m和p的数量没有绝对关系-启动以后p是固定的而m是动态的","link":"#m和p的数量没有绝对关系-启动以后p是固定的而m是动态的","children":[]},{"level":3,"title":"一些简单的问题 work stealing && hand off","slug":"一些简单的问题-work-stealing-hand-off","link":"#一些简单的问题-work-stealing-hand-off","children":[]},{"level":3,"title":"在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死 - 抢占式调度","slug":"在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度","link":"#在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度","children":[]},{"level":3,"title":"调度器的生命周期","slug":"调度器的生命周期","link":"#调度器的生命周期","children":[]},{"level":3,"title":"可视化GMP编程","slug":"可视化gmp编程","link":"#可视化gmp编程","children":[]},{"level":3,"title":"线程自旋：系统中最多有 GOMAXPROCS 个自旋的线程","slug":"线程自旋-系统中最多有-gomaxprocs-个自旋的线程","link":"#线程自旋-系统中最多有-gomaxprocs-个自旋的线程","children":[]},{"level":3,"title":"goroutine的状态有多少个","slug":"goroutine的状态有多少个","link":"#goroutine的状态有多少个","children":[]},{"level":3,"title":"GMP相关调优","slug":"gmp相关调优","link":"#gmp相关调优","children":[]},{"level":3,"title":"已经被废弃的GM 和 最新的GPM 的对比","slug":"已经被废弃的gm-和-最新的gpm-的对比","link":"#已经被废弃的gm-和-最新的gpm-的对比","children":[]},{"level":3,"title":"本质上就是增加了 M 的本地队列 、 本质上就是增加了 M 的本地队列、本质上就是增加了 M 的本地队列","slug":"本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列","link":"#本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列","children":[]},{"level":3,"title":"M 的 P 里面的G可以是 全局队列拿的，也可以是其他 P 的本地队列拿的","slug":"m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的","link":"#m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的","children":[]},{"level":3,"title":"关于数量","slug":"关于数量","link":"#关于数量","children":[]},{"level":3,"title":"GMP-hello的执行过程","slug":"gmp-hello的执行过程","link":"#gmp-hello的执行过程","children":[]},{"level":3,"title":"关键术语","slug":"关键术语","link":"#关键术语","children":[]},{"level":3,"title":"抢占式调度","slug":"抢占式调度","link":"#抢占式调度","children":[]},{"level":3,"title":"GMP的让出创建恢复","slug":"gmp的让出创建恢复","link":"#gmp的让出创建恢复","children":[]},{"level":3,"title":"协程状态","slug":"协程状态","link":"#协程状态","children":[]},{"level":3,"title":"备注","slug":"备注","link":"#备注","children":[]},{"level":3,"title":"协程创建后会加入 P 的本地队列runq之中","slug":"协程创建后会加入-p-的本地队列runq之中","link":"#协程创建后会加入-p-的本地队列runq之中","children":[]},{"level":3,"title":"main.main运行结束以后runtime.main会调用exit函数结束进程","slug":"main-main运行结束以后runtime-main会调用exit函数结束进程","link":"#main-main运行结束以后runtime-main会调用exit函数结束进程","children":[]},{"level":3,"title":"M 执行 G 的时候发生阻塞，那么 M 会失去原有的 P（摘除），然后创建新的 M 服务这个 P","slug":"m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p","link":"#m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p","children":[]}],"readingTime":{"minutes":4.12,"words":1235},"filePathRelative":"posts/go/GMP原理与调度.md","excerpt":"\\n<p><a href=\\"https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">GMP 原理与调度</a></p>\\n<ol>\\n<li>M (thread)  G (goroutine) P (Processor)</li>\\n<li>P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量）</li>\\n<li>每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量）</li>\\n</ol>","autoDesc":true}')}}]);