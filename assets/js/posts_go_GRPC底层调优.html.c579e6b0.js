"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1149],{6262:(e,s)=>{s.A=(e,s)=>{const n=e.__vccOpts||e;for(const[e,i]of s)n[e]=i;return n}},2741:(e,s,n)=>{n.r(s),n.d(s,{comp:()=>l,data:()=>t});var i=n(641);const a={},l=(0,n(6262).A)(a,[["render",function(e,s){return(0,i.uX)(),(0,i.CE)("div",null,s[0]||(s[0]=[(0,i.Fv)('<h1 id="grpc多路复用" tabindex="-1"><a class="header-anchor" href="#grpc多路复用"><span>GRPC多路复用</span></a></h1><h3 id="场景题-client-dial一个8100端口-客户端持有了1个tcp连接-对吗-如果有多个请求-这几个请求是顺序执行的吗" tabindex="-1"><a class="header-anchor" href="#场景题-client-dial一个8100端口-客户端持有了1个tcp连接-对吗-如果有多个请求-这几个请求是顺序执行的吗"><span>场景题，client Dial一个8100端口，客户端持有了1个TCP连接，对吗，如果有多个请求，这几个请求是顺序执行的吗</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>是建立起一个连接，获取一个ClientConn(TCP连接建立、TLS握手等封装)</span></span>\n<span class="line"><span>多个请求的话都会使用这个连接，发送如果顺序在传输层也是顺序，但是server的响应不会是顺序的</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>比如GetUserInfo后执行ClientConnInterface.Invoke的实现之中</span></span>\n<span class="line"><span>SendMsg之后，阻塞到RecvMsg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="server的lister获取了一个net-listener监听一个端口-这个端口收到多个数据包-他的执行次序是这么样的" tabindex="-1"><a class="header-anchor" href="#server的lister获取了一个net-listener监听一个端口-这个端口收到多个数据包-他的执行次序是这么样的"><span>server的lister获取了一个net.Listener监听一个端口，这个端口收到多个数据包，他的执行次序是这么样的</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>server.Server执行后会阻塞在一个for循环不断的等待net.Listener.Accept</span></span>\n<span class="line"><span>传输层的次序应用层管不了，我们通过socket与传输层沟通，而accept这个方法就是传输层的数据给过来的时候</span></span>\n<span class="line"><span>执行次序当然取决于accept接收数据包的顺序</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>上面说的监听一个端口只是创建了一个套接字socket</span></span>\n<span class="line"><span>也就是获取一个应用层和传输的沟通的媒介</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>server.socket.bind只能1个bind: address already in use</span></span>\n<span class="line"><span>client.net.Dial可以多个</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="grpc需要连接池吗" tabindex="-1"><a class="header-anchor" href="#grpc需要连接池吗"><span>grpc需要连接池吗</span></a></h3><h3 id="service的listen和client的dial的源码解析" tabindex="-1"><a class="header-anchor" href="#service的listen和client的dial的源码解析"><span>service的Listen和Client的Dial的源码解析</span></a></h3><h3 id="客户端请求失败后会默认重试吗" tabindex="-1"><a class="header-anchor" href="#客户端请求失败后会默认重试吗"><span>客户端请求失败后会默认重试吗</span></a></h3><h3 id="为什么要用http-2作为传输协议" tabindex="-1"><a class="header-anchor" href="#为什么要用http-2作为传输协议"><span>为什么要用HTTP/2作为传输协议</span></a></h3><h3 id="在kubernetes中grpc负载均衡有问题" tabindex="-1"><a class="header-anchor" href="#在kubernetes中grpc负载均衡有问题"><span>在Kubernetes中gRPC负载均衡有问题</span></a></h3><h3 id="grpc-dial默认是异步还是同步连接-dialcontext的context什么时候会失效" tabindex="-1"><a class="header-anchor" href="#grpc-dial默认是异步还是同步连接-dialcontext的context什么时候会失效"><span>grpc.Dial默认是异步还是同步连接，DialContext的context什么时候会失效</span></a></h3><h1 id="关键词" tabindex="-1"><a class="header-anchor" href="#关键词"><span>关键词</span></a></h1><ol><li><p>HTTP/2，双向流、流量控制WINDOW_UPDATE、Protobuf序列化压缩、头部压缩、单TCP连接上的多复用请求</p></li><li><p>服务端关键的方法 grpc.NewServer、grpc.RegisterService、grpc.Server.Serve(net.Listener)</p></li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Server(net.Listener)的时候传入TCPConn 基于 TCP Listener</span></span>\n<span class="line"><span>最后启动for循环不断等待listener.Accept接收到net.Conn传递给新协程处理</span></span>\n<span class="line"><span>这for循环内有一个time.Sleep休眠从5ms到1s之间</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>客户端的DialContext</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>ClientConn等一堆初始化</span></span>\n<span class="line"><span>基于进程 LB）负载均衡配置</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>addrConn.connect</span></span>\n<span class="line"><span>addrConn.resetTransport (不断地去尝试创建连接,Backoff算法的重试机制直至成功或者直到上下文取消)</span></span>\n<span class="line"><span>addrConn.createTransport</span></span>\n<span class="line"><span>addrConn.getReadyTransport</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>重试机制最大间隔时间120s</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>异步连接 </span></span>\n<span class="line"><span>WithBlock可以同步连接，会阻塞DialContext直至连接会到达Ready状态（握手成功）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="4"><li>客户端的调用最终是grpc.invoke</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>newClientStream 获取传输层Trasport并组合ClientStream（负载均衡、超时控制）都在这一步</span></span>\n<span class="line"><span>cs.SendMsg 发送请求</span></span>\n<span class="line"><span>cs.RecvMsg 阻塞等待请求结果回来</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>客户端关闭连接client.ClientConn.Close</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>清空并关闭客户端连接\\解析器连接\\负载均衡连接等</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="6"><li>如果不断Dial却不调用Close会导致内存泄漏</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>TCP连接也会一直占用</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="7"><li>频繁创建ClientConn会出现资源句柄过多的情况，建议池化或者公用</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>dialing dial tcp :10001: socket: too many open file</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="6"><li>k8s中，因为HTTP/2每次请求会复用原有连接（http/1.1会每次请求创建新连接）</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>kube-proxy的负载均衡在创建连接时候有效，复用原有连接就会导致所有的grpc请求都到了同一个服务</span></span>\n<span class="line"><span>（使用 k8s service 做负载均衡的情况下）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>gRPC 有四种调用方式，分别是一元、服务端/客户端流式、双向流式</li></ol><h3 id="相关博客" tabindex="-1"><a class="header-anchor" href="#相关博客"><span>相关博客</span></a></h3><p><a href="https://blog.csdn.net/cljdsc/article/details/124134531" target="_blank" rel="noopener noreferrer">why write: broken pipe</a><a href="https://juejin.cn/post/7118357388561907743" target="_blank" rel="noopener noreferrer">gRPC 客户端调用服务端需要连接池吗</a><a href="https://eddycjy.gitbook.io/golang/di-1-ke-za-tan/talking-grpc" target="_blank" rel="noopener noreferrer">从实践到原理，带你参透 gRPC</a></p>',29)]))}]]),t=JSON.parse('{"path":"/posts/go/GRPC%E5%BA%95%E5%B1%82%E8%B0%83%E4%BC%98.html","title":"GRPC多路复用","lang":"zh-CN","frontmatter":{"hide":true,"description":"GRPC多路复用 场景题，client Dial一个8100端口，客户端持有了1个TCP连接，对吗，如果有多个请求，这几个请求是顺序执行的吗 server的lister获取了一个net.Listener监听一个端口，这个端口收到多个数据包，他的执行次序是这么样的 grpc需要连接池吗 service的Listen和Client的Dial的源码解析 客户...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/GRPC%E5%BA%95%E5%B1%82%E8%B0%83%E4%BC%98.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"GRPC多路复用"}],["meta",{"property":"og:description","content":"GRPC多路复用 场景题，client Dial一个8100端口，客户端持有了1个TCP连接，对吗，如果有多个请求，这几个请求是顺序执行的吗 server的lister获取了一个net.Listener监听一个端口，这个端口收到多个数据包，他的执行次序是这么样的 grpc需要连接池吗 service的Listen和Client的Dial的源码解析 客户..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GRPC多路复用\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"场景题，client Dial一个8100端口，客户端持有了1个TCP连接，对吗，如果有多个请求，这几个请求是顺序执行的吗","slug":"场景题-client-dial一个8100端口-客户端持有了1个tcp连接-对吗-如果有多个请求-这几个请求是顺序执行的吗","link":"#场景题-client-dial一个8100端口-客户端持有了1个tcp连接-对吗-如果有多个请求-这几个请求是顺序执行的吗","children":[]},{"level":3,"title":"server的lister获取了一个net.Listener监听一个端口，这个端口收到多个数据包，他的执行次序是这么样的","slug":"server的lister获取了一个net-listener监听一个端口-这个端口收到多个数据包-他的执行次序是这么样的","link":"#server的lister获取了一个net-listener监听一个端口-这个端口收到多个数据包-他的执行次序是这么样的","children":[]},{"level":3,"title":"grpc需要连接池吗","slug":"grpc需要连接池吗","link":"#grpc需要连接池吗","children":[]},{"level":3,"title":"service的Listen和Client的Dial的源码解析","slug":"service的listen和client的dial的源码解析","link":"#service的listen和client的dial的源码解析","children":[]},{"level":3,"title":"客户端请求失败后会默认重试吗","slug":"客户端请求失败后会默认重试吗","link":"#客户端请求失败后会默认重试吗","children":[]},{"level":3,"title":"为什么要用HTTP/2作为传输协议","slug":"为什么要用http-2作为传输协议","link":"#为什么要用http-2作为传输协议","children":[]},{"level":3,"title":"在Kubernetes中gRPC负载均衡有问题","slug":"在kubernetes中grpc负载均衡有问题","link":"#在kubernetes中grpc负载均衡有问题","children":[]},{"level":3,"title":"grpc.Dial默认是异步还是同步连接，DialContext的context什么时候会失效","slug":"grpc-dial默认是异步还是同步连接-dialcontext的context什么时候会失效","link":"#grpc-dial默认是异步还是同步连接-dialcontext的context什么时候会失效","children":[]},{"level":3,"title":"相关博客","slug":"相关博客","link":"#相关博客","children":[]}],"readingTime":{"minutes":2.93,"words":878},"filePathRelative":"posts/go/GRPC底层调优.md","excerpt":"\\n<h3>场景题，client Dial一个8100端口，客户端持有了1个TCP连接，对吗，如果有多个请求，这几个请求是顺序执行的吗</h3>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>是建立起一个连接，获取一个ClientConn(TCP连接建立、TLS握手等封装)</span></span>\\n<span class=\\"line\\"><span>多个请求的话都会使用这个连接，发送如果顺序在传输层也是顺序，但是server的响应不会是顺序的</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>比如GetUserInfo后执行ClientConnInterface.Invoke的实现之中</span></span>\\n<span class=\\"line\\"><span>SendMsg之后，阻塞到RecvMsg</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);