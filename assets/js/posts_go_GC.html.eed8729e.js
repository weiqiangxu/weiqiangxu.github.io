"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6563],{6262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}},1707:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>p});var e=a(641);const i={},l=(0,a(6262).A)(i,[["render",function(s,n){return(0,e.uX)(),(0,e.CE)("div",null,n[0]||(n[0]=[(0,e.Fv)('<h3 id="进程虚拟地址空间" tabindex="-1"><a class="header-anchor" href="#进程虚拟地址空间"><span>进程虚拟地址空间</span></a></h3><ol><li>Code Segment 代码段（程序要执行的指令）</li><li>Data Segment 数据段(全局变量、静态数据)</li><li>Heap 堆（需要程序手动释放）（c\\c++ 手动垃圾回收容易出现 悬挂指针-释放早了、内存泄漏-忘了释放）</li><li>Stack 栈（函数局部变量、参数和返回值）函数调用完成后销毁（随着函数调用栈的销毁而释放内存）</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>栈、Data Segment 数据段上的对象作为root</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>基于它们 2个追踪</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>能追踪到的数据就代表是存活有引用的数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>不能编译期间确定大小（append slice）生命周期超出该函数（返回 *int） 不适合分配栈上（内存逃逸）</p></blockquote><blockquote><p>程序中用得到的数据一定是栈、数据段可以追踪到的数据，追踪不到也就意味着用不上</p></blockquote><h3 id="主流垃圾回收算法-数据-可达性-近似等于-存活性" tabindex="-1"><a class="header-anchor" href="#主流垃圾回收算法-数据-可达性-近似等于-存活性"><span>主流垃圾回收算法 ： 数据 “可达性” 近似等于 “存活性”</span></a></h3><ol><li>标记-清扫算法 核心思想</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>追踪数据，能追踪到的进行标记</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>追踪不到的就是垃圾</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>三色抽象 (heap \\ stack \\ data segment) 白色\\灰色\\黑色</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>a. 刚开始数据都是白色</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>b. 直接追踪到的root节点标记为灰色（当前节点展开追踪还未完成）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>c. 节点追踪完成后标记为黑色</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>结论一、没有灰色时候表示追踪已经完成</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>结论二、回收所有白色对象的内存</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>结论三、黑色表明追踪完成，无需再追踪，是存活数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>什么情况下会出现存活数据误判为垃圾</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>当存活数据（白色）在与黑色对象关联，而黑色对象是标记完成的不会再做标记，白色就一直是白色就会被清除</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>所以白色对象不能被黑色引用 （读写屏障）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="强弱三色不变式-严禁白色被黑色引用、白色可以被灰色引用" tabindex="-1"><a class="header-anchor" href="#强弱三色不变式-严禁白色被黑色引用、白色可以被灰色引用"><span>强弱三色不变式 （严禁白色被黑色引用、白色可以被灰色引用）</span></a></h3><h3 id="标记清扫容易造成内存碎片化-大量不连续的小分块内存-涉及内存使用率" tabindex="-1"><a class="header-anchor" href="#标记清扫容易造成内存碎片化-大量不连续的小分块内存-涉及内存使用率"><span>标记清扫容易造成内存碎片化 - 大量不连续的小分块内存 - 涉及内存使用率</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 按内存规格分类排列</span></span>\n<span class="line"><span>2. 移动内存数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li><p>标记 - 整理算法（标记后移动非垃圾数据）（扫描移动开销）</p></li><li><p>分代回收（新生代、老年代）老年代对象经历多次GC依然存活是更有生命力的 （降低对老年代对象GC的频率提升GC效率）</p></li></ol><h3 id="引用计数式回收" tabindex="-1"><a class="header-anchor" href="#引用计数式回收"><span>引用计数式回收</span></a></h3><ol><li>引用计数表示一个对象被引用的次数（计数为0时候表示可以被回收）</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>引用计数垃圾识别的任务分摊到每一次对数据对象的操作之中</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>高频率更新引用计数带来开销</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>循环引用带来内存泄漏</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="增量式垃圾回收-停止程序一小段时间清理垃圾再执行程序" tabindex="-1"><a class="header-anchor" href="#增量式垃圾回收-停止程序一小段时间清理垃圾再执行程序"><span>增量式垃圾回收 - 停止程序一小段时间清理垃圾再执行程序</span></a></h3><h3 id="说一说个人对go垃圾回收的理解" tabindex="-1"><a class="header-anchor" href="#说一说个人对go垃圾回收的理解"><span>说一说个人对Go垃圾回收的理解</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>第一就是程序执行的内存之中大概分成四种：代码段、数据段、栈、堆；其中需要清理的是堆数据里面的垃圾数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>那么在堆里面什么样的数据认为是垃圾数据呢，就是没有被栈和数据段引用数据 - 就是垃圾数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>所以从栈和数据段开始追踪扫描，但凡是追踪不到的就是垃圾数据 （标记 - 清扫算法核心思想）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>golang的也是这种标记清扫的思想</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>同时golang又实用了三色抽象去清扫垃圾</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第一将所有内存标记为白色</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第二将所有追踪到的数据标记为灰色</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第三对所有灰色追踪灰色能追踪到的数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>第四所有追踪完下属数据的标记为黑色</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>最后白色的数据就是无法追踪到的数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>白色的数据进行清除</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>缺点是会产生内存碎片，衍生出了标记压缩、复制等方式处理内存碎片</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">Golang合集</a><a href="https://www.modb.pro/db/171818" target="_blank" rel="noopener noreferrer">Go语言中的GC</a></p>',21)]))}]]),p=JSON.parse('{"path":"/posts/go/GC.html","title":"GC","lang":"zh-CN","frontmatter":{"title":"GC","tags":["GO原理"],"categories":["go"],"date":"2023-04-08T06:40:12.000Z","index_img":"/images/bg/computer.jpeg","hide":true,"description":"进程虚拟地址空间 Code Segment 代码段（程序要执行的指令） Data Segment 数据段(全局变量、静态数据) Heap 堆（需要程序手动释放）（c\\\\c++ 手动垃圾回收容易出现 悬挂指针-释放早了、内存泄漏-忘了释放） Stack 栈（函数局部变量、参数和返回值）函数调用完成后销毁（随着函数调用栈的销毁而释放内存） 不能编译期间确定大...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/GC.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"GC"}],["meta",{"property":"og:description","content":"进程虚拟地址空间 Code Segment 代码段（程序要执行的指令） Data Segment 数据段(全局变量、静态数据) Heap 堆（需要程序手动释放）（c\\\\c++ 手动垃圾回收容易出现 悬挂指针-释放早了、内存泄漏-忘了释放） Stack 栈（函数局部变量、参数和返回值）函数调用完成后销毁（随着函数调用栈的销毁而释放内存） 不能编译期间确定大..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"GO原理"}],["meta",{"property":"article:published_time","content":"2023-04-08T06:40:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GC\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-08T06:40:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"进程虚拟地址空间","slug":"进程虚拟地址空间","link":"#进程虚拟地址空间","children":[]},{"level":3,"title":"主流垃圾回收算法 ： 数据 “可达性” 近似等于 “存活性”","slug":"主流垃圾回收算法-数据-可达性-近似等于-存活性","link":"#主流垃圾回收算法-数据-可达性-近似等于-存活性","children":[]},{"level":3,"title":"强弱三色不变式 （严禁白色被黑色引用、白色可以被灰色引用）","slug":"强弱三色不变式-严禁白色被黑色引用、白色可以被灰色引用","link":"#强弱三色不变式-严禁白色被黑色引用、白色可以被灰色引用","children":[]},{"level":3,"title":"标记清扫容易造成内存碎片化 - 大量不连续的小分块内存 - 涉及内存使用率","slug":"标记清扫容易造成内存碎片化-大量不连续的小分块内存-涉及内存使用率","link":"#标记清扫容易造成内存碎片化-大量不连续的小分块内存-涉及内存使用率","children":[]},{"level":3,"title":"引用计数式回收","slug":"引用计数式回收","link":"#引用计数式回收","children":[]},{"level":3,"title":"增量式垃圾回收 - 停止程序一小段时间清理垃圾再执行程序","slug":"增量式垃圾回收-停止程序一小段时间清理垃圾再执行程序","link":"#增量式垃圾回收-停止程序一小段时间清理垃圾再执行程序","children":[]},{"level":3,"title":"说一说个人对Go垃圾回收的理解","slug":"说一说个人对go垃圾回收的理解","link":"#说一说个人对go垃圾回收的理解","children":[]}],"readingTime":{"minutes":3.49,"words":1047},"filePathRelative":"posts/go/GC.md","localizedDate":"2023年4月8日","excerpt":"<h3>进程虚拟地址空间</h3>\\n<ol>\\n<li>Code Segment 代码段（程序要执行的指令）</li>\\n<li>Data Segment 数据段(全局变量、静态数据)</li>\\n<li>Heap 堆（需要程序手动释放）（c\\\\c++ 手动垃圾回收容易出现 悬挂指针-释放早了、内存泄漏-忘了释放）</li>\\n<li>Stack 栈（函数局部变量、参数和返回值）函数调用完成后销毁（随着函数调用栈的销毁而释放内存）</li>\\n</ol>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>栈、Data Segment 数据段上的对象作为root</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>基于它们 2个追踪</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>能追踪到的数据就代表是存活有引用的数据</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);