"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2471],{6262:(e,a)=>{a.A=(e,a)=>{const s=e.__vccOpts||e;for(const[e,n]of a)s[e]=n;return s}},406:(e,a,s)=>{s.r(a),s.d(a,{comp:()=>l,data:()=>r});var n=s(641);const i={},l=(0,s(6262).A)(i,[["render",function(e,a){return(0,n.uX)(),(0,n.CE)("div",null,a[0]||(a[0]=[(0,n.Fv)('<h3 id="逐个发送" tabindex="-1"><a class="header-anchor" href="#逐个发送"><span>逐个发送</span></a></h3><p><a href="https://zhuanlan.zhihu.com/p/451678059" target="_blank" rel="noopener noreferrer">华为云开发者联盟​-带你认识三种kafka消息发送模式</a></p><ol><li>Fire-and-forget (不关心可靠性)</li><li>Synchronous send (关心次序)</li><li>Asynchronous send (不关心次序)</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>逐条发送</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>请求队列InFlightRequest中永远最多有一条数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>批量发送参数：max.in.flight.requests.per.connection=1 &amp; batch.size=1 效果也是逐条发送</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="批量发送" tabindex="-1"><a class="header-anchor" href="#批量发送"><span>批量发送</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>批量发送</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>运行生产者以batch的形式push数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>queue.buffering.max.ms = 5000 缓存5s的数据后batch发送</span></span>\n<span class="line"><span>queue.buffering.max.messages = 100  缓存队列最大数(尽量大)超过了会丢弃消息或阻塞</span></span>\n<span class="line"><span>queue.enqueue.timeout.ms = 0/-1 设置0时丢弃消息，设置-1是阻塞</span></span>\n<span class="line"><span>batch.num.messages = 100 batch缓存的消息数量达到了才会发送出去</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="ack机制" tabindex="-1"><a class="header-anchor" href="#ack机制"><span>ack机制</span></a></h3><blockquote><p>broker 收到消息之后在什么状态下（直接返回,leader success, follower&amp;leader success）返回success</p></blockquote><h3 id="java代码发送消息的三种模式-代码client实现" tabindex="-1"><a class="header-anchor" href="#java代码发送消息的三种模式-代码client实现"><span>Java代码发送消息的三种模式 - 代码client实现</span></a></h3><ol><li>发后即忘 (发送了不管成功与否)</li><li>同步(发送后等待结果)</li><li>异步（发送消息时指定回调函数，Kafka在返回响应时会调用该函数实现异步的发送确认）</li></ol><p><a href="https://blog.csdn.net/m0_45406092/article/details/119546471" target="_blank" rel="noopener noreferrer">【Kafka】消息的同步发送和异步发送</a></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>producer.type = sync\\async</span></span>\n<span class="line"><span>queue.buffering.max.ms</span></span>\n<span class="line"><span>queue.buffering.max.messages</span></span>\n<span class="line"><span>queue.enqueue.timeout.ms</span></span>\n<span class="line"><span>batch.num.messages</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="可靠性机制-ack属性配置" tabindex="-1"><a class="header-anchor" href="#可靠性机制-ack属性配置"><span>可靠性机制(ack属性配置)</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>acks = 0/1/-1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="同步和异步指client-producer-是否收到leader给的ack后才发下一条" tabindex="-1"><a class="header-anchor" href="#同步和异步指client-producer-是否收到leader给的ack后才发下一条"><span>同步和异步指client(producer)是否收到leader给的ack后才发下一条</span></a></h3><h3 id="ack-0时候已经忽略可靠性了-同步发送又有什么意义呢" tabindex="-1"><a class="header-anchor" href="#ack-0时候已经忽略可靠性了-同步发送又有什么意义呢"><span>ack=0时候已经忽略可靠性了，同步发送又有什么意义呢</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>同步方式最可靠、可重试</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>发送并忘记最快 - 无可靠性</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>异步发送加回调函数 - 效率较高且可知道结果</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h3><p><a href="https://zhuanlan.zhihu.com/p/531447457" target="_blank" rel="noopener noreferrer">知乎</a></p>',19)]))}]]),r=JSON.parse('{"path":"/posts/kafka/%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81.html","title":"同步和异步发送","lang":"zh-CN","frontmatter":{"title":"同步和异步发送","tags":["kafka"],"categories":["kafka"],"description":"逐个发送 华为云开发者联盟​-带你认识三种kafka消息发送模式 Fire-and-forget (不关心可靠性) Synchronous send (关心次序) Asynchronous send (不关心次序) 批量发送 ack机制 broker 收到消息之后在什么状态下（直接返回,leader success, follower&leader s...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/kafka/%E5%90%8C%E6%AD%A5%E5%8F%91%E9%80%81%E5%92%8C%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"同步和异步发送"}],["meta",{"property":"og:description","content":"逐个发送 华为云开发者联盟​-带你认识三种kafka消息发送模式 Fire-and-forget (不关心可靠性) Synchronous send (关心次序) Asynchronous send (不关心次序) 批量发送 ack机制 broker 收到消息之后在什么状态下（直接返回,leader success, follower&leader s..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"kafka"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"同步和异步发送\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"逐个发送","slug":"逐个发送","link":"#逐个发送","children":[]},{"level":3,"title":"批量发送","slug":"批量发送","link":"#批量发送","children":[]},{"level":3,"title":"ack机制","slug":"ack机制","link":"#ack机制","children":[]},{"level":3,"title":"Java代码发送消息的三种模式 - 代码client实现","slug":"java代码发送消息的三种模式-代码client实现","link":"#java代码发送消息的三种模式-代码client实现","children":[]},{"level":3,"title":"可靠性机制(ack属性配置)","slug":"可靠性机制-ack属性配置","link":"#可靠性机制-ack属性配置","children":[]},{"level":3,"title":"同步和异步指client(producer)是否收到leader给的ack后才发下一条","slug":"同步和异步指client-producer-是否收到leader给的ack后才发下一条","link":"#同步和异步指client-producer-是否收到leader给的ack后才发下一条","children":[]},{"level":3,"title":"ack=0时候已经忽略可靠性了，同步发送又有什么意义呢","slug":"ack-0时候已经忽略可靠性了-同步发送又有什么意义呢","link":"#ack-0时候已经忽略可靠性了-同步发送又有什么意义呢","children":[]},{"level":3,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"readingTime":{"minutes":1.42,"words":426},"filePathRelative":"posts/kafka/同步发送和异步发送.md","excerpt":"<h3>逐个发送</h3>\\n<p><a href=\\"https://zhuanlan.zhihu.com/p/451678059\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">华为云开发者联盟​-带你认识三种kafka消息发送模式</a></p>\\n<ol>\\n<li>Fire-and-forget (不关心可靠性)</li>\\n<li>Synchronous send (关心次序)</li>\\n<li>Asynchronous send (不关心次序)</li>\\n</ol>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>逐条发送</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>请求队列InFlightRequest中永远最多有一条数据</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>批量发送参数：max.in.flight.requests.per.connection=1 &amp; batch.size=1 效果也是逐条发送</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);