"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8102],{6262:(e,a)=>{a.A=(e,a)=>{const n=e.__vccOpts||e;for(const[e,i]of a)n[e]=i;return n}},9056:(e,a,n)=>{n.r(a),n.d(a,{comp:()=>t,data:()=>s});var i=n(641);const l={},t=(0,n(6262).A)(l,[["render",function(e,a){return(0,i.uX)(),(0,i.CE)("div",null,a[0]||(a[0]=[(0,i.Fv)('<h1 id="gpm" tabindex="-1"><a class="header-anchor" href="#gpm"><span>GPM</span></a></h1><blockquote><p>这篇文章写的太细致了，amazing</p></blockquote><ol><li>G goroutine</li><li>P processor</li><li>M thread</li></ol><h3 id="术语" tabindex="-1"><a class="header-anchor" href="#术语"><span>术语</span></a></h3><ol><li>全局队列 Global Queue</li><li>P的本地队列 (max 256) (out of size move half to GP)</li><li>P(runtime.GOMAXPROCS数量),程序启动时创建</li><li>M 从P之中获取G运行,P本地队列空了从 [Global Queue] 放到P的本地队列或者从 [其他P的本地队列] 偷一半到自己P的本地队列</li><li>M在不够用时可以新建M</li></ol><h3 id="m-和-p-的数量关系" tabindex="-1"><a class="header-anchor" href="#m-和-p-的数量关系"><span>M 和 P 的数量关系</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>数量上没有绝对的关系，P 固定而 M 不固定</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>G必须执行在M之中</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1个M必须有1个P，M和P是1:1 （绑定关系而言）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>M阻塞住了，P会寻找其他M</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="g创建以后优先甩p的本地队列-满了再往全局队列甩" tabindex="-1"><a class="header-anchor" href="#g创建以后优先甩p的本地队列-满了再往全局队列甩"><span>G创建以后优先甩P的本地队列，满了再往全局队列甩</span></a></h3><p><a href="https://www.yuque.com/aceld/golang/ithv8f" target="_blank" rel="noopener noreferrer">GO修养之路</a></p>',9)]))}]]),s=JSON.parse('{"path":"/posts/go/2.GPM%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.html","title":"GMP设计思想","lang":"zh-CN","frontmatter":{"title":"GMP设计思想","category":["go"],"tag":["go"],"description":"GPM 这篇文章写的太细致了，amazing G goroutine P processor M thread 术语 全局队列 Global Queue P的本地队列 (max 256) (out of size move half to GP) P(runtime.GOMAXPROCS数量),程序启动时创建 M 从P之中获取G运行,P本地队列空了从 ...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/2.GPM%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"GMP设计思想"}],["meta",{"property":"og:description","content":"GPM 这篇文章写的太细致了，amazing G goroutine P processor M thread 术语 全局队列 Global Queue P的本地队列 (max 256) (out of size move half to GP) P(runtime.GOMAXPROCS数量),程序启动时创建 M 从P之中获取G运行,P本地队列空了从 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"go"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP设计思想\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"术语","slug":"术语","link":"#术语","children":[]},{"level":3,"title":"M 和 P 的数量关系","slug":"m-和-p-的数量关系","link":"#m-和-p-的数量关系","children":[]},{"level":3,"title":"G创建以后优先甩P的本地队列，满了再往全局队列甩","slug":"g创建以后优先甩p的本地队列-满了再往全局队列甩","link":"#g创建以后优先甩p的本地队列-满了再往全局队列甩","children":[]}],"readingTime":{"minutes":0.77,"words":230},"filePathRelative":"posts/go/2.GPM设计思想.md","excerpt":"\\n<blockquote>\\n<p>这篇文章写的太细致了，amazing</p>\\n</blockquote>\\n<ol>\\n<li>G goroutine</li>\\n<li>P processor</li>\\n<li>M thread</li>\\n</ol>\\n<h3>术语</h3>\\n<ol>\\n<li>全局队列 Global Queue</li>\\n<li>P的本地队列 (max 256) (out of size move half to GP)</li>\\n<li>P(runtime.GOMAXPROCS数量),程序启动时创建</li>\\n<li>M 从P之中获取G运行,P本地队列空了从 [Global Queue] 放到P的本地队列或者从 [其他P的本地队列] 偷一半到自己P的本地队列</li>\\n<li>M在不够用时可以新建M</li>\\n</ol>","autoDesc":true}')}}]);