"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4788],{6262:(e,n)=>{n.A=(e,n)=>{const a=e.__vccOpts||e;for(const[e,s]of n)a[e]=s;return a}},7229:(e,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>t});var s=a(641);const i={},l=(0,a(6262).A)(i,[["render",function(e,n){return(0,s.uX)(),(0,s.CE)("div",null,n[0]||(n[0]=[(0,s.Fv)('<h1 id="如何退出协程" tabindex="-1"><a class="header-anchor" href="#如何退出协程"><span>如何退出协程</span></a></h1><h3 id="超时场景" tabindex="-1"><a class="header-anchor" href="#超时场景"><span>超时场景</span></a></h3><ol><li>模拟一个Goroutine泄漏的场景</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>父协程创建chan(无缓冲且只有父协程有接收的位置)且在子协程运行完成之前退出</span></span>\n<span class="line"><span>子协程(阻塞在 chan &lt;- true)(因为唯一接收的地方父协程关闭了)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>当父协程close了，子协程继续 chan &lt;- true 也会出错</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>defer 语句可能阻塞 goroutine 退出的情况有哪些</li></ol><h3 id="其他场景" tabindex="-1"><a class="header-anchor" href="#其他场景"><span>其他场景</span></a></h3><ol><li>例举一个协程泄漏的场景</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>巧妙地使用 close chan 以及 &lt;- chan 第二个参数解决协程泄漏</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="通道关闭原则" tabindex="-1"><a class="header-anchor" href="#通道关闭原则"><span>通道关闭原则</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>让一个通道唯一的发送者关闭此通道</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>可以避免 close chan 以后还有发送者执行 chan &lt;- 而导致 panic</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="使用-sync-once-关闭-chan-chan仅可以被关闭一次" tabindex="-1"><a class="header-anchor" href="#使用-sync-once-关闭-chan-chan仅可以被关闭一次"><span>使用 sync.Once 关闭 chan (chan仅可以被关闭一次)</span></a></h3><p><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></p>',12)]))}]]),t=JSON.parse('{"path":"/posts/go/%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E5%8D%8F%E7%A8%8B.html","title":"如何退出协程","lang":"zh-CN","frontmatter":{"hide":true,"description":"如何退出协程 超时场景 模拟一个Goroutine泄漏的场景 defer 语句可能阻塞 goroutine 退出的情况有哪些 其他场景 例举一个协程泄漏的场景 通道关闭原则 使用 sync.Once 关闭 chan (chan仅可以被关闭一次) GO语言高性能编程","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/%E5%A6%82%E4%BD%95%E9%80%80%E5%87%BA%E5%8D%8F%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"如何退出协程"}],["meta",{"property":"og:description","content":"如何退出协程 超时场景 模拟一个Goroutine泄漏的场景 defer 语句可能阻塞 goroutine 退出的情况有哪些 其他场景 例举一个协程泄漏的场景 通道关闭原则 使用 sync.Once 关闭 chan (chan仅可以被关闭一次) GO语言高性能编程"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何退出协程\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"超时场景","slug":"超时场景","link":"#超时场景","children":[]},{"level":3,"title":"其他场景","slug":"其他场景","link":"#其他场景","children":[]},{"level":3,"title":"通道关闭原则","slug":"通道关闭原则","link":"#通道关闭原则","children":[]},{"level":3,"title":"使用 sync.Once 关闭 chan (chan仅可以被关闭一次)","slug":"使用-sync-once-关闭-chan-chan仅可以被关闭一次","link":"#使用-sync-once-关闭-chan-chan仅可以被关闭一次","children":[]}],"readingTime":{"minutes":0.73,"words":220},"filePathRelative":"posts/go/如何退出协程.md","excerpt":"\\n<h3>超时场景</h3>\\n<ol>\\n<li>模拟一个Goroutine泄漏的场景</li>\\n</ol>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>父协程创建chan(无缓冲且只有父协程有接收的位置)且在子协程运行完成之前退出</span></span>\\n<span class=\\"line\\"><span>子协程(阻塞在 chan &lt;- true)(因为唯一接收的地方父协程关闭了)</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>当父协程close了，子协程继续 chan &lt;- true 也会出错</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);