"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6078],{6262:(e,t)=>{t.A=(e,t)=>{const n=e.__vccOpts||e;for(const[e,i]of t)n[e]=i;return n}},1298:(e,t,n)=>{n.r(t),n.d(t,{comp:()=>l,data:()=>s});var i=n(641);const a={},l=(0,n(6262).A)(a,[["render",function(e,t){return(0,i.uX)(),(0,i.CE)("div",null,t[0]||(t[0]=[(0,i.Fv)('<h1 id="来刷一下context源码" tabindex="-1"><a class="header-anchor" href="#来刷一下context源码"><span>来刷一下context源码</span></a></h1><blockquote><p>主要弄清楚 WithValue\\WithTimeout\\WithDeadline\\WithCancel 如何实现 子上下文和父上下文如何相互通讯的</p></blockquote><ol><li>跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗</li></ol><blockquote><p>不会</p></blockquote><ol start="2"><li>background和todo有什么区别</li></ol><blockquote><p>两个都是 emptyCtx int 都实现了接口 context.Context</p></blockquote><ol start="3"><li>context源码角度是一个什么样的结构</li></ol><blockquote><p>context.Context是一个interface 也就是一个待实现的接口</p></blockquote><ol start="4"><li><p>WithCancel() 和 WithTimeout() 可以通知多个goroutine, 如何实现的</p></li><li><p>ctx的key为name的value被子协程更改后，在主协程会变更吗</p></li></ol><blockquote><p>不会变</p></blockquote><ol start="6"><li>WithTimeout和WithCancel等本质上做了什么事情</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>context包有结构体 cancelCtx timerCtx valueCtx </span></span>\n<span class="line"><span>本质上每一次WithTimeout都是重新创建一个结构体，并且把当前的接口体赋到新结构体的属性变量之中</span></span>\n<span class="line"><span>所以结构体中存储parentContext</span></span>\n<span class="line"><span>以context.WithCancel为例</span></span>\n<span class="line"><span>如何在 parent.Done 的时候子 children.Done 呢</span></span>\n<span class="line"><span>本质上是起一个协程并且阻塞在 case &lt;-parent.Done() </span></span>\n<span class="line"><span>然后在阻塞通过后执行 children.Done</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>当执行 WithCancel 的时候，其实就是重新创建一个 cancelCtx 并且调用 propagateCancel 方法</span></span>\n<span class="line"><span>监听父级别上下文的信号，保证父级上下文关闭后，子上下文也发出cancel信号</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>c.Value 的访问</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>每次 WithValue 都会封装一次 valueCtx，然后把值和key存储到新的 valueCtx 之中</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>c.Value 的访问，是对当前的上下文的value访问，如果找不到那么查找父级上下文，找不到继续如何迭代查找</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li>WithTimeout如何实现的</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>源码是通过注册 time.AfterFunc 调用 ctx.cancel 函数执行的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="9"><li><p>为什么说context是线程安全的，如何实现的</p></li><li><p>context读取value会有什么问题（时间复杂度讲一下）嵌套很多层会逐个访问O(N)</p></li></ol><blockquote><p>contextl.Value的并发安全通过sync.Mutex实现</p></blockquote><p><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></p>',19)]))}]]),s=JSON.parse('{"path":"/posts/go/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html","title":"来刷一下context源码","lang":"zh-CN","frontmatter":{"description":"来刷一下context源码 主要弄清楚 WithValue\\\\WithTimeout\\\\WithDeadline\\\\WithCancel 如何实现 子上下文和父上下文如何相互通讯的 跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗 不会 background和todo有什么区别 两个都是 emptyCtx int 都实现了接口 con...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/Context%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"来刷一下context源码"}],["meta",{"property":"og:description","content":"来刷一下context源码 主要弄清楚 WithValue\\\\WithTimeout\\\\WithDeadline\\\\WithCancel 如何实现 子上下文和父上下文如何相互通讯的 跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗 不会 background和todo有什么区别 两个都是 emptyCtx int 都实现了接口 con..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"来刷一下context源码\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[],"readingTime":{"minutes":1.66,"words":497},"filePathRelative":"posts/go/Context源码解析.md","excerpt":"\\n<blockquote>\\n<p>主要弄清楚 WithValue\\\\WithTimeout\\\\WithDeadline\\\\WithCancel 如何实现\\n子上下文和父上下文如何相互通讯的</p>\\n</blockquote>\\n<ol>\\n<li>跟上下文被子协程A添加了timeout会影响到同样适用跟上下文的协程B吗</li>\\n</ol>\\n<blockquote>\\n<p>不会</p>\\n</blockquote>\\n<ol start=\\"2\\">\\n<li>background和todo有什么区别</li>\\n</ol>\\n<blockquote>\\n<p>两个都是 emptyCtx int 都实现了接口 context.Context</p>\\n</blockquote>","autoDesc":true}')}}]);