"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7525],{6262:(s,e)=>{e.A=(s,e)=>{const n=s.__vccOpts||s;for(const[s,i]of e)n[s]=i;return n}},6339:(s,e,n)=>{n.r(e),n.d(e,{comp:()=>l,data:()=>t});var i=n(641);const a={},l=(0,n(6262).A)(a,[["render",function(s,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h3 id="一、应用场景" tabindex="-1"><a class="header-anchor" href="#一、应用场景"><span>一、应用场景</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>HCI超融合的监控，我们的应用程序将会和主机一起打包销售，给到客户的时候启动主机，这个主机有可能是1台也有可能是3台。</span></span>\n<span class="line"><span>那么主机启动之后，监控服务随之启动;</span></span>\n<span class="line"><span>业务会暴露指标给prometheus采集</span></span>\n<span class="line"><span>这里的prometheus如果有1台主机那么就只有1个监控服务，如果有3台主机那么就会有3个监控服务，</span></span>\n<span class="line"><span>这3台机器上面的3个prometheus的实例各自的存储是独立的。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="二、需求" tabindex="-1"><a class="header-anchor" href="#二、需求"><span>二、需求</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. prometheus任何一台宕机，监控情况正常；</span></span>\n<span class="line"><span>2. prometheus独立于业务之外，监控不会影响业务，也就是在内存、磁盘等占用不会影响业务正常运行；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="三、目标" tabindex="-1"><a class="header-anchor" href="#三、目标"><span>三、目标</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. prometheus的高可用方案（数据同步、配置热重载、主从选举）；</span></span>\n<span class="line"><span>2. 限制prometheus的资源消耗；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="四、数据同步方案" tabindex="-1"><a class="header-anchor" href="#四、数据同步方案"><span>四、数据同步方案</span></a></h3><ol><li>多个Prometheus采集完全一样的数据，外边挂负载均衡用于查询监控数据</li></ol><figure><img src="/images/简单的高可用模式.jpg" alt="简单的集群模式" tabindex="0" loading="lazy"><figcaption>简单的集群模式</figcaption></figure><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>优点：</span></span>\n<span class="line"><span>1.配置简单</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>缺点：</span></span>\n<span class="line"><span>1.数据一致性取决于数据拉取频率，频率不高情况下，数据一致性较差；</span></span>\n<span class="line"><span>2.数据拉取频率高的情况下，对于业务的指标采集接口增加了网络IO压力，并且随着主机增多，压力加大；</span></span>\n<span class="line"><span>3.单机存储不适用于海量数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>多个prometheus将数据写入远程</li></ol><figure><img src="/images/远程写模式主从.png" alt="远程写模式主从" tabindex="0" loading="lazy"><figcaption>远程写模式主从</figcaption></figure><p>Prometheus的远程存储接口可以支持多种实现比如 Elasticsearch或者prometheus自身也提供了write接口；Prometheus 的 remote write 当 Prometheus 从目标上 pull 数据时，它会立即将这些数据写入本地存储，然后再将这些数据发送到远程写入端点。如果在此过程中发生错误，远程写入可能会失败，但不会导致数据丢失，因为数据已经写入了本地存储。 如果远程写入失败，会自动重试多次（次数可以配置）发送数据；</p><ul><li>优点：a.如果外挂存储引擎可以解决单机数据存储局限的问题；b.配置简单；</li><li>缺点：a.如果使用外部存储殷勤，需要额外部署一个远端数据存储服务；b.通过remote write失败会进行重试，这个重试次数和间隔不太好确定，不同的负载、业务需求都会不一样；</li></ul><ol start="3"><li>基于prometheus的federation联邦机制同步数据，做一主多从</li></ol><p>prometheus的端点/federate可以用于指标数据拉取，但是仅支持即时查询 Instant Query 返回的内容叫做即时向量 Instant Vector；同步时候仅仅可以获取当前某一个指标的最近的值；当新纳入一个节点时候，从prometheus从主prometheus拉取指标时候，只能拉取最新的指标，历史的指标不能拉取；所以新纳入一个节点，启动之前需要将主节点的prometheus的data数据目录同步过来，比如本地数据存储默认是 /data 目录。纳入新节点，开始同步文件到同步完成，最后启动从节点，这一段时间，主节点是仍然在工作的，这一段时间的指标，在从节点是不会被拉取的，会丢失。</p><figure><img src="/images/联邦模式的主从.png" alt="联邦模式的主从" tabindex="0" loading="lazy"><figcaption>联邦模式的主从</figcaption></figure><ul><li>优点：a.官方现有方案，配置相对简单；b.数据丢失范围相对可控，数据拉取间隔也是最大可能数据丢失间隔，比如从节点每隔10s拉一次cpu指标数据，那么从节点最大可能丢失10s的cpu指标数据；</li><li>缺点：a.无法拉取历史数据；b.一致性问题，主从同步延迟，查询从节点的监控数据会存在延迟；c.一主多从时候，对主节点的网络IO压力加大，但压缩传输消耗很小，很难达到瓶颈。</li></ul><h3 id="五、选主和配置热重载" tabindex="-1"><a class="header-anchor" href="#五、选主和配置热重载"><span>五、选主和配置热重载</span></a></h3><ol><li>基于etcd的分布式锁选主</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>3台prometheus的选主逻辑:</span></span>\n<span class="line"><span>主节点获得etcd的分布式锁，间隔30s租约续租方式保活，超过30s不续租，则会触发重新选主。</span></span>\n<span class="line"><span>支持手动选主，手动选主的方式是，在主节点续租的时候判定是否存在手动设置的主节点</span></span>\n<span class="line"><span>并且在选主的时候判定是否存在手动设置的主节点。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="/images/基于etcd的主从实现.png" alt="基于etcd的主从选举" tabindex="0" loading="lazy"><figcaption>基于etcd的主从选举</figcaption></figure><ol start="2"><li>配置热重载</li></ol><p>a.官方支持的 curl -X POST http://IP/-/reload，或者kill -HUP pid，会自动重新读取配置文件prometheus.yml；</p><p>优点：不用改造源码，方便后续prometheus升级； 缺点：需要程序操作生成yml配置文件并访问节点触发配置更新；</p><p>b.改造源码prometheus.Config.reloadConfig，实现基于ETCD的配置热重载，比如watch ETCD key并获取配置热重载。</p><p>优点：不需要admin程序直接访问prometheus节点，通过etcd解耦配置加载和写入； 缺点：改造源码后对后续升级不太友好，并且需要较多开发和测试成本投入；</p><h3 id="六、相关疑问" tabindex="-1"><a class="header-anchor" href="#六、相关疑问"><span>六、相关疑问</span></a></h3><ol><li>磁盘限制</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Prometheus中存储的每一个样本大概占用1-2字节大小</span></span>\n<span class="line"><span>磁盘大小 = 保留时间 * 每秒获取样本数 * 样本大小</span></span>\n<span class="line"><span>2byte * 1 * (3600*24*15) = 2.5GB</span></span>\n<span class="line"><span>假设每秒钟采集cpu占用指标，并且保存数据1个月，消耗的磁盘是2.5GB</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>storage.tsdb.path 存储数据的目录，默认为data/</span></span>\n<span class="line"><span>storage.tsdb.retention.time 数据过期清理时间，默认保存15天</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>单节点存储的限制，无法持久化海量的metrics数据，数据持久化的问题，默认保存15天</span></span>\n<span class="line"><span>原生的TSDB对于大数据量的保存及查询支持不太友好 </span></span>\n<span class="line"><span>所以并不适用于保存长期的大量数据（只能使用其他远程存储解决）一般Prometheus推荐只保留几周或者几个月的数据;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>单机prometheus采集指标数量大了会影响性能吗</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>一主的情况下，如果大量的target需要采集，prometheus pull的数据太多会带来以下几个问题:</span></span>\n<span class="line"><span>1.带宽占用</span></span>\n<span class="line"><span>2.内存</span></span>\n<span class="line"><span>3.CPU</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>官方推荐的是做分片，比如ABC三台prometheus分别采集不同业务的Metrics</span></span>\n<span class="line"><span>最后有一个C prometheus通过联邦机制汇总所有监控数据用于查询</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>但是关于带宽，prometheus的1个指标大概就 10bytes 例如:</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span># TYPE app_system_request counter</span></span>\n<span class="line"><span>app_system_request 0</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>federate机制主从最大可能丢失的数据范围是多大</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>取决于拉取数据的间隔，间隔15s的话，如果主节点宕机，那么会丢失主节点15s以内的监控数据。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="4"><li>federate的拉取间隔会如何影响指标数据展示</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>假设federate的更新时间点是10s一次，而job=cpu的监控要求是2s一次</span></span>\n<span class="line"><span>意味着从节点监控数据查询的话没办法实现高频率 (2s) 更新cpu指标监测</span></span>\n<span class="line"><span>但可以针对不同的指标设置不同的采集频率，或将所有的查询请求打到主节点</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="5"><li>单机的prometheus数据存储是多久</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Prometheus TSDB (Time Series DataBase) 以时间线分块存储监控数据。</span></span>\n<span class="line"><span>Prometheus的本地存储默认保留15天的数据，之后就会删除旧数据，间隔可以通过修改配置文件中的参数进行自定义。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="6"><li>主节点离线后再次接入监控集群，注册节点到选主再到切主成功大概需要多久</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>主节点离线，租约10s续约一次，假设主节点刚刚续约完就宕机了，那么在10s租约内，无法切主；</span></span>\n<span class="line"><span>过了10s之后，从节点获得分布式锁，选主成功，之后触发配置更新和热重载。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="7"><li>etcd宕机了，prometheus的运行情况是什么样的</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>如果是主节点正常的情况下，从节点和主节点工作正常；</span></span>\n<span class="line"><span>如果主节点不正常的情况下，从节点无法从主节点拉取数据，同时无法依赖etcd重新选主，从节点无法拉取指标；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ol start="8"><li>采集指标带宽占用如何计算</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>看exporter数量，1个exportner采集目标一个http请求，一个指标大概就2kb</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1个指标内容示例如下：</span></span>\n<span class="line"><span># HELP app_system_request request counter</span></span>\n<span class="line"><span># TYPE app_system_request counter</span></span>\n<span class="line"><span>app_system_request 1</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="9"><li>federate会同步历史数据吗</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>不会，联邦机制同步的是即使向量，走的是即使查询，历史的无法同步，需要手动同步文件系统通常是/data目录</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="10"><li>prometheus的内存消耗如何计算</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>首先存储结构来看，prometheus将数据按照时间段分块存储</span></span>\n<span class="line"><span>每一块数据单位为Block（Block里面的单位是chunk1、chuck2...和index、meta.json）；</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>内存消耗：</span></span>\n<span class="line"><span>1.因为每隔2小时有一个block数据落盘，落盘之前所有数据都在内存里面（限制block大小、缩短落盘间隔）;</span></span>\n<span class="line"><span>2.数据查询时，是从磁盘到内存的，查询范围越大，内存越大;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>内存消耗大小计算：</span></span>\n<span class="line"><span>假设采集的指标只有1个cpu的，cpu{node=xxx} 只有3个node，每15s采集一次，那么内存占用是2mb；</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>如何降低内存消耗:</span></span>\n<span class="line"><span>1.优化数据查询不要查询过大的时间范围的数据；</span></span>\n<span class="line"><span>2.调整query timeout（查询超时时间）对于不合理的查询超时后及时回收资源；</span></span>\n<span class="line"><span>3.--storage.tsdb.max-block-duration：该参数用于设置存储周期的最大时间范围，单位为小时。</span></span>\n<span class="line"><span>    默认值为 2 小时。可以根据需要适当调整该值，以减少存储需求和内存占用；</span></span>\n<span class="line"><span>4.--storage.tsdb.max-block-size：该参数用于设置每个块的最大大小，单位为字节。</span></span>\n<span class="line"><span>    默认值为 512MB。可以根据需要适当调整该值，以减少内存占用；</span></span>\n<span class="line"><span>5.Linux 中可以使用 ulimit 命令限制prometheus内存占用；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="11"><li>如何手动干预选主</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>干预抢ETCD锁和续约过程就可以实现手动选主；</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="12"><li>如何防止prometheus的内存爆满</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 配置合理的 retention time（数据保存周期）和 storage size（数据保存大小）。</span></span>\n<span class="line"><span>  这样可以避免 Prometheus 存储过多无用的数据。</span></span>\n<span class="line"><span>2. 使用短周期的数据抽样。通过将采样间隔降低到几秒钟，可以大大减少时间序列数据的数量。</span></span>\n<span class="line"><span>3. 调整 query timeout（查询超时时间）。如果查询超时，则查询将被取消，从而避免资源的浪费。</span></span>\n<span class="line"><span>4. 避免使用复杂的 PromQL 查询语句。复杂查询语句需要更多的计算资源，占用更多的内存。</span></span>\n<span class="line"><span>5. 使用 Prometheus 的 remote write 功能，将数据推送到外部存储中，释放的内存压力。</span></span>\n<span class="line"><span>6. 将 Prometheus 部署在资源较为充足的机器上，并尽可能提高机器的硬件配置。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="13"><li>如何控制prometheus运行内存占用大小</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>在 Prometheus 配置文件中，可以使用以下参数来设置最大内存占用：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>--storage.tsdb.max-block-duration：该参数用于设置存储周期的最大时间范围，单位为小时。</span></span>\n<span class="line"><span>  默认值为 2 小时。可以根据需要适当调整该值，以减少存储需求和内存占用。</span></span>\n<span class="line"><span>--storage.tsdb.retention：该参数用于设置每个使用者的数据保留时间。默认值为 15 天。</span></span>\n<span class="line"><span>  可以根据需要适当调整该值，以减少存储需求和内存占用。</span></span>\n<span class="line"><span>--storage.tsdb.max-block-size：该参数用于设置每个块的最大大小，单位为字节。</span></span>\n<span class="line"><span>  默认值为 512MB。可以根据需要适当调整该值，以减少内存占用。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>另外，还可以通过以下参数来配置 Prometheus 进程的最大内存占用：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>--storage.tsdb.no-lockfile：该参数用于禁用锁定文件，以减少磁盘 I/O。</span></span>\n<span class="line"><span>  在高负载环境中使用该参数可能会导致内存占用增加，但可以提高性能。</span></span>\n<span class="line"><span>--storage.tsdb.wal-compression：该参数用于启用 WAL 压缩，以减少磁盘 I/O 和内存占用。</span></span>\n<span class="line"><span>  默认情况下，WAL 压缩是禁用的。可以根据需要启用该功能。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>最后，还可以使用操作系统的资源限制功能来限制 Prometheus 进程的最大内存占用。</span></span>\n<span class="line"><span>例如，在 Linux 中可以使用 ulimit 命令来设置进程的最大虚拟内存或物理内存限制。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="14"><li>prometheus版本升级和编译</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> go</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> build</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./cmd/prometheus</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ol start="15"><li>storage.local.memory-chunks作用</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Prometheus的storage.local.memory-chunks是一个配置参数，</span></span>\n<span class="line"><span>用于调整Prometheus本地存储的内存占用量，控制Prometheus在内存中保留的时间序列数据点数量。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>具体来说，memory-chunks参数指定了Prometheus在内存中保留的时间序列数据块的数量。</span></span>\n<span class="line"><span>每个数据块包含一组时间序列数据点，这些数据点按照时间排序，并按照其标记（labels）进行索引。</span></span>\n<span class="line"><span>为了支持快速查询和聚合操作，Prometheus需要将一些时间序列数据点保留在内存中。</span></span>\n<span class="line"><span>memory-chunks参数的值越高，Prometheus在内存中保留的时间序列数据点就越多，但同时也会占用更多的内存资源。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>通过调整memory-chunks参数，用户可以平衡Prometheus在内存占用和查询性能之间的权衡。</span></span>\n<span class="line"><span>如果Prometheus需要处理大量的时间序列数据点，可以增加memory-chunks的值，以提高查询性能。</span></span>\n<span class="line"><span>但同时也需要确保Prometheus有足够的内存资源来存储这些数据点。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="16"><li>prometheus federation 和 remote write有哪些缺点</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. Prometheus Federation 缺点：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>- 需要手动配置和管理，对于大规模集群可能会增加管理成本。</span></span>\n<span class="line"><span>- Federation 中的实例依赖于网络性能，如果网络延迟较高，则可能导致数据同步不及时。</span></span>\n<span class="line"><span>- 不支持查询跨越多个 Federation 实例的聚合查询。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>虽然也是即时向量查询 - 但是这个查询回溯间隔可以设置大一点比如设置query.lookback-delta=5m</span></span>\n<span class="line"><span>那么可以查到倒计时5min内最后的指标</span></span>\n<span class="line"><span>cpu{node=xxx}@1232134324 56</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>2. Remote Write 缺点：</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>- 需要对写入的数据进行格式化和编码，使其适用于远程写入的目标存储系统。</span></span>\n<span class="line"><span>- 如果目标存储系统宕机或出现故障，数据可能会丢失或无法恢复。</span></span>\n<span class="line"><span>- Remote Write 操作需要进行网络传输，可能存在网络延迟等问题，可能导致数据同步不及时。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>丢数据相对概率大</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="17"><li>是否可以remote write prometheus</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>感觉这个特点很多人不知道</span></span>\n<span class="line"><span>以为 remote read\\remote write 必须配置第三方存储如 m3db 等，</span></span>\n<span class="line"><span>其实目标也可以prometheus实例</span></span>\n<span class="line"><span>只不过需要开启 --enable-feature=remote-write-receiver</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="18"><li>query.lookback-delta参数作用</li></ol><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>即时查询（Instant Query） 返回的内容叫做即时向量（ Instant Vector）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>因为是即时，如果当时没有数据，它会往前追溯，找到一个时间点。</span></span>\n<span class="line"><span>这个往回追溯的参数的值由 Prometheus 的启动参数 --query.lookback-delta 控制</span></span>\n<span class="line"><span>这个参数默认是  5 分钟。从监控的角度来看，建议调短一些</span></span>\n<span class="line"><span>比如改成 1 分钟 --query.lookback-delta=1m</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="19"><li>范围查询（Range Query）写法</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>范围查询（Range Query），返回的内容叫做 Range Vector</span></span>\n<span class="line"><span>{__name__=~&quot;node_load.*&quot;, zone=&quot;sh&quot;}[1m]</span></span>\n<span class="line"><span>这个范围就是1分钟，采集的多少个点都会返回</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="20"><li>本地启动如何指定存储路径</li></ol><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 数据存储在目录 /Users/Documents/data</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> ./prometheus</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> --storage.tsdb.path=/Users/Documents/data</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    --config.file=/Users/Documents/prometheus.yml</span><span style="--shiki-light:#0184BC;--shiki-dark:#56B6C2;"> \\</span></span>\n<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">    --web.listen-address=:8989</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料"><span>参考资料</span></a></h3><p><a href="https://www.kancloud.cn/pshizhsysu/prometheus/1803792" target="_blank" rel="noopener noreferrer">prometheus的时间序列指的是什么</a><a href="https://www.cnblogs.com/alchemystar/p/14462052.html" target="_blank" rel="noopener noreferrer">Prometheus时序数据库-磁盘中的存储结构</a><a href="https://www.robustperception.io/how-much-ram-does-prometheus-2-x-need-for-cardinality-and-ingestion/" target="_blank" rel="noopener noreferrer">根据指标数量和采集频率计算prometheus最大内存占用计算器</a><a href="https://github.com/ywanbing/golearning/tree/master/etcd_confd_prometheus" target="_blank" rel="noopener noreferrer">etcd + confd + prometheus 自动发现</a><a href="https://yunlzheng.gitbook.io/prometheus-book/part-ii-prometheus-jin-jie/sd/service-discovery-with-file" target="_blank" rel="noopener noreferrer">prometheus自带的基于文件的服务发现</a><a href="https://prometheus.io/blog/2015/08/17/service-discovery-with-etcd/" target="_blank" rel="noopener noreferrer">etcd 服务发现</a></p>',70)]))}]]),t=JSON.parse('{"path":"/posts/prometheus/prometheus%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E9%A2%84%E7%A0%94.html","title":"prometheus高可用方案预研","lang":"zh-CN","frontmatter":{"title":"prometheus高可用方案预研","index_img":"/images/prometheus_icon.jpeg","tags":["prometheus"],"categories":["prometheus"],"date":"2023-04-08T06:40:12.000Z","sticky":1,"description":"一、应用场景 二、需求 三、目标 四、数据同步方案 多个Prometheus采集完全一样的数据，外边挂负载均衡用于查询监控数据 简单的集群模式简单的集群模式 多个prometheus将数据写入远程 远程写模式主从远程写模式主从 Prometheus的远程存储接口可以支持多种实现比如 Elasticsearch或者prometheus自身也提供了writ...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/prometheus/prometheus%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88%E9%A2%84%E7%A0%94.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"prometheus高可用方案预研"}],["meta",{"property":"og:description","content":"一、应用场景 二、需求 三、目标 四、数据同步方案 多个Prometheus采集完全一样的数据，外边挂负载均衡用于查询监控数据 简单的集群模式简单的集群模式 多个prometheus将数据写入远程 远程写模式主从远程写模式主从 Prometheus的远程存储接口可以支持多种实现比如 Elasticsearch或者prometheus自身也提供了writ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://weiqiangxu.github.io/images/简单的高可用模式.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"prometheus"}],["meta",{"property":"article:published_time","content":"2023-04-08T06:40:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"prometheus高可用方案预研\\",\\"image\\":[\\"https://weiqiangxu.github.io/images/简单的高可用模式.jpg\\",\\"https://weiqiangxu.github.io/images/远程写模式主从.png\\",\\"https://weiqiangxu.github.io/images/联邦模式的主从.png\\",\\"https://weiqiangxu.github.io/images/基于etcd的主从实现.png\\"],\\"datePublished\\":\\"2023-04-08T06:40:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"一、应用场景","slug":"一、应用场景","link":"#一、应用场景","children":[]},{"level":3,"title":"二、需求","slug":"二、需求","link":"#二、需求","children":[]},{"level":3,"title":"三、目标","slug":"三、目标","link":"#三、目标","children":[]},{"level":3,"title":"四、数据同步方案","slug":"四、数据同步方案","link":"#四、数据同步方案","children":[]},{"level":3,"title":"五、选主和配置热重载","slug":"五、选主和配置热重载","link":"#五、选主和配置热重载","children":[]},{"level":3,"title":"六、相关疑问","slug":"六、相关疑问","link":"#六、相关疑问","children":[]},{"level":3,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"readingTime":{"minutes":13.72,"words":4117},"filePathRelative":"posts/prometheus/prometheus高可用方案预研.md","localizedDate":"2023年4月8日","excerpt":"<h3>一、应用场景</h3>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>HCI超融合的监控，我们的应用程序将会和主机一起打包销售，给到客户的时候启动主机，这个主机有可能是1台也有可能是3台。</span></span>\\n<span class=\\"line\\"><span>那么主机启动之后，监控服务随之启动;</span></span>\\n<span class=\\"line\\"><span>业务会暴露指标给prometheus采集</span></span>\\n<span class=\\"line\\"><span>这里的prometheus如果有1台主机那么就只有1个监控服务，如果有3台主机那么就会有3个监控服务，</span></span>\\n<span class=\\"line\\"><span>这3台机器上面的3个prometheus的实例各自的存储是独立的。</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);