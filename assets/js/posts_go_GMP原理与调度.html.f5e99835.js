"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2257],{6262:(e,a)=>{a.A=(e,a)=>{const i=e.__vccOpts||e;for(const[e,n]of a)i[e]=n;return i}},2405:(e,a,i)=>{i.r(a),i.d(a,{comp:()=>l,data:()=>o});var n=i(641);const t={},l=(0,i(6262).A)(t,[["render",function(e,a){return(0,n.uX)(),(0,n.CE)("div",null,a[0]||(a[0]=[(0,n.Fv)('<h1 id="gmp-原理与调度" tabindex="-1"><a class="header-anchor" href="#gmp-原理与调度"><span>GMP 原理与调度</span></a></h1><p><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" target="_blank" rel="noopener noreferrer">GMP 原理与调度</a></p><ol><li>M (thread) G (goroutine) P (Processor)</li><li>P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量）</li><li>每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量）</li></ol><h3 id="m和p的数量没有绝对关系-启动以后p是固定的而m是动态的" tabindex="-1"><a class="header-anchor" href="#m和p的数量没有绝对关系-启动以后p是固定的而m是动态的"><span>M和P的数量没有绝对关系，启动以后P是固定的而M是动态的</span></a></h3><blockquote><p>M被阻塞的时候，P会创建或者切换到另一个M</p></blockquote><h3 id="一些简单的问题-work-stealing-hand-off" tabindex="-1"><a class="header-anchor" href="#一些简单的问题-work-stealing-hand-off"><span>一些简单的问题 work stealing &amp;&amp; hand off</span></a></h3><ol><li>M关联的P无G消费的时候，是不是就会一直空闲在那里 （全局队列G和其他P的G都会被偷取）</li><li>G阻塞的时候，P会转移给其他空闲的M</li></ol><h3 id="在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度" tabindex="-1"><a class="header-anchor" href="#在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度"><span>在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死 - 抢占式调度</span></a></h3><h3 id="调度器的生命周期" tabindex="-1"><a class="header-anchor" href="#调度器的生命周期"><span>调度器的生命周期</span></a></h3><ol><li>创建P\\G\\M</li><li>运行M</li><li>M和P绑定</li><li>M通过P获取到G进行消费 （M肯定通过P呀、P是M的本地队列呀）</li><li>M获取不到G的时候休眠</li><li>P绑定M的时候唤醒</li></ol><p>main.main &gt; runtime.main -&gt; runtime.exit or runtime.main finish</p><h3 id="可视化gmp编程" tabindex="-1"><a class="header-anchor" href="#可视化gmp编程"><span>可视化GMP编程</span></a></h3><ol><li>go tool trace</li><li>debug trace</li></ol><h3 id="线程自旋-系统中最多有-gomaxprocs-个自旋的线程" tabindex="-1"><a class="header-anchor" href="#线程自旋-系统中最多有-gomaxprocs-个自旋的线程"><span>线程自旋：系统中最多有 GOMAXPROCS 个自旋的线程</span></a></h3><h3 id="goroutine的状态有多少个" tabindex="-1"><a class="header-anchor" href="#goroutine的状态有多少个"><span>goroutine的状态有多少个</span></a></h3><h3 id="gmp相关调优" tabindex="-1"><a class="header-anchor" href="#gmp相关调优"><span>GMP相关调优</span></a></h3><ol><li>GOMAXPROCS配置 决定P的数量也就是 能够并行执行的goroutine的最大数量</li></ol><h3 id="已经被废弃的gm-和-最新的gpm-的对比" tabindex="-1"><a class="header-anchor" href="#已经被废弃的gm-和-最新的gpm-的对比"><span>已经被废弃的GM 和 最新的GPM 的对比</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>本质上就是增加了 &quot;M 的本地队列&quot;</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>如果M获取每一个G都要去全局队列获取，和其他M抢夺G，就需要大量的加锁解锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列" tabindex="-1"><a class="header-anchor" href="#本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列"><span>本质上就是增加了 M 的本地队列 、 本质上就是增加了 M 的本地队列、本质上就是增加了 M 的本地队列</span></a></h3><h3 id="m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的" tabindex="-1"><a class="header-anchor" href="#m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的"><span>M 的 P 里面的G可以是 全局队列拿的，也可以是其他 P 的本地队列拿的</span></a></h3><blockquote><p>每个 M 都代表了 1 个内核线程，OS 调度器负责把内核线程分配到 CPU 的核上执行</p></blockquote><h3 id="关于数量" tabindex="-1"><a class="header-anchor" href="#关于数量"><span>关于数量</span></a></h3><ol><li>M是动态的不够用的时候就会创建 （随时创建） 只能限定最大数量</li><li>P是固定数量的 GOMAXPROCS配置 （启动时候就创建）</li></ol><h3 id="m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p" tabindex="-1"><a class="header-anchor" href="#m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p"><span>M 执行 G 的时候发生阻塞，那么 M 会失去原有的 P（摘除），然后创建新的 M 服务这个 P</span></a></h3><p><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></p>',26)]))}]]),o=JSON.parse('{"path":"/posts/go/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html","title":"GMP 原理与调度","lang":"zh-CN","frontmatter":{"hide":true,"description":"GMP 原理与调度 GMP 原理与调度 M (thread) G (goroutine) P (Processor) P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量） 每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量） M和P的数...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"GMP 原理与调度"}],["meta",{"property":"og:description","content":"GMP 原理与调度 GMP 原理与调度 M (thread) G (goroutine) P (Processor) P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量） 每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量） M和P的数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP 原理与调度\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"M和P的数量没有绝对关系，启动以后P是固定的而M是动态的","slug":"m和p的数量没有绝对关系-启动以后p是固定的而m是动态的","link":"#m和p的数量没有绝对关系-启动以后p是固定的而m是动态的","children":[]},{"level":3,"title":"一些简单的问题 work stealing && hand off","slug":"一些简单的问题-work-stealing-hand-off","link":"#一些简单的问题-work-stealing-hand-off","children":[]},{"level":3,"title":"在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死 - 抢占式调度","slug":"在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度","link":"#在go中-一个goroutine最多占用cpu-10ms-防止其他goroutine被饿死-抢占式调度","children":[]},{"level":3,"title":"调度器的生命周期","slug":"调度器的生命周期","link":"#调度器的生命周期","children":[]},{"level":3,"title":"可视化GMP编程","slug":"可视化gmp编程","link":"#可视化gmp编程","children":[]},{"level":3,"title":"线程自旋：系统中最多有 GOMAXPROCS 个自旋的线程","slug":"线程自旋-系统中最多有-gomaxprocs-个自旋的线程","link":"#线程自旋-系统中最多有-gomaxprocs-个自旋的线程","children":[]},{"level":3,"title":"goroutine的状态有多少个","slug":"goroutine的状态有多少个","link":"#goroutine的状态有多少个","children":[]},{"level":3,"title":"GMP相关调优","slug":"gmp相关调优","link":"#gmp相关调优","children":[]},{"level":3,"title":"已经被废弃的GM 和 最新的GPM 的对比","slug":"已经被废弃的gm-和-最新的gpm-的对比","link":"#已经被废弃的gm-和-最新的gpm-的对比","children":[]},{"level":3,"title":"本质上就是增加了 M 的本地队列 、 本质上就是增加了 M 的本地队列、本质上就是增加了 M 的本地队列","slug":"本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列","link":"#本质上就是增加了-m-的本地队列-、-本质上就是增加了-m-的本地队列、本质上就是增加了-m-的本地队列","children":[]},{"level":3,"title":"M 的 P 里面的G可以是 全局队列拿的，也可以是其他 P 的本地队列拿的","slug":"m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的","link":"#m-的-p-里面的g可以是-全局队列拿的-也可以是其他-p-的本地队列拿的","children":[]},{"level":3,"title":"关于数量","slug":"关于数量","link":"#关于数量","children":[]},{"level":3,"title":"M 执行 G 的时候发生阻塞，那么 M 会失去原有的 P（摘除），然后创建新的 M 服务这个 P","slug":"m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p","link":"#m-执行-g-的时候发生阻塞-那么-m-会失去原有的-p-摘除-然后创建新的-m-服务这个-p","children":[]}],"readingTime":{"minutes":2.22,"words":666},"filePathRelative":"posts/go/GMP原理与调度.md","excerpt":"\\n<p><a href=\\"https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">GMP 原理与调度</a></p>\\n<ol>\\n<li>M (thread)  G (goroutine) P (Processor)</li>\\n<li>P在启动时创建，保存在数组之中，数量是GOMAXPROCS （决定同时执行的goroutine的最大数量）</li>\\n<li>每个M代表1个内核线程 （runtime/debug 中的 SetMaxThreads 函数，设置 M 的最大数量）</li>\\n</ol>","autoDesc":true}')}}]);