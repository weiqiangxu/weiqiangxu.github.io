"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8310],{6262:(n,e)=>{e.A=(n,e)=>{const l=n.__vccOpts||n;for(const[n,i]of e)l[n]=i;return l}},6086:(n,e,l)=>{l.r(e),l.d(e,{comp:()=>s,data:()=>t});var i=l(641);const a={},s=(0,l(6262).A)(a,[["render",function(n,e){return(0,i.uX)(),(0,i.CE)("div",null,e[0]||(e[0]=[(0,i.Fv)('<h3 id="channel的特性" tabindex="-1"><a class="header-anchor" href="#channel的特性"><span>channel的特性</span></a></h3><ol><li>分配在堆上</li><li>管道的数据结构是 hchan</li><li>缓冲区就是数组</li><li>两个队列（发送、接收）</li><li>关闭状态</li><li>缓冲区buffer之中有sendx发送队列偏移和recevx接收偏移 - 环形缓冲区</li></ol><h3 id="channel发送过程做了什么" tabindex="-1"><a class="header-anchor" href="#channel发送过程做了什么"><span>channel发送过程做了什么</span></a></h3><ol><li>有没有goroutine在接收数据</li><li>如果缓冲区已经满了，继续发送数据到channel的话会进入发送等待队列 sendq</li><li>发送等待队列sendq (底层是sudog数据结构链表)</li><li>sudog数据结构链表（记录拿个协程在等待、等待哪个channel）</li><li>g2接受 ch1 的数据，此时缓冲区就空余出1个</li><li>唤醒发送队列 ch1 的 sendq 之中的 g1 , g1 此时将数据发送给 ch1</li></ol><blockquote><p>缓冲区有空余或者有gorotine在接收channel数据的时候才不会发生阻塞</p></blockquote><h3 id="多路select" tabindex="-1"><a class="header-anchor" href="#多路select"><span>多路select</span></a></h3><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>select 监听多个chanel </span></span>\n<span class="line"><span>被编译器编译为 runtime.selectgo</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1. 按序加锁</span></span>\n<span class="line"><span>2. 乱序轮询</span></span>\n<span class="line"><span>3. 挂起等待</span></span>\n<span class="line"><span>4. 按序解锁</span></span>\n<span class="line"><span>5. 唤醒执行</span></span>\n<span class="line"><span>6. 按序加锁</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="底层原理" tabindex="-1"><a class="header-anchor" href="#底层原理"><span>底层原理</span></a></h3><ol><li>环形缓冲区</li><li>等待队列</li><li>阻塞与非阻塞式操作</li><li>多路select</li><li>channel的send被编译器转换为runtime.chansend1()函数调用</li></ol><h3 id="数据结构" tabindex="-1"><a class="header-anchor" href="#数据结构"><span>数据结构</span></a></h3><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>hchan 数据结构</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>1. &quot;环形&quot;缓冲区 (实际上是一个数组)</span></span>\n<span class="line"><span>2. 锁</span></span>\n<span class="line"><span>3. 发送和接受的下标(sendx recvx)</span></span>\n<span class="line"><span>4. goroutine阻塞在发送或者接收时候，会有发送队列和接受队列记录</span></span>\n<span class="line"><span>5. 元素类型、大小、是否关闭</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">Golang合集</a></p>',12)]))}]]),t=JSON.parse('{"path":"/posts/go/Channel.html","title":"Channel","lang":"zh-CN","frontmatter":{"title":"Channel","tags":["GO原理"],"categories":["go"],"date":"2023-04-08T06:40:12.000Z","index_img":"/images/bg/computer.jpeg","hide":true,"description":"channel的特性 分配在堆上 管道的数据结构是 hchan 缓冲区就是数组 两个队列（发送、接收） 关闭状态 缓冲区buffer之中有sendx发送队列偏移和recevx接收偏移 - 环形缓冲区 channel发送过程做了什么 有没有goroutine在接收数据 如果缓冲区已经满了，继续发送数据到channel的话会进入发送等待队列 sendq 发...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/Channel.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"Channel"}],["meta",{"property":"og:description","content":"channel的特性 分配在堆上 管道的数据结构是 hchan 缓冲区就是数组 两个队列（发送、接收） 关闭状态 缓冲区buffer之中有sendx发送队列偏移和recevx接收偏移 - 环形缓冲区 channel发送过程做了什么 有没有goroutine在接收数据 如果缓冲区已经满了，继续发送数据到channel的话会进入发送等待队列 sendq 发..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"GO原理"}],["meta",{"property":"article:published_time","content":"2023-04-08T06:40:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Channel\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-08T06:40:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"channel的特性","slug":"channel的特性","link":"#channel的特性","children":[]},{"level":3,"title":"channel发送过程做了什么","slug":"channel发送过程做了什么","link":"#channel发送过程做了什么","children":[]},{"level":3,"title":"多路select","slug":"多路select","link":"#多路select","children":[]},{"level":3,"title":"底层原理","slug":"底层原理","link":"#底层原理","children":[]},{"level":3,"title":"数据结构","slug":"数据结构","link":"#数据结构","children":[]}],"readingTime":{"minutes":1.39,"words":417},"filePathRelative":"posts/go/Channel.md","localizedDate":"2023年4月8日","excerpt":"<h3>channel的特性</h3>\\n<ol>\\n<li>分配在堆上</li>\\n<li>管道的数据结构是 hchan</li>\\n<li>缓冲区就是数组</li>\\n<li>两个队列（发送、接收）</li>\\n<li>关闭状态</li>\\n<li>缓冲区buffer之中有sendx发送队列偏移和recevx接收偏移 - 环形缓冲区</li>\\n</ol>\\n<h3>channel发送过程做了什么</h3>\\n<ol>\\n<li>有没有goroutine在接收数据</li>\\n<li>如果缓冲区已经满了，继续发送数据到channel的话会进入发送等待队列 sendq</li>\\n<li>发送等待队列sendq (底层是sudog数据结构链表)</li>\\n<li>sudog数据结构链表（记录拿个协程在等待、等待哪个channel）</li>\\n<li>g2接受 ch1 的数据，此时缓冲区就空余出1个</li>\\n<li>唤醒发送队列 ch1 的 sendq 之中的 g1 , g1 此时将数据发送给 ch1</li>\\n</ol>","autoDesc":true}')}}]);