"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6209],{6262:(e,s)=>{s.A=(e,s)=>{const i=e.__vccOpts||e;for(const[e,a]of s)i[e]=a;return i}},8130:(e,s,i)=>{i.r(s),i.d(s,{comp:()=>l,data:()=>d});var a=i(641);const n={},l=(0,i(6262).A)(n,[["render",function(e,s){return(0,a.uX)(),(0,a.CE)("div",null,s[0]||(s[0]=[(0,a.Fv)('<h1 id="redis事务" tabindex="-1"><a class="header-anchor" href="#redis事务"><span>Redis事务</span></a></h1><h3 id="事务是批量执行脚本-redis语句是原子性的-事物不可分割-要么都发生要么都不发生" tabindex="-1"><a class="header-anchor" href="#事务是批量执行脚本-redis语句是原子性的-事物不可分割-要么都发生要么都不发生"><span>事务是批量执行脚本，Redis语句是原子性的(事物不可分割，要么都发生要么都不发生)</span></a></h3><h3 id="redis事务不会因为批量脚本之中的某一个执行失败而回滚-也不会造成后续的指令不执行" tabindex="-1"><a class="header-anchor" href="#redis事务不会因为批量脚本之中的某一个执行失败而回滚-也不会造成后续的指令不执行"><span>Redis事务不会因为批量脚本之中的某一个执行失败而回滚，也不会造成后续的指令不执行</span></a></h3><h3 id="常用指令" tabindex="-1"><a class="header-anchor" href="#常用指令"><span>常用指令</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>MULTI</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>EXEC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>DISCARD</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>UNWATCH</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>WATCH</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="所以watch怎么用-监控事务" tabindex="-1"><a class="header-anchor" href="#所以watch怎么用-监控事务"><span>所以Watch怎么用，监控事务</span></a></h3><p><a href="http://c.biancheng.net/view/4544.html" target="_blank" rel="noopener noreferrer">这篇文章写得不错</a></p><p>该机制参考了 CAS（比较与交换，Compare And Swap）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>WATCH mykey</span></span>\n<span class="line"><span>val = GET mykey</span></span>\n<span class="line"><span>val = val+1</span></span>\n<span class="line"><span>MULTI</span></span>\n<span class="line"><span>SET mykey val</span></span>\n<span class="line"><span>EXEC [这里会检测WATCH开始mykey的值有没有被其他命令修改过，如果没有，才会执行]</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在 WATCH 到 EXEC 之间，如果mykey更改了，那么这个EXEC命令将执行失败 从而保证了这个事务的从 GET -&gt; INCR 这几步多个事务之间的串行化</p><h3 id="什么叫做cas的aba问题" tabindex="-1"><a class="header-anchor" href="#什么叫做cas的aba问题"><span>什么叫做CAS的ABA问题</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>CAS是比较一个变量值在2个时间点是否一致判定该变量是否有被其他线程修改过</span></span>\n<span class="line"><span>当其他线程将变量值从A改成B再改回来为A，那么CAS仍然是错误地认为这个变量是没有被修改过的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>',13)]))}]]),d=JSON.parse('{"path":"/posts/redis/Redis%E4%BA%8B%E5%8A%A1.html","title":"Redis事务","lang":"zh-CN","frontmatter":{"hide":true,"description":"Redis事务 事务是批量执行脚本，Redis语句是原子性的(事物不可分割，要么都发生要么都不发生) Redis事务不会因为批量脚本之中的某一个执行失败而回滚，也不会造成后续的指令不执行 常用指令 所以Watch怎么用，监控事务 这篇文章写得不错 该机制参考了 CAS（比较与交换，Compare And Swap） 在 WATCH 到 EXEC 之间，...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/redis/Redis%E4%BA%8B%E5%8A%A1.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"Redis事务"}],["meta",{"property":"og:description","content":"Redis事务 事务是批量执行脚本，Redis语句是原子性的(事物不可分割，要么都发生要么都不发生) Redis事务不会因为批量脚本之中的某一个执行失败而回滚，也不会造成后续的指令不执行 常用指令 所以Watch怎么用，监控事务 这篇文章写得不错 该机制参考了 CAS（比较与交换，Compare And Swap） 在 WATCH 到 EXEC 之间，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis事务\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"事务是批量执行脚本，Redis语句是原子性的(事物不可分割，要么都发生要么都不发生)","slug":"事务是批量执行脚本-redis语句是原子性的-事物不可分割-要么都发生要么都不发生","link":"#事务是批量执行脚本-redis语句是原子性的-事物不可分割-要么都发生要么都不发生","children":[]},{"level":3,"title":"Redis事务不会因为批量脚本之中的某一个执行失败而回滚，也不会造成后续的指令不执行","slug":"redis事务不会因为批量脚本之中的某一个执行失败而回滚-也不会造成后续的指令不执行","link":"#redis事务不会因为批量脚本之中的某一个执行失败而回滚-也不会造成后续的指令不执行","children":[]},{"level":3,"title":"常用指令","slug":"常用指令","link":"#常用指令","children":[]},{"level":3,"title":"所以Watch怎么用，监控事务","slug":"所以watch怎么用-监控事务","link":"#所以watch怎么用-监控事务","children":[]},{"level":3,"title":"什么叫做CAS的ABA问题","slug":"什么叫做cas的aba问题","link":"#什么叫做cas的aba问题","children":[]}],"readingTime":{"minutes":1,"words":300},"filePathRelative":"posts/redis/Redis事务.md","excerpt":"\\n<h3>事务是批量执行脚本，Redis语句是原子性的(事物不可分割，要么都发生要么都不发生)</h3>\\n<h3>Redis事务不会因为批量脚本之中的某一个执行失败而回滚，也不会造成后续的指令不执行</h3>\\n<h3>常用指令</h3>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>MULTI</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>EXEC</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);