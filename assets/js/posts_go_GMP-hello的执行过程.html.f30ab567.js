"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2763],{6262:(e,n)=>{n.A=(e,n)=>{const i=e.__vccOpts||e;for(const[e,a]of n)i[e]=a;return i}},6201:(e,n,i)=>{i.r(n),i.d(n,{comp:()=>l,data:()=>s});var a=i(641);const t={},l=(0,i(6262).A)(t,[["render",function(e,n){return(0,a.uX)(),(0,a.CE)("div",null,n[0]||(n[0]=[(0,a.Fv)('<h3 id="关键术语" tabindex="-1"><a class="header-anchor" href="#关键术语"><span>关键术语</span></a></h3><ol><li>进程虚拟地址空间中的代码段</li><li>程序执行入口 runtime.main 创建 main.goroutine （call main.main）</li><li>协程对应的数据结构是runtime.g，工作线程对应的数据结构是runtime.m，处理器P对应的数据结构是 runtime.p (本地runq)</li><li>全局runq 存储在 全局变量 sched （调度器，对应的数据结构是 runtime.schedt）</li><li>P程序初始化过程之中进行调度器初始化，初始化固定数量的 P (GOMAXPROCS)</li><li>start函数开启调度循环schedule()函数</li><li>time.sleep 调用 gopark函数</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>协程的状态从 _Grunning修改为_Gwaiting </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>(main.goroutine就不会因为执行完成回到P之中而是timer之中等待) </span></span>\n<span class="line"><span>然后使用 schedule() 调度执行其他的goroutine</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>时间到了以后 _Grunnable 状态然后G被访问P的runq之中，main.main结束</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>M 可以去 P 获取 G，所以不用再去全局队列和其他M争抢G了 全局变量 sched 调度器记录所有空闲的m 和空闲的p 等 以及全局 runq M 优先从关联的 P 获取 G，没有的话去全局变量 sched 调度器的全局runq领取 G ， 如果调度器也没有那么从别的 P 的runq 获取G</p></blockquote><h3 id="协程创建后会加入-p-的本地队列runq之中" tabindex="-1"><a class="header-anchor" href="#协程创建后会加入-p-的本地队列runq之中"><span>协程创建后会加入 P 的本地队列runq之中</span></a></h3><h3 id="main-main运行结束以后runtime-main会调用exit函数结束进程" tabindex="-1"><a class="header-anchor" href="#main-main运行结束以后runtime-main会调用exit函数结束进程"><span>main.main运行结束以后runtime.main会调用exit函数结束进程</span></a></h3><p><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">Golang合集</a></p>',7)]))}]]),s=JSON.parse('{"path":"/posts/go/GMP-hello%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.html","title":"GMP-hello的执行过程","lang":"zh-CN","frontmatter":{"title":"GMP-hello的执行过程","tags":["GO原理"],"categories":["go"],"date":"2023-04-08T06:40:12.000Z","index_img":"/images/bg/computer.jpeg","hide":true,"description":"关键术语 进程虚拟地址空间中的代码段 程序执行入口 runtime.main 创建 main.goroutine （call main.main） 协程对应的数据结构是runtime.g，工作线程对应的数据结构是runtime.m，处理器P对应的数据结构是 runtime.p (本地runq) 全局runq 存储在 全局变量 sched （调度器，对应...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/GMP-hello%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"GMP-hello的执行过程"}],["meta",{"property":"og:description","content":"关键术语 进程虚拟地址空间中的代码段 程序执行入口 runtime.main 创建 main.goroutine （call main.main） 协程对应的数据结构是runtime.g，工作线程对应的数据结构是runtime.m，处理器P对应的数据结构是 runtime.p (本地runq) 全局runq 存储在 全局变量 sched （调度器，对应..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"GO原理"}],["meta",{"property":"article:published_time","content":"2023-04-08T06:40:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP-hello的执行过程\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2023-04-08T06:40:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"关键术语","slug":"关键术语","link":"#关键术语","children":[]},{"level":3,"title":"协程创建后会加入 P 的本地队列runq之中","slug":"协程创建后会加入-p-的本地队列runq之中","link":"#协程创建后会加入-p-的本地队列runq之中","children":[]},{"level":3,"title":"main.main运行结束以后runtime.main会调用exit函数结束进程","slug":"main-main运行结束以后runtime-main会调用exit函数结束进程","link":"#main-main运行结束以后runtime-main会调用exit函数结束进程","children":[]}],"readingTime":{"minutes":1.27,"words":382},"filePathRelative":"posts/go/GMP-hello的执行过程.md","localizedDate":"2023年4月8日","excerpt":"<h3>关键术语</h3>\\n<ol>\\n<li>进程虚拟地址空间中的代码段</li>\\n<li>程序执行入口 runtime.main 创建 main.goroutine （call main.main）</li>\\n<li>协程对应的数据结构是runtime.g，工作线程对应的数据结构是runtime.m，处理器P对应的数据结构是 runtime.p (本地runq)</li>\\n<li>全局runq 存储在 全局变量 sched （调度器，对应的数据结构是 runtime.schedt）</li>\\n<li>P程序初始化过程之中进行调度器初始化，初始化固定数量的 P (GOMAXPROCS)</li>\\n<li>start函数开启调度循环schedule()函数</li>\\n<li>time.sleep 调用 gopark函数</li>\\n</ol>","autoDesc":true}')}}]);