"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[819],{6262:(s,n)=>{n.A=(s,n)=>{const a=s.__vccOpts||s;for(const[s,e]of n)a[s]=e;return a}},5120:(s,n,a)=>{a.r(n),a.d(n,{comp:()=>l,data:()=>p});var e=a(641);const i={},l=(0,a(6262).A)(i,[["render",function(s,n){return(0,e.uX)(),(0,e.CE)("div",null,n[0]||(n[0]=[(0,e.Fv)('<h3 id="redis入门指南" tabindex="-1"><a class="header-anchor" href="#redis入门指南"><span>Redis入门指南</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>9 种数据类型</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>BitMap 二值状态统计的场景</span></span>\n<span class="line"><span>Stream 消息队列</span></span>\n<span class="line"><span>HyperLogLog 海量数据基数统计的场景</span></span>\n<span class="line"><span>GEO 地理位置信息</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>HSET key field value</span></span>\n<span class="line"><span>KEYS</span></span>\n<span class="line"><span>LPUSH LPOP</span></span>\n<span class="line"><span>RPUSH RPOP</span></span>\n<span class="line"><span>LLEN KEY</span></span>\n<span class="line"><span>SADD KEY member</span></span>\n<span class="line"><span>SREM KEY member</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>ZADD KEY [score member]...</span></span>\n<span class="line"><span>ZADD studend 89 tom 98 jack 76 rose</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>MULTI</span></span>\n<span class="line"><span>...</span></span>\n<span class="line"><span>EXEC</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 (CAS)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>EXPIRE</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>SORT</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>SORT key ALPHA [字典排序]</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>SORT key DESC</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>单线程的 Redis QPS 可以达到 10W/每秒</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>脑裂：多个主节点的现象</span></span>\n<span class="line"><span>（主节点没有问题但是哨兵发现主节点无法连通将从节点选举为主节点的时候）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>被降格为从节点的旧主节点</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>由于第一次同步是全量同步的方式，此时的从节点（A）会清空掉自己本地的数据，然后再做全量同步</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>脑裂导致数据丢失，本质上是旧主节点降格为从节点之后，被清空数据再同步新主节点导致</p></blockquote><h3 id="脑裂解决方案" tabindex="-1"><a class="header-anchor" href="#脑裂解决方案"><span>脑裂解决方案</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>从节点下线时，禁止主节点写数据，直接返回error给客户端</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>min-slaves-to-write x：主节点必须要有至少 x 个从节点连接，如果小于，主节点禁止写数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>min-slaves-max-lag x，主从数据复制和同步的延迟不能超过 x 秒</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>避免原主库是假故障（哨兵认为故障，客户端认为非故障继续写数据，导致客户端写的数据丢失）</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="过期删除策略" tabindex="-1"><a class="header-anchor" href="#过期删除策略"><span>过期删除策略</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>过期字典</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>惰性删除: 访问key后发现已经过期就删除</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>定期删除：定时随机取出一定数量的key检查并删除其中过期的部分，如果比例超出25%则会再次执行检查</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意： 过期删除策略和内存淘汰策略不是同一个东西</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>从库不会进行过期扫描，从库对过期的处理是被动的</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Redis 内存满了，会出发内存淘汰机制、</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="内存淘汰算法" tabindex="-1"><a class="header-anchor" href="#内存淘汰算法"><span>内存淘汰算法</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>LRU 全称是 Least Recently Used 翻译为最近最少使用，选择淘汰最近最少使用的数据</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>(随机采样的方式来淘汰数据，默认随机5个淘汰最久没有使用的那个)</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>LFU 全称是 Least Frequently Used 翻译为最近最不常用的，依据数据访问次数来淘汰数据</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="缓存设计" tabindex="-1"><a class="header-anchor" href="#缓存设计"><span>缓存设计</span></a></h3><ol><li>缓存雪崩 - 大量缓存同时过期（解决方案：将缓存失效时间随机打散、设置不过期）</li><li>缓存击穿 - 热点数据过期（业务请求加锁、不给热点数据设置过期时间而是后台主动更新缓存）</li><li>缓存穿透 - 数据库没有数据，缓存中也没法构建数据（非法请求限制、构建默认值）</li></ol><p><a href="https://www.cnblogs.com/cpselvis/p/6265825.html" target="_blank" rel="noopener noreferrer">布隆过滤器(Bloom Filter)的原理和实现</a></p><p><a href="https://learnku.com/articles/63352" target="_blank" rel="noopener noreferrer">布隆过滤器原理与实现 - golang</a></p><blockquote><p>一个很长的二进制向量和一系列随机映射函数，用于检索一个元素是否在一个集合中</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>它的优点是空间效率和查询时间都远远超过一般的算法</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="redis的zset-加-zrangebysocre-实现延迟队列" tabindex="-1"><a class="header-anchor" href="#redis的zset-加-zrangebysocre-实现延迟队列"><span>Redis的ZSet 加 zrangebysocre 实现延迟队列</span></a></h3><h3 id="redis-的大-key-如何处理" tabindex="-1"><a class="header-anchor" href="#redis-的大-key-如何处理"><span>Redis 的大 key 如何处理？</span></a></h3><ol><li>客户端超时阻塞</li><li>网络阻塞</li><li>del大key会阻塞工作线程</li><li>内存分配不均（集群slot分配均匀的情况下）</li></ol><blockquote><p>String 类型的值大于 10 KB \\ Hash、List、Set、ZSet 类型的元素的个数超过 5000个 通常叫做大Key</p></blockquote><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>### 自带命令发现大key（集合只知道个数而不是实际内存量）</span></span>\n<span class="line"><span>redis-cli --bigkeys</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### 查看具体大小</span></span>\n<span class="line"><span>MEMORY USAGE keyname1</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### 字符串</span></span>\n<span class="line"><span>STRLEN</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### 列表List</span></span>\n<span class="line"><span>LLEN</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### hash哈希</span></span>\n<span class="line"><span>HLEN</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### Set类型</span></span>\n<span class="line"><span>SCARD </span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### Sorted Set类型</span></span>\n<span class="line"><span>ZCARD</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>### 第三方工具使用 RdbTools 工具查找大 key</span></span>\n<span class="line"><span>redis-rdb-tools</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="redis管道技术-pipeline-是客户端提供的一种批处理技术-用于一次处理多个-redis-命令-提高交互性能" tabindex="-1"><a class="header-anchor" href="#redis管道技术-pipeline-是客户端提供的一种批处理技术-用于一次处理多个-redis-命令-提高交互性能"><span>Redis管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，提高交互性能</span></a></h3><h3 id="redis是不支持事务回滚的-需要程序员手动回滚" tabindex="-1"><a class="header-anchor" href="#redis是不支持事务回滚的-需要程序员手动回滚"><span>Redis是不支持事务回滚的，需要程序员手动回滚</span></a></h3><h3 id="redis分布式锁-setnx-key-name-value" tabindex="-1"><a class="header-anchor" href="#redis分布式锁-setnx-key-name-value"><span>Redis分布式锁 SETNX KEY_NAME VALUE</span></a></h3><ol><li>锁超时时间，守护进程自旋，无法限制业务执行时长</li><li>redis集群模式下同步延迟（Redlock）</li></ol><h3 id="redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗" tabindex="-1"><a class="header-anchor" href="#redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗"><span>redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗</span></a></h3><h3 id="redis分片集群模式" tabindex="-1"><a class="header-anchor" href="#redis分片集群模式"><span>redis分片集群模式</span></a></h3><h1 id="full-stack-knowledge-system" tabindex="-1"><a class="header-anchor" href="#full-stack-knowledge-system"><span>Full_stack_knowledge_system</span></a></h1><p><a href="https://pdai.tech/" target="_blank" rel="noopener noreferrer">pdai.tech</a></p>',32)]))}]]),p=JSON.parse('{"path":"/posts/redis/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html","title":"Full_stack_knowledge_system","lang":"zh-CN","frontmatter":{"hide":true,"description":"Redis入门指南 脑裂导致数据丢失，本质上是旧主节点降格为从节点之后，被清空数据再同步新主节点导致 脑裂解决方案 过期删除策略 注意： 过期删除策略和内存淘汰策略不是同一个东西 内存淘汰算法 缓存设计 缓存雪崩 - 大量缓存同时过期（解决方案：将缓存失效时间随机打散、设置不过期） 缓存击穿 - 热点数据过期（业务请求加锁、不给热点数据设置过期时间而是...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/redis/%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"Full_stack_knowledge_system"}],["meta",{"property":"og:description","content":"Redis入门指南 脑裂导致数据丢失，本质上是旧主节点降格为从节点之后，被清空数据再同步新主节点导致 脑裂解决方案 过期删除策略 注意： 过期删除策略和内存淘汰策略不是同一个东西 内存淘汰算法 缓存设计 缓存雪崩 - 大量缓存同时过期（解决方案：将缓存失效时间随机打散、设置不过期） 缓存击穿 - 热点数据过期（业务请求加锁、不给热点数据设置过期时间而是..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Full_stack_knowledge_system\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"Redis入门指南","slug":"redis入门指南","link":"#redis入门指南","children":[]},{"level":3,"title":"脑裂解决方案","slug":"脑裂解决方案","link":"#脑裂解决方案","children":[]},{"level":3,"title":"过期删除策略","slug":"过期删除策略","link":"#过期删除策略","children":[]},{"level":3,"title":"内存淘汰算法","slug":"内存淘汰算法","link":"#内存淘汰算法","children":[]},{"level":3,"title":"缓存设计","slug":"缓存设计","link":"#缓存设计","children":[]},{"level":3,"title":"Redis的ZSet 加 zrangebysocre 实现延迟队列","slug":"redis的zset-加-zrangebysocre-实现延迟队列","link":"#redis的zset-加-zrangebysocre-实现延迟队列","children":[]},{"level":3,"title":"Redis 的大 key 如何处理？","slug":"redis-的大-key-如何处理","link":"#redis-的大-key-如何处理","children":[]},{"level":3,"title":"Redis管道技术（Pipeline）是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，提高交互性能","slug":"redis管道技术-pipeline-是客户端提供的一种批处理技术-用于一次处理多个-redis-命令-提高交互性能","link":"#redis管道技术-pipeline-是客户端提供的一种批处理技术-用于一次处理多个-redis-命令-提高交互性能","children":[]},{"level":3,"title":"Redis是不支持事务回滚的，需要程序员手动回滚","slug":"redis是不支持事务回滚的-需要程序员手动回滚","link":"#redis是不支持事务回滚的-需要程序员手动回滚","children":[]},{"level":3,"title":"Redis分布式锁 SETNX KEY_NAME VALUE","slug":"redis分布式锁-setnx-key-name-value","link":"#redis分布式锁-setnx-key-name-value","children":[]},{"level":3,"title":"redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗","slug":"redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗","link":"#redis分片集群模式下还需要考虑同步延迟导致的分布式锁失效问题吗","children":[]},{"level":3,"title":"redis分片集群模式","slug":"redis分片集群模式","link":"#redis分片集群模式","children":[]}],"readingTime":{"minutes":4.15,"words":1244},"filePathRelative":"posts/redis/基础入门.md","excerpt":"<h3>Redis入门指南</h3>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>9 种数据类型</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>BitMap 二值状态统计的场景</span></span>\\n<span class=\\"line\\"><span>Stream 消息队列</span></span>\\n<span class=\\"line\\"><span>HyperLogLog 海量数据基数统计的场景</span></span>\\n<span class=\\"line\\"><span>GEO 地理位置信息</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>HSET key field value</span></span>\\n<span class=\\"line\\"><span>KEYS</span></span>\\n<span class=\\"line\\"><span>LPUSH LPOP</span></span>\\n<span class=\\"line\\"><span>RPUSH RPOP</span></span>\\n<span class=\\"line\\"><span>LLEN KEY</span></span>\\n<span class=\\"line\\"><span>SADD KEY member</span></span>\\n<span class=\\"line\\"><span>SREM KEY member</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>ZADD KEY [score member]...</span></span>\\n<span class=\\"line\\"><span>ZADD studend 89 tom 98 jack 76 rose</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>MULTI</span></span>\\n<span class=\\"line\\"><span>...</span></span>\\n<span class=\\"line\\"><span>EXEC</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>Redis的事务还能保证一个事务内的命令依次执行而不被其他命令插入</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>开发者必须在事务执行出错后自己收拾剩下的摊子（将数据库复原回事务执行前的状态等）</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>Watch 命令用于监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断 (CAS)</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>EXPIRE</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>SORT</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>SORT key ALPHA [字典排序]</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>SORT key DESC</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}')}}]);