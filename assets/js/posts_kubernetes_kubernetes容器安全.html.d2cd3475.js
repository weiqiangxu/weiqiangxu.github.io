"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7603],{6262:(e,i)=>{i.A=(e,i)=>{const a=e.__vccOpts||e;for(const[e,s]of i)a[e]=s;return a}},7849:(e,i,a)=>{a.r(i),a.d(i,{comp:()=>l,data:()=>t});var s=a(641);const n={},l=(0,a(6262).A)(n,[["render",function(e,i){return(0,s.uX)(),(0,s.CE)("div",null,i[0]||(i[0]=[(0,s.Fv)('<h3 id="课题" tabindex="-1"><a class="header-anchor" href="#课题"><span>课题</span></a></h3><ul><li>容器在k8s是什么</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">轻量级的虚拟化技术，可以打包应用程序及其依赖项，使其更易于部署和管理</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">k8s支持多种容器运行时（Container</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> Runtime），包括Docker、containerd、CRI-O等</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>容器运行时Container Runtime是什么意思</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>一种软件，其主要任务是负责在操作系统上启动和管理容器</span></span>\n<span class="line"><span>容器运行时通常通过调用操作系统提供的系统调用 - 来创建和管理容器</span></span>\n<span class="line"><span>一般和容器编排工具（例如Kubernetes）协同工作，实现容器的自动化部署、扩缩容等</span></span>\n<span class="line"><span>常见容器运行时有：Docker容器引擎、rkt、containerd等</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>Kubernetes中的容器可能会有哪些安全风险</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>1. 容器之间共享主机系统的资源,可能会通过共享文件或进程来获取其他容器中的敏感信息</span></span>\n<span class="line"><span>2. 容器的容量限制不够严格</span></span>\n<span class="line"><span>3. 容器镜像来源不可信</span></span>\n<span class="line"><span>4. 容器网络安全风险,比如需要访问外部网络或者其他容器</span></span>\n<span class="line"><span>5. 容器数据持久化缺少加密</span></span>\n<span class="line"><span>6. Kubernetes容器默认以高权限运行，容器内进程的文件系统和主机文件系统是共享的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>模拟docker的容器A非法访问容器B的资源</li><li>NetworkNamespace是在Linux内核中实现的一种机制，用于隔离网络资源，例如网络接口、路由表和iptables规则等</li><li>kata是什么</li><li>容器逻辑上分割，物理上的资源区隔的设计是什么样的</li><li>kubernetes的安全策略，如容器隔离、网络策略、RBAC设计是什么样的</li><li>iSula是什么</li><li>iSula+StratoVirt安全容器是什么</li><li>在容器执行top命令看到宿主机进程，为什么</li><li>containerd和docker什么关系，有架构图吗</li><li>runc、cri、运行时是什么</li><li>容器网络安全是怎么样的</li><li>k8s的设计的架构图</li><li>docker架构图</li><li>Istios是第二代Service Mesh的代表</li><li>Service Mesh服务网格是一种用于解决微服务架构中服务之间通信的问题的技术</li><li>namespace和cgroups标准是什么</li><li>OCI(Open Container Initiative)(开放容器计划)是什么涉及哪些内容</li><li>Kubernetes的CRI(Container Runtime Interface)的容器运行时接口是什么意思</li><li>shim的设计:作为适配器将自身容器运行时接口适配到 Kubernetes 的 CRI 接口(dockershim就是Kubernetes对接Docker到CRI接口)</li><li>CGroup是Control Groups限制\\记录\\隔离进程组所使用的物理资源</li><li>Name Space是什么</li><li>Busy Box是什么</li><li>k3s是什么</li><li>Kernel是什么</li><li>如何添加并使用docker的runtime和查看当前docker支持的runtime</li><li>docker使用kata runtime 抛出异常 cannot program address in sandbox interface because it conflicts with existing route</li><li>Qemu是什么</li><li>KVM是什么</li><li>KVM 要求 CPU 支持虚拟化扩展，例如 Intel VT 或 AMD-V。如果您的 CPU 不支持这些扩展，则无法使用 KVM</li><li>Kata Containers如何配置使用QEMU</li><li>Kata Runtime使用Firecracker</li><li>QEMU path (/usr/bin/qemu-kvm) does not exist</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> yum</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> install</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;"> -y</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> qemu</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li>Fedora 和 Centos 和 ky10.aarch64是什么关系</li><li>modprobe是干嘛的</li><li>docker run --runtime kata-runtime &amp;&amp; Could not access KVM kernel module</li><li>怎么判断cpu是否支持KVM</li><li>linux的命名空间是什么</li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">命名空间是Linux内核中的一个概念，它可以将不同的系统资源隔离开来，比如网络、进程空间等。</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">通过将容器连接到特定的网络命名空间中，可以实现容器与特定网络资源的隔离和互通</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>kata-containerd 和 kvm 是什么关系</p></li><li><p>kata-containerd 可以不依赖kvm吗</p></li><li><p>使用docker时候用的runtime是kata-runtime 但是不想依赖kvm怎么实现</p></li><li><p>kata containerd 怎么运行需要什么条件</p></li><li><p>KataContainers和Docker如何集成</p></li><li><p>kvm_intel是干嘛的</p></li><li><p>如何判断当前aarch64支持ARM Hyp</p></li><li><p>kata runtime可以不需要kvm吗，怎么实现</p></li><li><p>x86_64, amd64 Intel VT-x, AMD SVM 是什么意思</p></li><li><p>aarch64 (&quot;arm64&quot;) ARM Hyp 是什么意思</p></li><li><p>mac 怎么判断 arm64（aarch64）架构是否支持ARM Hypervisor</p></li></ul><div class="language-bash line-numbers-mode" data-highlighter="shiki" data-ext="bash" data-title="bash" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;"># 输出1表示支持虚拟化</span></span>\n<span class="line"><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;">$</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> sysctl</span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;"> kern.hv_support</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>kvm 和 ARM Hypervisor什么关系</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>KVM和ARM Hypervisor都是虚拟化技术，用于在处理器上创建虚拟化环境。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>KVM是用于x86架构的开源虚拟化解决方案，而ARM Hypervisor是用于ARM架构的虚拟化解决方案。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>在ARM架构中，ARM Hypervisor被用于虚拟化环境和资源，它允许多个操作系统同时运行在单个ARM处理器上，每个操作系统都在自己的虚拟机中运行。</span></span>\n<span class="line"><span>ARM Hypervisor通过使用虚拟地址空间映射等技术来隔离不同的虚拟机之间的资源，从而保证每个虚拟机的安全性和独立性。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>与此类似，KVM也是一种虚拟化解决方案，它可以在x86架构的处理器上运行多个虚拟机，并将物理资源映射到虚拟机中。</span></span>\n<span class="line"><span>KVM通过模拟多种硬件设备，如网络适配器和存储控制器等，为虚拟机提供与物理主机相同的环境，从而保证虚拟机的稳定性和性能。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>总之，KVM和ARM Hypervisor都是虚拟化技术，它们可以在不同的架构上将物理主机资源虚拟化为多个虚拟机，并支持多个操作系统同时运行。</span></span>\n<span class="line"><span>相比于x86架构，ARM Hypervisor在ARM架构上提供了更高效和安全的虚拟化环境。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>kvm 和 Intel VT-x, AMD SVM是什么关系</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Intel VT-x和AMD SVM是虚拟化技术的硬件支持，可以使操作系统在虚拟机中以更高效率的方式运行。</span></span>\n<span class="line"><span>kvm是一种基于虚拟化技术的虚拟机监视器，可以在支持Intel VT-x或AMD SVM的处理器上运行。</span></span>\n<span class="line"><span>kvm通过硬件虚拟化技术实现虚拟化，提供更高效的虚拟化性能。</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>因此，Intel VT-x和AMD SVM是支持kvm运行的基础。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>虚拟化研究中KVM和QEMU的区别</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span></span></span>\n<span class="line"><span>QEMU（Quick Emulator）是一个独立的开源虚拟机软件，纯软件的实现（处理器虚拟化、内存虚拟、虚拟设备模拟）</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>Qemu利用KVM提供的LibKvm应用程序接口，通过ioctl系统调用创建和运行虚拟机</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>QEMU在上层，KVM在下层</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>KVM(Kernel-based Virtual Machine)是基于虚拟化扩展（Intel VT或AMD-V）的X86硬件平台实现的Linux的全虚拟化解决方案</span></span>\n<span class="line"><span></span></span>\n<span class="line"><span>KVM是x86的东西</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>网桥是什么</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>网络设备，连接多个网络。</span></span>\n<span class="line"><span>转发不同网络之中的数据流。</span></span>\n<span class="line"><span>工作在OSI模型的第二层：数据链路层</span></span>\n<span class="line"><span>通过物理地址（MAC地址）识别网络设备来传递数据包</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>网段是什么</li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>网络地址范围 (表示方式：IP地址和子网掩码)；</span></span>\n<span class="line"><span>同一网段的设备可互相通信</span></span>\n<span class="line"><span>不同网段需要路由器等设备才可痛心</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>rootfs是什么</p></li><li><p>Guest Kernel是什么</p></li><li><p>Virtio是什么</p></li><li><p>阿里巴巴的ACK是什么意思</p></li></ul><div class="language-txt line-numbers-mode" data-highlighter="shiki" data-ext="txt" data-title="txt" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>阿里的ACK的全称是Alibaba Cloud ACK（Alibaba Cloud Container Service for Kubernetes）。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="课题方向" tabindex="-1"><a class="header-anchor" href="#课题方向"><span>课题方向</span></a></h3><ol><li>容器哪里不安全了</li><li>目前的解决方案是什么样的</li><li>解决方案的使用怎样可达到更好的效果</li><li>一些常见的兼容性、性能测试覆盖一下</li></ol><blockquote><p>Containerd 实现了 Kubernetes 容器运行时接口 (CRI) BuildKit 是一种开源工具，它从 Dockerfile 获取指令并“构建”Docker 映像 OCI (Open Container Initiative) 开放容器计划（容器规范的开放标准） CRI (Container Runtime Interface) 容器运行时接口，定义了 Kubernetes 与容器运行时之间的接口和协议 CRI-O 是实现了CRI和OCI，实现 OCI 和 CRI，等于是containerd</p></blockquote><h3 id="架构图" tabindex="-1"><a class="header-anchor" href="#架构图"><span>架构图</span></a></h3><p><img src="/images/什么是k8s的CRI-O.png" alt="什么是k8s的CRI-O" loading="lazy"><img src="/images/早期的k8s与docker.png" alt="早期的k8s与docker" loading="lazy"><img src="/images/containerd集成cri-containerd-shim后架构图.png" alt="containerd集成cri-containerd-shim后架构图" loading="lazy"><img src="/images/docker和containerd关系.png" alt="docker和containerd关系" loading="lazy"><img src="/images/docker依赖k8s标准.png" alt="docker依赖k8s标准" loading="lazy"><img src="/images/k8s-v1.20-24分离docker-shim.png" alt="k8s-v1.20-24分离docker-shim" loading="lazy"><img src="/images/k8s-v1.20之前内置docker-shim.png" alt="k8s-v1.20之前内置docker-shim" loading="lazy"><img src="/images/k8s-v1.24之后自行安装cri-dockerd.png" alt="k8s-v1.24之后自行安装cri-dockerd" loading="lazy"><img src="/images/k8s分离docker-shim.png" alt="k8s分离docker-shim" loading="lazy"><img src="/images/k8s与docker分离的初步计划.png" alt="k8s与docker分离的初步计划" loading="lazy"><img src="/images/kubelet和containerd简化调用链过程.png" alt="kubelet和containerd简化调用链过程" loading="lazy"><img src="/images/kubelet与容器运行时.png" alt="kubelet与容器运行时" loading="lazy"><img src="/images/k8s分离docker-shim.png" alt="kubelet与cri内部结构" loading="lazy"></p><h3 id="相关资料" tabindex="-1"><a class="header-anchor" href="#相关资料"><span>相关资料</span></a></h3><p><a href="https://github.com/containerd/containerd/blob/main/docs/getting-started.md" target="_blank" rel="noopener noreferrer">github.com/containerd</a><a href="https://zhuanlan.zhihu.com/p/61901608" target="_blank" rel="noopener noreferrer">zhihu/什么是 Service Mesh</a><a href="https://philcalcado.com/2017/08/03/pattern_service_mesh.html" target="_blank" rel="noopener noreferrer">PhilCalcado/Pattern: Service Mesh</a><a href="https://kubernetes.io/zh-cn/docs/setup/production-environment/container-runtimes/" target="_blank" rel="noopener noreferrer">官网运行时container-runtimes</a><a href="https://blog.csdn.net/m0_57776598/article/details/126963904" target="_blank" rel="noopener noreferrer">csdn剖析容器docker运行时-说的太细致了</a><a href="https://blog.csdn.net/yangyijun1990/article/details/108694011" target="_blank" rel="noopener noreferrer">csdn之IaaS/PaaS/SaaS/DaaS的区别-说的太好了</a><a href="https://zhuanlan.zhihu.com/p/279747954" target="_blank" rel="noopener noreferrer">知乎/container之runc</a><a href="https://zhuanlan.zhihu.com/p/122247284" target="_blank" rel="noopener noreferrer">从零开始入门 K8s | Kata Containers 创始人带你入门安全容器技术</a><a href="https://cloud.tencent.com/developer/article/1730700" target="_blank" rel="noopener noreferrer">如何在 Kubernetes 集群中集成 Kata</a><a href="https://www.dtstack.com/bbs/article/258" target="_blank" rel="noopener noreferrer">Docker，containerd，CRI，CRI-O，OCI，runc 分不清？看这一篇就够了 - 写的太好了</a><a href="https://www.huweihuang.com/kubernetes-notes/runtime/kata/kata-container.html" target="_blank" rel="noopener noreferrer">huweihuang/Kata-container简介</a><a href="https://blog.51cto.com/u_11979904/5676073" target="_blank" rel="noopener noreferrer">kata-containd和docker集成</a><a href="https://blog.51cto.com/u_11979904/5676073" target="_blank" rel="noopener noreferrer">如何给docker添加runtime支持</a><a href="https://www.cnblogs.com/fanqisoft/p/12096904.html" target="_blank" rel="noopener noreferrer">博客园-KataContainers和Docker的集成</a><a href="https://www.qemu.org/" target="_blank" rel="noopener noreferrer">https://www.qemu.org/</a><a href="https://github.com/kata-containers/runtime/issues/935" target="_blank" rel="noopener noreferrer">sandbox interface because it conflicts with existing route</a><a href="https://www.scholat.com/vpost.html?pid=7294" target="_blank" rel="noopener noreferrer">虚拟化研究中KVM和QEMU的区别-这个图画的很哇塞哦</a><a href="https://github.com/kubernetes/community/blob/master/contributors/devel/sig-node/container-runtime-interface.md" target="_blank" rel="noopener noreferrer">k8s官方讲解有多少种CRI</a><a href="https://blog.51cto.com/u_15682248/5806851" target="_blank" rel="noopener noreferrer">非常细致描述kata的优势</a></p><h3 id="gvisor和kata-containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点" tabindex="-1"><a class="header-anchor" href="#gvisor和kata-containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点"><span>gVisor和Kata Containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点：</span></a></h3><h4 id="gvisor的优点" tabindex="-1"><a class="header-anchor" href="#gvisor的优点"><span>gVisor的优点：</span></a></h4><ul><li>gVisor 使用了一个特殊的沙箱机制，可以提供更高的隔离性和安全性。</li><li>gVisor可以在Linux容器内运行，而无需对宿主机进行特殊设置。</li><li>gVisor的性能比Kata Containers更快。</li></ul><h4 id="gvisor的缺点" tabindex="-1"><a class="header-anchor" href="#gvisor的缺点"><span>gVisor的缺点：</span></a></h4><ul><li>gVisor还是一个比较新的项目，尚未被广泛测试和采用。</li><li>gVisor需要的内存和CPU资源比Kata Containers更多。</li><li>系统调用频繁的情况下gvisor的性能差</li></ul><h4 id="kata-containers的优点" tabindex="-1"><a class="header-anchor" href="#kata-containers的优点"><span>Kata Containers的优点：</span></a></h4><ul><li>Kata Containers运行在轻量级虚拟机中，可以提供与传统虚拟机相似的隔离性和安全性。</li><li>Kata Containers基于OCI标准，可以无缝地与Docker等容器工具集成。</li><li>Kata Containers比gVisor更易于部署和使用。</li><li>Kata Containers的启动时间通常在几百毫秒到一秒左右。</li></ul><h4 id="kata-containers的缺点" tabindex="-1"><a class="header-anchor" href="#kata-containers的缺点"><span>Kata Containers的缺点：</span></a></h4><ul><li>Kata Containers的启动速度比gVisor慢（但kata速度仍然非常快，通常在毫秒级别），因为它需要启动轻量级虚拟机。</li><li>由于使用了轻量级虚拟机，Kata Containers的性能比gVisor略低。</li></ul><p>需要注意的是，以上优缺点只是大概的总结，实际的情况可能会因特定的使用场景和需求而发生变化。</p>',42)]))}]]),t=JSON.parse('{"path":"/posts/kubernetes/kubernetes%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8.html","title":"kubernetes容器安全","lang":"zh-CN","frontmatter":{"title":"kubernetes容器安全","index_img":"/images/bg/k8s.webp","banner_img":"/images/bg/5.jpg","tags":["kubernetes"],"categories":["kubernetes"],"date":"2023-04-23T18:40:12.000Z","excerpt":"介绍k8s操作系统底层资源分割逻辑","sticky":1,"hide":false,"description":"课题 容器在k8s是什么 容器运行时Container Runtime是什么意思 Kubernetes中的容器可能会有哪些安全风险 模拟docker的容器A非法访问容器B的资源 NetworkNamespace是在Linux内核中实现的一种机制，用于隔离网络资源，例如网络接口、路由表和iptables规则等 kata是什么 容器逻辑上分割，物理上的资源...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/kubernetes/kubernetes%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8.html"}],["meta",{"property":"og:site_name","content":"QuickStart程序员"}],["meta",{"property":"og:title","content":"kubernetes容器安全"}],["meta",{"property":"og:description","content":"课题 容器在k8s是什么 容器运行时Container Runtime是什么意思 Kubernetes中的容器可能会有哪些安全风险 模拟docker的容器A非法访问容器B的资源 NetworkNamespace是在Linux内核中实现的一种机制，用于隔离网络资源，例如网络接口、路由表和iptables规则等 kata是什么 容器逻辑上分割，物理上的资源..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://weiqiangxu.github.io/images/什么是k8s的CRI-O.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"kubernetes"}],["meta",{"property":"article:published_time","content":"2023-04-23T18:40:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"kubernetes容器安全\\",\\"image\\":[\\"https://weiqiangxu.github.io/images/什么是k8s的CRI-O.png\\",\\"https://weiqiangxu.github.io/images/早期的k8s与docker.png\\",\\"https://weiqiangxu.github.io/images/containerd集成cri-containerd-shim后架构图.png\\",\\"https://weiqiangxu.github.io/images/docker和containerd关系.png\\",\\"https://weiqiangxu.github.io/images/docker依赖k8s标准.png\\",\\"https://weiqiangxu.github.io/images/k8s-v1.20-24分离docker-shim.png\\",\\"https://weiqiangxu.github.io/images/k8s-v1.20之前内置docker-shim.png\\",\\"https://weiqiangxu.github.io/images/k8s-v1.24之后自行安装cri-dockerd.png\\",\\"https://weiqiangxu.github.io/images/k8s分离docker-shim.png\\",\\"https://weiqiangxu.github.io/images/k8s与docker分离的初步计划.png\\",\\"https://weiqiangxu.github.io/images/kubelet和containerd简化调用链过程.png\\",\\"https://weiqiangxu.github.io/images/kubelet与容器运行时.png\\",\\"https://weiqiangxu.github.io/images/k8s分离docker-shim.png\\"],\\"datePublished\\":\\"2023-04-23T18:40:12.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"课题","slug":"课题","link":"#课题","children":[]},{"level":3,"title":"课题方向","slug":"课题方向","link":"#课题方向","children":[]},{"level":3,"title":"架构图","slug":"架构图","link":"#架构图","children":[]},{"level":3,"title":"相关资料","slug":"相关资料","link":"#相关资料","children":[]},{"level":3,"title":"gVisor和Kata Containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点：","slug":"gvisor和kata-containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点","link":"#gvisor和kata-containers都是用于提供容器运行时隔离性的开源技术选项。以下是它们各自的优缺点","children":[]}],"readingTime":{"minutes":9.33,"words":2798},"filePathRelative":"posts/kubernetes/kubernetes容器安全.md","localizedDate":"2023年4月24日","autoDesc":true}')}}]);