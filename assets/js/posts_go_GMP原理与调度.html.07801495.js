"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2257],{6262:(e,i)=>{i.A=(e,i)=>{const n=e.__vccOpts||e;for(const[e,a]of i)n[e]=a;return n}},6453:(e,i,n)=>{n.r(i),n.d(i,{comp:()=>l,data:()=>t});var a=n(641);const s={},l=(0,n(6262).A)(s,[["render",function(e,i){return(0,a.uX)(),(0,a.CE)("div",null,i[0]||(i[0]=[(0,a.Fv)('<h1 id="gmp原理与调度" tabindex="-1"><a class="header-anchor" href="#gmp原理与调度"><span>GMP原理与调度</span></a></h1><h3 id="一、概念" tabindex="-1"><a class="header-anchor" href="#一、概念"><span>一、概念</span></a></h3><h5 id="_1-g-goroutine-轻量级用户线程" tabindex="-1"><a class="header-anchor" href="#_1-g-goroutine-轻量级用户线程"><span>1.G（Goroutine）轻量级用户线程</span></a></h5><pre><code>用户态的线程，轻量级，上下文切换全部由语言层面实现，初始栈大小通常只有2KB左右。\n</code></pre><h5 id="_2-m-machine-操作系统线程" tabindex="-1"><a class="header-anchor" href="#_2-m-machine-操作系统线程"><span>2.M（Machine）操作系统线程</span></a></h5><pre><code>M从调度队列中获取到一个Goroutine后，就会开始执行它，如果 Goroutine 发生了阻塞（如进行 I/O 操作、等待锁等），M会尝试从本地调度器的队列中获取其他可执行的 Goroutine 来继续执行。runtime/debug.SetMaxThreads设置M的最大数量。\n</code></pre><h5 id="_3-p-processor-逻辑处理器" tabindex="-1"><a class="header-anchor" href="#_3-p-processor-逻辑处理器"><span>3.P（Processor）逻辑处理器</span></a></h5><pre><code>P是Go运行时对操作系统资源的一种抽象，它可以看作是一个逻辑处理器。管理和调度 Goroutine，每个 P 都有自己的本地 Goroutine 队列。P相当于是M和G的中间人，M通过P获取G，如果 P 的本地队列为空，M 可以从其他 P 的队列或者全局队列中获取G。\n</code></pre><h3 id="二、设计策略" tabindex="-1"><a class="header-anchor" href="#二、设计策略"><span>二、设计策略</span></a></h3><h5 id="_1-工作窃取-work-stealing-算法" tabindex="-1"><a class="header-anchor" href="#_1-工作窃取-work-stealing-算法"><span>1.工作窃取（Work-Stealing）算法</span></a></h5><pre><code>P的本地 Goroutine 队列空了，它可以从其他 P 的队列或者全局队列中 “窃取” Goroutine 来执行，高效的调度机制。\n</code></pre><h5 id="_2-动态调整-m-machine-的数量" tabindex="-1"><a class="header-anchor" href="#_2-动态调整-m-machine-的数量"><span>2.动态调整 M（Machine）的数量</span></a></h5><pre><code>在系统负载较轻时，不会因为过多的线程而浪费系统资源；而在系统负载较重，需要更多的计算资源时，能够及时地增加线程数量来满足需求。\n</code></pre><h4 id="_3-hand-off-机制" tabindex="-1"><a class="header-anchor" href="#_3-hand-off-机制"><span>3.hand off 机制</span></a></h4><pre><code>本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，让 M 挂载其他 P，执行其他P的G，让M的资源得到更高效率的应用。\n</code></pre><h3 id="三、gmp的状态流转" tabindex="-1"><a class="header-anchor" href="#三、gmp的状态流转"><span>三、GMP的状态流转</span></a></h3><h5 id="_1-goroutine状态" tabindex="-1"><a class="header-anchor" href="#_1-goroutine状态"><span>1.Goroutine状态</span></a></h5><blockquote><p>Go\\src\\runtime\\runtime2.go</p></blockquote><ol><li>_Gidle = 0 刚刚被分配并且还没有被初始化</li><li>_Grunnable = 1 准备好被调度器分配到一个处理器核心上执行，但还未被选中执行</li><li>_Grunning = 2 正在一个处理器核心上执行时，被赋予了内核线程 M 和处理器 P</li><li>_Gsyscall = 3 当goroutine正在执行一个系统调用时，它处于系统调用状态，goroutine 会被阻塞，例如，进行文件 I/O、网络 I/O</li><li>_Gwaiting = 4 当goroutine正在等待某个条件满足时处于等待状态,比如等待一个通道（channel）或者time.Sleep.</li><li>_Gdead = 6 当goroutine已死亡，不再执行任何代码，也不会被调度器再次调度执行，占用的资源（如栈空间等）可以被回收.</li></ol><blockquote><p>有几个状态是不用去理会的</p></blockquote><ul><li>_Genqueue_unused（目前未使用）</li><li>_Gcopystack=8 （不在运行队列上）</li><li>_Gpreempted=9 （没有执行用户代码）</li><li>_Gscan=10 GC （没有执行代码，可以与其他状态同时存在 ）</li></ul><h5 id="_2-m状态" tabindex="-1"><a class="header-anchor" href="#_2-m状态"><span>2.M状态</span></a></h5><ol><li>执行用户代码（Executing user code）正在执行一个 goroutine 的用户代码</li><li>执行系统调用（Executing system call）进行文件 I/O、网络 I/O 等操作时.</li><li>闲置状态（Idle）</li><li>自旋状态（Spinning） 当没有可运行的 goroutine 但是预计很快就有新的 goroutine，减少上下文切换的开销，不进入闲置而是直接自旋.</li></ol><h5 id="_3-p状态" tabindex="-1"><a class="header-anchor" href="#_3-p状态"><span>3.P状态</span></a></h5><ol><li>Pidle：当前p尚未与任何m关联，处于空闲状态</li><li>Prunning：当前p已经和m关联，并且正在运行g代码</li><li>Psyscall：当前p正在执行系统调用</li><li>Pgcstop：当前p需要停止调度，一般在GC前或者刚被创建时</li><li>Pdead：当前p已死亡，不会再被调度</li></ol><h3 id="相关文章" tabindex="-1"><a class="header-anchor" href="#相关文章"><span>相关文章</span></a></h3><p><a href="https://zhuanlan.zhihu.com/p/618222173" target="_blank" rel="noopener noreferrer">Go调度系列--GMP状态流转</a></p><h3 id="四、q-a" tabindex="-1"><a class="header-anchor" href="#四、q-a"><span>四、Q&amp;A</span></a></h3><ol><li><p>M和P的数量关系</p><p>M和P的数量没有绝对的关系，因为M是动态的，只是执行之中的M只能有1个P，启动以后P是固定的而M是动态的。P的数量是可以使用runtime.GOMAXPROCS设置。M是动态的不够用的时候就会创建 （随时创建） 只能限定最大数量，P是固定数量的 GOMAXPROCS配置 （启动时候就创建）.</p></li><li><p>GMP之中的抢占式调度是什么意思</p><p>一种任务调度策略。在这种策略下，操作系统（或运行时环境）可以在一个任务（如线程、进程或 Go 语言中的 Goroutine）执行过程中，中断它的执行，将 CPU 资源分配给其他任务。注意：不依赖任务自身主动放弃 CPU 资源，而是由系统强制进行资源分配。</p><p>比如在 Go 中，一个 goroutine 占用 CPU 较长时间（并非严格的10ms），运行时（runtime）会中断它的执行，主要基于信号（如 SIGURG）来触发抢占，比如运行时发送信号暂停这个Goroutine的执行，防止其他 goroutine 被饿死，这是抢占式调度。</p></li><li><p>GMP的一个M对应操作系统内核的一个线程，对吗</p><p>在 Go 语言的 GMP 模型中，一个 M（Machine）通常对应操作系统内核的一个线程。M 是真正执行计算任务的实体，它需要借助操作系统提供的线程来运行，这些线程可以在 CPU 上执行指令。</p></li><li><p>在G里面创建G(go func(){xxx})</p><p>在Go语言中的GMP模型中，创建Goroutine的时候，协程创建后会将G直接加入P的本地队列runq之中。</p></li><li><p>goroutine在time.Sleep后状态流转是什么样子的</p><p>goroutine当执行 time.Sleep 时，goroutine 进入等待中状态（Waiting），指定的睡眠时间过去后，goroutine 再次变为可运行状态（Runnable），等待被调度器分配到一个处理器核心上执行。</p></li><li><p>goroutine的唤醒是如何实现的</p><ul><li>channel</li><li>time.After\\time.Ticker</li><li>sync.Cond</li></ul></li><li><p>sync.Cond的底层</p><div class="language-go line-numbers-mode" data-highlighter="shiki" data-ext="go" data-title="go" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">type</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Cond</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> struct</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 本质是使用互斥锁实现的</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    L</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> Locker</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 管理等待条件满足的 Goroutine 列表</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 简单理解为它包含了一个用于存储等待 Goroutine 相关信息的队列结构</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    notify</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;">  notifyList</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // 防止Cond结构被意外复制</span></span>\n<span class="line"><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">    // checker结构会在运行时检查Cond是否被复制一旦发现复制行为会触发错误</span></span>\n<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    checker</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> copyChecker</span></span>\n<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h3 id="相关资料" tabindex="-1"><a class="header-anchor" href="#相关资料"><span>相关资料</span></a></h3><ul><li><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></li><li><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" target="_blank" rel="noopener noreferrer">topgoer GMP 原理与调度 - 简单易懂</a></li><li><a href="https://geektutu.com/post/high-performance-go.html" target="_blank" rel="noopener noreferrer">GO语言高性能编程</a></li><li><a href="https://www.topgoer.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html" target="_blank" rel="noopener noreferrer">GMP 原理与调度</a></li><li><a href="https://zhuanlan.zhihu.com/p/618222173" target="_blank" rel="noopener noreferrer">Go调度系列--GMP状态流转</a></li><li><a href="https://www.bilibili.com/video/BV1hv411x7we" target="_blank" rel="noopener noreferrer">幼麟实验室Golang</a></li></ul>',31)]))}]]),t=JSON.parse('{"path":"/posts/go/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html","title":"GMP原理与调度","lang":"zh-CN","frontmatter":{"description":"GMP原理与调度 一、概念 1.G（Goroutine）轻量级用户线程 2.M（Machine）操作系统线程 3.P（Processor）逻辑处理器 二、设计策略 1.工作窃取（Work-Stealing）算法 2.动态调整 M（Machine）的数量 3.hand off 机制 三、GMP的状态流转 1.Goroutine状态 Go\\\\src\\\\runt...","gitInclude":[],"head":[["meta",{"property":"og:url","content":"https://weiqiangxu.github.io/posts/go/GMP%E5%8E%9F%E7%90%86%E4%B8%8E%E8%B0%83%E5%BA%A6.html"}],["meta",{"property":"og:site_name","content":"笔记本"}],["meta",{"property":"og:title","content":"GMP原理与调度"}],["meta",{"property":"og:description","content":"GMP原理与调度 一、概念 1.G（Goroutine）轻量级用户线程 2.M（Machine）操作系统线程 3.P（Processor）逻辑处理器 二、设计策略 1.工作窃取（Work-Stealing）算法 2.动态调整 M（Machine）的数量 3.hand off 机制 三、GMP的状态流转 1.Goroutine状态 Go\\\\src\\\\runt..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GMP原理与调度\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"xuweiqiang\\",\\"url\\":\\"https://weiqiangxu.github.io\\"}]}"]]},"headers":[{"level":3,"title":"一、概念","slug":"一、概念","link":"#一、概念","children":[]},{"level":3,"title":"二、设计策略","slug":"二、设计策略","link":"#二、设计策略","children":[]},{"level":3,"title":"三、GMP的状态流转","slug":"三、gmp的状态流转","link":"#三、gmp的状态流转","children":[]},{"level":3,"title":"相关文章","slug":"相关文章","link":"#相关文章","children":[]},{"level":3,"title":"四、Q&A","slug":"四、q-a","link":"#四、q-a","children":[]},{"level":3,"title":"相关资料","slug":"相关资料","link":"#相关资料","children":[]}],"readingTime":{"minutes":5.52,"words":1657},"filePathRelative":"posts/go/GMP原理与调度.md","excerpt":"\\n<h3>一、概念</h3>\\n<h5>1.G（Goroutine）轻量级用户线程</h5>\\n<pre><code>用户态的线程，轻量级，上下文切换全部由语言层面实现，初始栈大小通常只有2KB左右。\\n</code></pre>\\n<h5>2.M（Machine）操作系统线程</h5>\\n<pre><code>M从调度队列中获取到一个Goroutine后，就会开始执行它，如果 Goroutine 发生了阻塞（如进行 I/O 操作、等待锁等），M会尝试从本地调度器的队列中获取其他可执行的 Goroutine 来继续执行。runtime/debug.SetMaxThreads设置M的最大数量。\\n</code></pre>","autoDesc":true}')}}]);